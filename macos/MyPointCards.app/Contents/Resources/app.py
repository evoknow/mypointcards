#!/usr/bin/env python3
# Web server app for MyPointCards

import os
import sys
import socket
import http.server
import socketserver
import threading
import time
import signal
import atexit
import subprocess
import webbrowser
import json
import logging
import traceback

# App name (defined at the global scope)
APP_NAME = 'MyPointCards'

# Setup logging
LOG_FILE = os.path.expanduser("~/Library/Logs/mypointcards_app.log")
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(APP_NAME)

# Configuration
PORT = 8000
PID_FILE = "/tmp/mypointcards_app.pid"
HTML_CONTENT = '<!DOCTYPE html>\n<html lang="en" data-bs-theme="light">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>MyPointCards</title>\n    <!-- Bootstrap CSS -->\n    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">\n    <!-- Font Awesome -->\n    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">\n    <!-- Google Fonts -->\n\n    <!-- Google Fonts -->\n<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Montserrat:wght@400;700&family=Poppins:wght@400;700&family=Nunito:wght@400;700&family=Noto+Sans:wght@400;700&family=Noto+Sans+Bengali:wght@400;700&family=Noto+Sans+SC:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+KR:wght@400;700&family=Noto+Sans+Arabic:wght@400;700&family=Bungee+Tint&family=Roboto+Condensed:wght@400;700&family=Oswald:wght@400;700&family=Bebas+Neue&family=Pacifico&display=swap" rel="stylesheet">\n\n\n    <!-- Basic icon for most devices -->\n    <link rel="icon" href="https://v1.mypoint.cards/icons/favicon.ico" type="image/x-icon">\n\n    <!-- Apple Touch Icons for iOS home screen -->\n    <link rel="apple-touch-icon" href="https://v1.mypoint.cards/icons/apple-touch-icon.png">\n    <link rel="apple-touch-icon" sizes="57x57" href="https://v1.mypoint.cards/icons/apple-touch-icon-57x57.png">\n    <link rel="apple-touch-icon" sizes="60x60" href="https://v1.mypoint.cards/icons/apple-touch-icon-60x60.png">\n    <link rel="apple-touch-icon" sizes="72x72" href="https://v1.mypoint.cards/icons/apple-touch-icon-72x72.png">\n    <link rel="apple-touch-icon" sizes="76x76" href="https://v1.mypoint.cards/icons/apple-touch-icon-76x76.png">\n    <link rel="apple-touch-icon" sizes="114x114" href="https://v1.mypoint.cards/icons/apple-touch-icon-114x114.png">\n    <link rel="apple-touch-icon" sizes="120x120" href="https://v1.mypoint.cards/icons/apple-touch-icon-120x120.png">\n    <link rel="apple-touch-icon" sizes="144x144" href="https://v1.mypoint.cards/icons/apple-touch-icon-144x144.png">\n    <link rel="apple-touch-icon" sizes="152x152" href="https://v1.mypoint.cards/icons/apple-touch-icon-152x152.png">\n    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://v1.mypoint.cards/icons/apple-touch-icon-180x180.png">\n\n    <!-- iOS status bar -->\n    <meta name="mobile-web-app-capable" content="yes">\n    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">\n    <meta name="apple-mobile-web-app-title" content="MyPointCards">\n\n\n\n    <style>\n        body {\n            background-color: #f0f2f5;\n            font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif;\n            padding: 0px;\n        }\n        \n\n          /* Add these CSS variables */\n    :root {\n        --body-bg: #f0f2f5;\n        --card-bg: #ffffff;\n        --text-color: #333333;\n        --border-color: rgba(0, 0, 0, 0.1);\n        --input-bg: #ffffff;\n        --toolbar-bg: #ffffff;\n        --toolbar-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n        --nav-color: #444;\n        --nav-active-color: #1877f2;\n        --alert-bg: rgba(255, 255, 255, 0.9);\n    }\n    \n   /* Refined dark mode styling to make elements blend better */\n\n/* Improve dark mode variables with softer colors */\n[data-bs-theme="dark"] {\n    /* Softer background colors */\n    --body-bg: #121212;\n    --card-bg: #1e1e1e;\n    --toolbar-bg: #1a1a1a;\n    --input-bg: #242424;\n    --dropdown-bg: #242424;\n    --tab-active-bg: #2a2a2a;\n    \n    /* Softer text colors */\n    --text-color: #d8d8d8;\n    --input-text-color: #d8d8d8;\n    --dropdown-text: #d8d8d8;\n    \n    /* Improved border colors */\n    --border-color: rgba(255, 255, 255, 0.08);\n    --form-control-border: rgba(255, 255, 255, 0.1);\n    \n    /* Better accent colors */\n    --nav-active-color: #4f9eff;\n    \n    /* Better shadows */\n    --toolbar-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);\n}\n\n/* Soften textarea/input styling in dark mode */\n[data-bs-theme="dark"] .form-control {\n    background-color: var(--input-bg);\n    color: var(--input-text-color);\n    border-color: var(--form-control-border);\n}\n\n/* Make textarea blend better with background */\n[data-bs-theme="dark"] textarea.form-control {\n    background-color: #242424;\n    color: #d8d8d8;\n    border-color: rgba(255, 255, 255, 0.08);\n}\n\n/* Improve tab styling for better integration */\n[data-bs-theme="dark"] .nav-tabs {\n    border-bottom-color: #333;\n}\n\n[data-bs-theme="dark"] .nav-tabs .nav-link {\n    color: #999;\n    background-color: transparent;\n}\n\n[data-bs-theme="dark"] .nav-tabs .nav-link.active {\n    color: var(--nav-active-color);\n    background-color: var(--tab-active-bg);\n    border-color: #333 #333 var(--tab-active-bg);\n}\n\n[data-bs-theme="dark"] .nav-tabs .nav-link:hover:not(.active) {\n    border-color: rgba(255, 255, 255, 0.05);\n    background-color: rgba(255, 255, 255, 0.03);\n}\n\n/* Better integration of dropdown styling */\n[data-bs-theme="dark"] .form-select {\n    background-color: var(--dropdown-bg);\n    color: var(--dropdown-text);\n    border-color: var(--form-control-border);\n}\n\n/* Soften labels and text */\n[data-bs-theme="dark"] .form-label,\n[data-bs-theme="dark"] .form-text,\n[data-bs-theme="dark"] .form-check-label {\n    color: #aaa;\n}\n\n/* Reduce contrast on secondary elements */\n[data-bs-theme="dark"] .text-muted {\n    color: #888 !important;\n}\n\n/* Make toolbar blend better */\n[data-bs-theme="dark"] .toolbar {\n    background-color: var(--toolbar-bg);\n    border-color: rgba(255, 255, 255, 0.05);\n}\n\n/* Make the theme toggle blend better */\n[data-bs-theme="dark"] .theme-toggle {\n    background-color: #242424;\n    border-color: rgba(255, 255, 255, 0.08);\n}\n\n/* Customize font preview for better integration */\n[data-bs-theme="dark"] .font-preview {\n    background-color: #242424;\n    border-color: rgba(255, 255, 255, 0.08);\n}\n\n[data-bs-theme="dark"] .font-preview:hover {\n    background-color: #2a2a2a;\n}\n\n[data-bs-theme="dark"] .font-preview.active {\n    border-color: var(--nav-active-color);\n    background-color: rgba(79, 158, 255, 0.08);\n}\n\n/* Improve form range track */\n[data-bs-theme="dark"] .form-range::-webkit-slider-runnable-track {\n    background-color: #333;\n}\n\n/* Fix active tab indicator */\n[data-bs-theme="dark"] .nav-tabs .nav-item.show .nav-link, \n[data-bs-theme="dark"] .nav-tabs .nav-link.active {\n    background-color: var(--tab-active-bg);\n    border-color: #333 #333 var(--tab-active-bg);\n}\n\n/* Reduce the intensity of alert backgrounds */\n[data-bs-theme="dark"] .alert-info,\n[data-bs-theme="dark"] .alert-warning,\n[data-bs-theme="dark"] .alert-success,\n[data-bs-theme="dark"] .alert-danger {\n    background-color: rgba(30, 30, 30, 0.8);\n    border-color: rgba(255, 255, 255, 0.1);\n}\n\n/* Better button styling for dark mode */\n[data-bs-theme="dark"] .btn-outline-primary {\n    border-color: rgba(79, 158, 255, 0.5);\n    color: var(--nav-active-color);\n}\n\n/* Remove black border from active color boxes */\n[data-bs-theme="dark"] .color-box.active,\n[data-bs-theme="dark"] .gradient-box.active {\n    border-color: var(--nav-active-color);\n}\n    /* Update these existing styles */\n    body {\n        background-color: var(--body-bg);\n        color: var(--text-color);\n        font-family: \'Segoe UI\', Tahoma, Geneva, Verdana, sans-serif;\n        padding: 0px;\n        transition: background-color 0.3s ease, color 0.3s ease;\n    }\n    \n    .toolbar {\n        background-color: var(--toolbar-bg);\n        border-radius: 10px;\n        padding: 15px;\n        margin: 20px 0;\n        box-shadow: var(--toolbar-shadow);\n        border: 1px solid var(--border-color);\n    }\n    \n    .nav-tabs .nav-link {\n        color: var(--nav-color);\n    }\n    \n    .nav-tabs .nav-link.active {\n        font-weight: bold;\n        color: var(--nav-active-color);\n        background-color: var(--toolbar-bg);\n    }\n    \n    .form-control, .form-select {\n        background-color: var(--input-bg);\n        color: var(--text-color);\n        border-color: var(--border-color);\n    }\n    \n    .form-control:focus, .form-select:focus {\n        background-color: var(--input-bg);\n        color: var(--text-color);\n    }\n    \n    .font-preview {\n        background-color: var(--input-bg);\n        border-color: var(--border-color);\n    }\n    \n    .font-preview:hover {\n        background-color: var(--input-bg);\n    }\n    \n    .font-preview.active {\n        background-color: rgba(24, 119, 242, 0.1);\n    }\n    \n    /* Dark mode toggle styles */\n    .theme-toggle {\n        position: fixed;\n        top: 15px;\n        right: 15px;\n        z-index: 1000;\n        background-color: var(--toolbar-bg);\n        border-radius: 50px;\n        padding: 5px 12px;\n        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);\n        border: 1px solid var(--border-color);\n        cursor: pointer;\n        display: flex;\n        align-items: center;\n        gap: 8px;\n        transition: all 0.3s ease;\n    }\n    \n    .theme-toggle:hover {\n        transform: scale(1.05);\n    }\n    \n    .theme-toggle i {\n        font-size: 16px;\n    }\n\n    .app_title {\n\n        font-size: 1.2em;\n        color: #999;\n    }\n\n        .card-preview {\n                width: 100%;\n                max-width: 500px;\n                height: 300px;\n                position: relative;\n                overflow: hidden;\n                border-radius: 12px;\n                box-shadow: 0 4px 12px rgba(0,0,0,0.1);\n                margin: 0 auto;\n                background-color: #ED213A;\n                background-size: contain;\n                background-position: center;\n                background-repeat: no-repeat !important;\n        }\n\n        .card-text {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            transform: translate(-50%, -50%);\n            color: white;\n            text-align: center;\n            width: 90%;\n            font-size: 32px;\n            font-weight: bold;\n            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);\n            word-wrap: break-word;\n            white-space: pre-wrap; /* This preserves line breaks */\n        }\n        \n        .toolbar {\n            background-color: white;\n            border-radius: 10px;\n            padding: 15px;\n            margin: 20px 0;\n            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n        }\n        \n        .nav-tabs .nav-link {\n            color: #444;\n        }\n        \n        .nav-tabs .nav-link.active {\n            font-weight: bold;\n            color: #1877f2;\n        }\n        \n        .color-box {\n            width: 30px;\n            height: 30px;\n            display: inline-block;\n            cursor: pointer;\n            margin: 5px;\n            border-radius: 5px;\n            border: 2px solid transparent;\n        }\n        \n        .color-box.active {\n            border-color: black;\n        }\n        \n        .emoji {\n            font-size: 24px;\n            margin: 5px;\n            cursor: pointer;\n            display: inline-block;\n        }\n        \n        .giphy-image {\n            width: 120px;\n            height: 120px;\n            object-fit: cover;\n            cursor: pointer;\n            border-radius: 8px;\n            margin: 5px;\n            transition: transform 0.2s;\n        }\n        \n        .giphy-image:hover {\n            transform: scale(1.05);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.2);\n        }\n        \n        .featured-image {\n            width: 120px;\n            height: 120px;\n            object-fit: cover;\n            cursor: pointer;\n            border-radius: 8px;\n            margin: 5px;\n            transition: transform 0.2s;\n        }\n        \n        .featured-image:hover {\n            transform: scale(1.05);\n            box-shadow: 0 4px 8px rgba(0,0,0,0.2);\n        }\n        \n        .featured-image-container {\n            position: relative;\n            display: inline-block;\n            margin: 5px;\n        }\n        \n        .featured-image-container .image-info {\n            display: none;\n            position: absolute;\n            bottom: 0;\n            left: 0;\n            right: 0;\n            background-color: rgba(0, 0, 0, 0.7);\n            color: white;\n            padding: 5px;\n            font-size: 12px;\n            border-radius: 0 0 8px 8px;\n        }\n        \n        .featured-image-container:hover .image-info {\n            display: block;\n        }\n        \n        /* Toast/alert animations */\n        @keyframes slideInFadeOut {\n            0% { transform: translateY(100px); opacity: 0; }\n            10% { transform: translateY(0); opacity: 1; }\n            90% { transform: translateY(0); opacity: 1; }\n            100% { transform: translateY(-20px); opacity: 0; }\n        }\n        \n        .alert.position-fixed {\n            animation: slideInFadeOut 3s forwards;\n            z-index: 9999;\n            box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n        }\n\n        .gradient-box {\n            width: 30px;\n            height: 30px;\n            display: inline-block;\n            cursor: pointer;\n            margin: 5px;\n            border-radius: 5px;\n            border: 2px solid transparent;\n        }\n\n        .gradient-box.active {\n            border-color: black;\n        }\n\n        .powered-by {\n            position: absolute;\n            bottom: 5px;\n            right: 10px;\n            font-size: 10px;\n            color: rgba(255, 255, 255, 0.7);\n            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);\n        }\n\n        .font-preview {\n            border: 1px solid #ddd;\n            padding: 8px;\n            margin-bottom: 10px;\n            border-radius: 4px;\n            cursor: pointer;\n            transition: background-color 0.2s;\n        }\n\n        .font-preview:hover {\n            background-color: #f8f9fa;\n        }\n\n        .font-preview.active {\n            border-color: #1877f2;\n            background-color: #e9f0ff;\n        }\n\n        /* Add this CSS to center the preview text and align it with the card */\n        .preview-container {\n          text-align: center;\n          margin-top: 1rem;\n        }\n\n        .preview-container p {\n          display: inline-block;\n          margin: 0 auto;\n          font-weight: 500;\n        }\n\n        .preview-container strong {\n          font-weight: 700;\n        }\n\n\n\n    \n    /* Mobile styles */\n    @media (max-width: 768px) {\n        .card-preview {\n            height: 250px;\n        }\n        \n        .toolbar {\n            padding: 10px;\n        }\n        \n        .nav-tabs .nav-link {\n            padding: 0.5rem 0.5rem;\n            font-size: 0.9rem;\n        }\n        \n        .font-preview {\n            padding: 4px;\n        }\n        \n        .giphy-image, .featured-image {\n            width: 90px;\n            height: 90px;\n        }\n        \n        /* Better spacing for mobile forms */\n        .form-label {\n            margin-bottom: 0.25rem;\n        }\n        \n        .mb-3 {\n            margin-bottom: 0.75rem !important;\n        }\n        \n        /* Adjust card text size for mobile */\n        .card-text {\n            font-size: 24px;\n        }\n    }\n    \n    /* Small mobile devices */\n    @media (max-width: 576px) {\n        .card-preview {\n            height: 200px;\n        }\n        \n        .card-text {\n            font-size: 20px;\n        }\n        \n        /* Stack the color boxes for better mobile experience */\n        .color-box, .gradient-box {\n            margin: 3px;\n        }\n        \n        /* Make the buttons more tappable */\n        .btn {\n            padding: 0.5rem;\n            margin-bottom: 0.5rem;\n        }\n    }\n\n\n    .emoji-container {\n        display: flex;\n        flex-wrap: wrap;\n        max-height: 200px;\n        overflow-y: auto;\n    }\n    \n    .emoji {\n        font-size: 24px;\n        margin: 5px;\n        cursor: pointer;\n        display: inline-block;\n    }\n    \n    @media (max-width: 768px) {\n        .emoji-container {\n            max-height: 150px;\n        }\n        \n        .emoji {\n            font-size: 20px;\n            margin: 3px;\n        }\n    }\n\n\n    @media (max-width: 576px) {\n        .nav-tabs {\n            display: flex;\n            flex-wrap: nowrap;\n            overflow-x: auto;\n            white-space: nowrap;\n            -webkit-overflow-scrolling: touch;\n        }\n        \n        .nav-tabs .nav-item {\n            float: none;\n            flex-shrink: 0;\n        }\n    }\n\n    @media (max-width: 768px) {\n        /* Stack the font controls on mobile */\n        #text .row .col-md-5,\n        #text .row .col-md-3,\n        #text .row .col-md-4,\n        #text .row .col-md-6 {\n            width: 100%;\n            margin-bottom: 10px;\n        }\n    }\n\n   /* Inline Buttons Styling */\n    .button-container {\n        margin-top: 15px;\n    }\n    \n    .button-container .btn {\n        min-width: 120px;\n        white-space: nowrap;\n    }\n    \n    /* Responsive adjustments */\n    @media (max-width: 767px) {\n        .button-container {\n            flex-direction: row;\n        }\n        \n        .button-container .btn {\n            font-size: 0.9rem;\n            padding: 0.4rem 0.5rem;\n        }\n    }\n    \n    /* Very small screens */\n    @media (max-width: 480px) {\n        .button-container .btn i {\n            margin-right: 4px;\n        }\n    }\n\n\n   h1 {\n      font-size: 1.4em;\n      padding-bottom: 10px;\n   }\n\n   @media (max-width: 768px) {\n    .featured-image-container .image-info {\n        display: none !important; /* Force hide the overlay on mobile */\n    }\n    \n    .featured-image-container:hover .image-info {\n        display: none !important; /* Ensure it stays hidden on hover for mobile */\n    }\n    \n    /* Make the clickable area larger and more obvious */\n    .featured-image {\n        border: 2px solid transparent;\n        transition: border-color 0.2s;\n    }\n    \n    .featured-image:active {\n        border-color: #1877f2; /* Add a blue border when tapped */\n    }\n}\n\n/* Optional: Add a tooltip that shows up on tap for mobile users */\n@media (max-width: 768px) {\n    #featuredResults {\n        position: relative;\n    }\n    \n    #mobileInfoTip {\n        display: none;\n        position: fixed;\n        bottom: 10px;\n        left: 50%;\n        transform: translateX(-50%);\n        background: rgba(0, 0, 0, 0.8);\n        color: white;\n        padding: 10px 15px;\n        border-radius: 20px;\n        font-size: 14px;\n        z-index: 1000;\n        text-align: center;\n        width: 90%;\n        max-width: 300px;\n    }\n\n}\n\n\n@media (max-width: 768px) {\n  .text-options-container {\n    overflow: hidden;\n    transition: max-height 0.3s ease, opacity 0.3s ease;\n    max-height: 0;\n    opacity: 0;\n  }\n  \n  .text-options-container.visible {\n    max-height: 1000px; /* Large enough to contain all options */\n    opacity: 1;\n  }\n  \n  .text-options-toggle {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    margin: 10px 0;\n    padding: 10px;\n    background-color: var(--toolbar-bg);\n    border-radius: 5px;\n    cursor: pointer;\n    border: 1px solid var(--border-color);\n    font-weight: 500;\n  }\n  \n  .text-options-toggle i {\n    margin-right: 8px;\n    font-size: 16px;\n  }\n  \n  .text-options-toggle:active {\n    background-color: rgba(0, 123, 255, 0.2);\n  }\n  \n  .text-options-toggle:hover {\n    background-color: rgba(0, 123, 255, 0.1);\n  }\n}\n\n    </style>\n</head>\n<body>\n    <div class="theme-toggle">\n        <i class="fas fa-sun"></i>\n        <div class="form-check form-switch d-inline-block m-0">\n            <input class="form-check-input" type="checkbox" id="themeSwitch">\n        </div>\n        <i class="fas fa-moon"></i>\n   </div>\n\n    <div class="container">\n        <h1 class="app_title pt-4">MyPointCards v1.1.2</h1>\n        \n        <div class="row">\n            <div class="col-md-6">\n                <div class="toolbar">\n                    <ul class="nav nav-tabs" id="myTab" role="tablist">\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link active" id="text-tab" data-bs-toggle="tab" data-bs-target="#text" type="button">\n                                  <span class="d-inline d-sm-none">Text</span>\n                                  <span class="d-none d-sm-inline">ğŸ…°ï¸ Text</span>\n                            </button>\n                        </li>\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link" id="background-tab" data-bs-toggle="tab" data-bs-target="#background" type="button">\n                                  <span class="d-inline d-sm-none">Colors</span>\n                                  <span class="d-none d-sm-inline">ğŸ¨ Colors</span>\n                            </button>\n                        </li>\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link" id="emoji-tab" data-bs-toggle="tab" data-bs-target="#emoji" type="button">\n                                <span class="d-inline d-sm-none">Emoji</span>\n                                <span class="d-none d-sm-inline">ğŸ˜„ Emoji</span>\n                            </button>\n                        </li>\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link" id="giphy-tab" data-bs-toggle="tab" data-bs-target="#giphy" type="button">\n                                <span class="d-inline d-sm-none">Giphy</span>\n                                <span class="d-none d-sm-inline">ğŸ–¼ï¸ Giphy</span>\n                            </button>\n                        </li>\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link" id="upload-tab" data-bs-toggle="tab" data-bs-target="#upload" type="button">\n                                <span class="d-inline d-sm-none">Upload</span>\n                                <span class="d-none d-sm-inline">â¬†ï¸ Upload</span>\n\n                            </button>\n                        </li>\n                        <li class="nav-item" role="presentation">\n                            <button class="nav-link" id="featured-tab" data-bs-toggle="tab" data-bs-target="#featured" type="button">\n                                <span class="d-inline d-sm-none">â­</span>\n                                <span class="d-none d-sm-inline">â­ Featured</span>\n\n                            </button>\n                        </li>\n                    </ul>\n                    \n                    <div class="tab-content p-3" id="myTabContent">\n                        <div class="tab-pane fade show active" id="text" role="tabpanel">\n                            <div class="mb-3">\n                                <label for="cardText" class="form-label">What\'s on your mind?</label>\n                                <textarea class="form-control" id="cardText" rows="3" placeholder="Type your message here..."></textarea>\n                            </div>\n                            <!-- Font Controls (all in one line) -->\n                            <div class="mb-3">\n                              <div class="row">\n\n                                <!-- Font Family -->\n                                <div class="col-md-5">\n                      \n                                  <select class="form-select" id="fontFamily">\n                                    <option value="">Select Font</option>\n                                    <option value="Roboto, sans-serif">Roboto (English)</option>\n                                    <option value="\'Roboto Condensed\', sans-serif">Roboto Condensed</option>\n                                    <option value="\'Bebas Neue\', sans-serif">Bebas Neue</option>\n                                    <option value="Oswald, sans-serif">Oswald</option>\n                                    <option value="Pacifico, cursive">Pacifico</option>\n                                    <option value="\'Bungee Tint\', cursive">Bungee Tint</option>\n                                    <option value="Open Sans, sans-serif">Open Sans</option>\n                                    <option value="Lato, sans-serif">Lato</option>\n                                    <option value="Montserrat, sans-serif">Montserrat</option>\n                                    <option value="Poppins, sans-serif">Poppins</option>\n                                    <option value="Nunito, sans-serif">Nunito</option>\n                                    <option value="\'Noto Sans Bengali\', sans-serif">Noto Sans Bengali (à¦¬à¦¾à¦‚à¦²à¦¾)</option>\n                                    <option value="\'Noto Sans SC\', sans-serif">Noto Sans SC (ç®€ä½“ä¸­æ–‡)</option>\n                                    <option value="\'Noto Sans JP\', sans-serif">Noto Sans JP (æ—¥æœ¬èª)</option>\n                                    <option value="\'Noto Sans KR\', sans-serif">Noto Sans KR (í•œêµ­ì–´)</option>\n                                    <option value="\'Noto Sans Arabic\', sans-serif">Noto Sans Arabic (Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)</option>\n                                  </select>\n                                </div>\n                                \n                                <!-- Font Size -->\n                                <div class="col-md-3">\n                                   Size: <span id="fontSizeValue">32</span>px\n                                  <input type="range" class="form-range" id="fontSize" min="20" max="120" step="1" value="32">\n                                </div>\n                                \n                                <!-- Font Color -->\n                                <div class="col-md-4">\n                            \n                                  <div class="d-flex align-items-center">\n                                    <input type="color" class="form-control form-control-color me-2" id="fontColor" value="#ffffff" title="Choose font color">\n                                    <span id="fontColorHex">#ffffff</span>\n                                  </div>\n                                </div>\n                              </div>\n                            </div>\n\n                            <div class="mb-3 d-flex align-items-center">\n                              <div class="me-3">\n                               \n                                <div class="btn-group" role="group" aria-label="Text alignment">\n                                  <input type="radio" class="btn-check" name="textAlign" id="alignLeft" autocomplete="off">\n                                  <label class="btn btn-outline-primary" for="alignLeft"><i class="fas fa-align-left"></i></label>\n                                  \n                                  <input type="radio" class="btn-check" name="textAlign" id="alignCenter" autocomplete="off" checked>\n                                  <label class="btn btn-outline-primary" for="alignCenter"><i class="fas fa-align-center"></i></label>\n                                  \n                                  <input type="radio" class="btn-check" name="textAlign" id="alignRight" autocomplete="off">\n                                  <label class="btn btn-outline-primary" for="alignRight"><i class="fas fa-align-right"></i></label>\n                                </div>\n                              </div>\n                              \n                              <div class="flex-grow-1">\n                                Line Height: <span id="lineHeightValue">1.2</span>\n                                <input type="range" class="form-range" id="lineHeight" min="0.8" max="2.0" step="0.1" value="1.2">\n                              </div>\n                            </div>\n\n\n                            <!-- Checkboxes in one line -->\n                            <div class="mb-3">\n                              <div class="row">\n                                <div class="col-md-6">\n                                  <div class="form-check">\n                                    <input type="checkbox" class="form-check-input" id="textShadow" checked>\n                                    <label class="form-check-label" for="textShadow">Text Shadow</label>\n                                  </div>\n                                </div>\n                                <div class="col-md-6">\n                                  <div class="form-check">\n                                    <input type="checkbox" class="form-check-input" id="poweredBy" checked>\n                                    <label class="form-check-label" for="poweredBy">Show "Powered by MyPoint.Cards"</label>\n                                  </div>\n                                </div>\n                              </div>\n                            </div>\n                        </div>\n                        \n                        <div class="tab-pane fade" id="background" role="tabpanel">\n                            <div class="mb-3">\n                                <label class="form-label">Choose a background color:</label>\n                                <div>\n                                    <div class="color-box active" style="background-color: #ED213A;" data-color="#ED213A"></div>\n                                    <div class="color-box" style="background-color: #3498db;" data-color="#3498db"></div>\n                                    <div class="color-box" style="background-color: #2ecc71;" data-color="#2ecc71"></div>\n                                    <div class="color-box" style="background-color: #f39c12;" data-color="#f39c12"></div>\n                                    <div class="color-box" style="background-color: #9b59b6;" data-color="#9b59b6"></div>\n                                    <div class="color-box" style="background-color: #34495e;" data-color="#34495e"></div>\n                                    <div class="color-box" style="background-color: #1abc9c;" data-color="#1abc9c"></div>\n                                    <div class="color-box" style="background-color: #000000;" data-color="#000000"></div>\n                                    <div class="color-box" style="background-color: #e74c3c;" data-color="#e74c3c"></div>\n                                    <div class="color-box" style="background-color: #f1c40f;" data-color="#f1c40f"></div>\n                                    <div class="color-box" style="background-color: #95a5a6;" data-color="#95a5a6"></div>\n                                    <div class="color-box" style="background-color: #ffffff;" data-color="#ffffff"></div>\n                                    <div class="color-box" style="background-color: #e84393;" data-color="#e84393"></div>\n                                    <div class="color-box" style="background-color: #8B4513;" data-color="#8B4513"></div>\n\n                                </div>\n                                <div class="mt-4">\n                                    <label class="form-label">Gradient backgrounds:</label>\n                                    <div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #f12711, #f5af19);" data-gradient="linear-gradient(to right, #f12711, #f5af19)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #8e2de2, #4a00e0);" data-gradient="linear-gradient(to right, #8e2de2, #4a00e0)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #00b09b, #96c93d);" data-gradient="linear-gradient(to right, #00b09b, #96c93d)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(45deg, #ff9a9e, #fad0c4);" data-gradient="linear-gradient(45deg, #ff9a9e, #fad0c4)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #4facfe, #00f2fe);" data-gradient="linear-gradient(to right, #4facfe, #00f2fe)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(135deg, #667eea, #764ba2);" data-gradient="linear-gradient(135deg, #667eea, #764ba2)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #2c3e50, #4ca1af);" data-gradient="linear-gradient(to right, #2c3e50, #4ca1af)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #f953c6, #b91d73);" data-gradient="linear-gradient(to right, #f953c6, #b91d73)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #11998e, #38ef7d);" data-gradient="linear-gradient(to right, #11998e, #38ef7d)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(45deg, #fc4a1a, #f7b733);" data-gradient="linear-gradient(45deg, #fc4a1a, #f7b733)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #43cea2, #185a9d);" data-gradient="linear-gradient(to right, #43cea2, #185a9d)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(135deg, #ff0844, #ffb199);" data-gradient="linear-gradient(135deg, #ff0844, #ffb199)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #2b5876, #4e4376);" data-gradient="linear-gradient(to right, #2b5876, #4e4376)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #6a3093, #a044ff);" data-gradient="linear-gradient(to right, #6a3093, #a044ff)"></div>\n\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #BF953F, #FCF6BA, #B38728, #FBF5B7, #AA771C);" data-gradient="linear-gradient(to right, #BF953F, #FCF6BA, #B38728, #FBF5B7, #AA771C)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #8e9eab, #eef2f3, #8e9eab);" data-gradient="linear-gradient(to right, #8e9eab, #eef2f3, #8e9eab)"></div>\n                                        <div class="gradient-box" style="background: linear-gradient(to right, #536976, #292E49, #536976);" data-gradient="linear-gradient(to right, #536976, #292E49, #536976)"></div>\n\n                                    </div>\n                                    \n                                    <div class="mt-3">\n                                        <label class="form-label">Create custom gradient:</label>\n                                        <div class="row">\n                                            <div class="col-md-5">\n                                                <input type="color" class="form-control form-control-color mb-2" id="gradientColor1" value="#ff0000">\n                                                <label for="gradientColor1" class="form-text">First color</label>\n                                            </div>\n                                            <div class="col-md-5">\n                                                <input type="color" class="form-control form-control-color mb-2" id="gradientColor2" value="#ffcc00">\n                                                <label for="gradientColor2" class="form-text">Second color</label>\n                                            </div>\n                                            <div class="col-md-2">\n                                                <button class="btn btn-sm btn-primary mt-1" id="applyCustomGradient">Apply</button>\n                                            </div>\n                                        </div>\n                                        <div class="form-text">\n                                            <select class="form-select form-select-sm mt-2" id="gradientDirection">\n                                                <option value="to right">Horizontal â†’</option>\n                                                <option value="to left">Horizontal â†</option>\n                                                <option value="to bottom">Vertical â†“</option>\n                                                <option value="to top">Vertical â†‘</option>\n                                                <option value="45deg">Diagonal â†˜</option>\n                                                <option value="135deg">Diagonal â†—</option>\n                                                <option value="225deg">Diagonal â†™</option>\n                                                <option value="315deg">Diagonal â†–</option>\n                                            </select>\n                                        </div>\n                                    </div>\n                                </div>\n\n                                \n                                <div class="mt-3">\n                                    <label for="customColor" class="form-label">Custom color:</label>\n                                    <input type="color" class="form-control form-control-color" id="customColor" value="#ED213A">\n                                </div>\n                            </div>\n                        </div>\n                        \n<div class="tab-pane fade" id="emoji" role="tabpanel">\n    <div class="mb-3">\n        <label class="form-label">Click an emoji to add to your text:</label>\n        \n        <h6 class="mt-3 mb-1">Smileys & Emotions</h6>\n        <div class="emoji-container">\n            <span class="emoji" title="Grinning Face">ğŸ˜€</span> <!-- Grinning Face -->\n            <span class="emoji" title="Face with Tears of Joy">ğŸ˜‚</span> <!-- Face with Tears of Joy -->\n            <span class="emoji" title="Smiling Face with Heart-Eyes">ğŸ˜</span> <!-- Smiling Face with Heart-Eyes -->\n            <span class="emoji" title="Smiling Face with Hearts">ğŸ¥°</span> <!-- Smiling Face with Hearts -->\n            <span class="emoji" title="Smiling Face with Sunglasses">ğŸ˜</span> <!-- Smiling Face with Sunglasses -->\n            <span class="emoji" title="Thinking Face">ğŸ¤”</span> <!-- Thinking Face -->\n            <span class="emoji" title="Grinning Face with Sweat">ğŸ˜…</span> <!-- Grinning Face with Sweat -->\n            <span class="emoji" title="Crying Face">ğŸ˜¢</span> <!-- Crying Face -->\n            <span class="emoji" title="Pouting Face">ğŸ˜¡</span> <!-- Pouting Face -->\n            <span class="emoji" title="Exploding Head">ğŸ¤¯</span> <!-- Exploding Head -->\n            <span class="emoji" title="Star-Struck">ğŸ¤©</span> <!-- Star-Struck -->\n            <span class="emoji" title="Sleeping Face">ğŸ˜´</span> <!-- Sleeping Face -->\n            <span class="emoji" title="Smiling Face with Halo">ğŸ˜‡</span> <!-- Smiling Face with Halo -->\n            <span class="emoji" title="Grimacing Face">ğŸ˜¬</span> <!-- Grimacing Face -->\n            <span class="emoji" title="Hugging Face">ğŸ¤—</span> <!-- Hugging Face -->\n            <span class="emoji" title="Partying Face">ğŸ¥³</span> <!-- Partying Face -->\n            <span class="emoji" title="Clown Face">ğŸ¤¡</span> <!-- Clown Face -->\n            <span class="emoji" title="Grinning Face with Smiling Eyes">ğŸ˜„</span> <!-- Grinning Face with Smiling Eyes -->\n            <span class="emoji" title="Slightly Smiling Face">ğŸ™‚</span> <!-- Slightly Smiling Face -->\n            <span class="emoji" title="Winking Face">ğŸ˜‰</span> <!-- Winking Face -->\n            <span class="emoji" title="Grinning Squinting Face">ğŸ˜†</span> <!-- Grinning Squinting Face -->\n            <span class="emoji" title="Partying Face">ğŸ¥³</span> <!-- Partying Face -->\n            <span class="emoji" title="Thinking Face">ğŸ¤”</span> <!-- Thinking Face -->\n            <span class="emoji" title="Smiling Face With Sunglasses">ğŸ˜</span> <!-- Smiling Face With Sunglasses -->\n            <span class="emoji" title="Smiling Face With Halo">ğŸ˜‡</span> <!-- Smiling Face With Halo -->\n            <span class="emoji" title="Loudly Crying Face">ğŸ˜­</span> <!-- Loudly Crying Face -->\n            <span class="emoji" title="Star-Struck">ğŸ¤©</span> <!-- Star-Struck -->\n            <span class="emoji" title="Exploding Head">ğŸ¤¯</span> <!-- Exploding Head -->\n            <span class="emoji" title="Pleading Face">ğŸ¥º</span> <!-- Pleading Face -->\n            <span class="emoji" title="Face with Steam From Nose">ğŸ˜¤</span> <!-- Face with Steam From Nose -->\n\n        </div>\n        \n        <h6 class="mt-3 mb-1">Gestures & People</h6>\n        <div class="emoji-container">\n            <span class="emoji" title="Thumbs Up">ğŸ‘</span> <!-- Thumbs Up -->\n            <span class="emoji" title="Folded Hands">ğŸ™</span> <!-- Folded Hands -->\n            <span class="emoji" title="Flexed Biceps">ğŸ’ª</span> <!-- Flexed Biceps -->\n            <span class="emoji" title="Raising Hands">ğŸ™Œ</span> <!-- Raising Hands -->\n            <span class="emoji" title="Eyes">ğŸ‘€</span> <!-- Eyes -->\n            <span class="emoji" title="Man Shrugging">ğŸ¤·\u200dâ™‚ï¸</span> <!-- Man Shrugging -->\n            <span class="emoji" title="Woman Facepalming">ğŸ¤¦\u200dâ™€ï¸</span> <!-- Woman Facepalming -->\n            <span class="emoji" title="Brain">ğŸ§ </span> <!-- Brain -->\n            <span class="emoji" title="Crown">ğŸ‘‘</span> <!-- Crown -->\n            <span class="emoji" title="Heart Hands">ğŸ«¶</span> <!-- Heart Hands -->\n            <span class="emoji" title="Thumbs Down">ğŸ‘</span> <!-- Thumbs Down -->\n            <span class="emoji" title="Victory Hand">âœŒï¸</span> <!-- Victory Hand -->\n            <span class="emoji" title="Handshake">ğŸ¤</span> <!-- Handshake -->\n            <span class="emoji" title="Clapping Hands">ğŸ‘</span> <!-- Clapping Hands -->\n            <span class="emoji" title="Handshake">ğŸ¤</span> <!-- Handshake -->\n            <span class="emoji" title="Woman Shrugging">ğŸ¤·\u200dâ™€ï¸</span> <!-- Woman Shrugging -->\n            <span class="emoji" title="Man Facepalming">ğŸ¤¦\u200dâ™‚ï¸</span> <!-- Man Facepalming -->\n            <span class="emoji" title="Woman Facepalming">ğŸ¤¦\u200dâ™€ï¸</span> <!-- Woman Facepalming -->\n            <span class="emoji" title="Raising Hands">ğŸ™Œ</span> <!-- Raising Hands -->\n            <span class="emoji" title="Fist Bump">ğŸ¤œğŸ¤›</span> <!-- Fist Bump -->\n            <span class="emoji" title="Technologist">ğŸ§‘\u200dğŸ’»</span> <!-- Technologist -->\n            <span class="emoji" title="Astronaut">ğŸ§‘\u200dğŸš€</span> <!-- Astronaut -->\n            <span class="emoji" title="Artist">ğŸ§‘\u200dğŸ¨</span> <!-- Artist -->\n\n        </div>\n        \n        <h6 class="mt-3 mb-1">Hearts & Symbols</h6>\n        <div class="emoji-container">\n            <span class="emoji" title="Red Heart">â¤ï¸</span> <!-- Red Heart -->\n            <span class="emoji" title="Party Popper">ğŸ‰</span> <!-- Party Popper -->\n            <span class="emoji" title="Sparkles">âœ¨</span> <!-- Sparkles -->\n            <span class="emoji" title="Fire">ğŸ”¥</span> <!-- Fire -->\n            <span class="emoji" title="Hundred Points">ğŸ’¯</span> <!-- Hundred Points -->\n            <span class="emoji" title="Prohibited">ğŸš«</span> <!-- Prohibited/No -->\n            <span class="emoji" title="Cross Mark">âŒ</span> <!-- Cross Mark/No -->\n                        <span class="emoji" title="Star">â­ï¸</span> <!-- Star -->\n            <span class="emoji" title="Sparkle">âœ¨</span> <!-- Sparkle -->\n            <span class="emoji" title="Glowing Star">ğŸŒŸ</span> <!-- Glowing Star -->\n            <span class="emoji" title="Blue Heart">ğŸ’™</span> <!-- Blue Heart -->\n            <span class="emoji" title="Green Heart">ğŸ’š</span> <!-- Green Heart -->\n            <span class="emoji" title="Purple Heart">ğŸ’œ</span> <!-- Purple Heart -->\n            <span class="emoji" title="Black Heart">ğŸ–¤</span> <!-- Black Heart -->\n            <span class="emoji" title="White Heart">ğŸ¤</span> <!-- White Heart -->\n            <span class="emoji" title="Sparkling Heart">ğŸ’–</span> <!-- Sparkling Heart -->\n\n            <span class="emoji" title="Light Bulb">ğŸ’¡</span> <!-- Light Bulb -->\n            <span class="emoji" title="Collision">ğŸ’¥</span> <!-- Collision -->\n            <span class="emoji" title="Sun">â˜€ï¸</span> <!-- Sun -->\n            <span class="emoji" title="Crescent Moon">ğŸŒ™</span> <!-- Crescent Moon -->\n            <span class="emoji" title="Check Mark Button">âœ…</span> <!-- Check Mark Button -->\n            <span class="emoji" title="Cross Mark">âŒ</span> <!-- Cross Mark -->\n            <span class="emoji" title="High Voltage">âš¡ï¸</span> <!-- High Voltage -->\n\n        </div>\n        \n        <h6 class="mt-3 mb-1">Objects & Activities</h6>\n        <div class="emoji-container">\n            <span class="emoji" title="Rocket">ğŸš€</span> <!-- Rocket -->\n            <span class="emoji" title="Black Small Square">â–ªï¸</span> <!-- Black Small Square -->\n            <span class="emoji" title="White Small Square">â–«ï¸</span> <!-- White Small Square -->\n            <span class="emoji" title="Black Circle">âš«ï¸</span> <!-- Black Circle -->\n            <span class="emoji" title="White Circle">âšªï¸</span> <!-- White Circle -->\n            <span class="emoji" title="Red Circle">ğŸ”´</span> <!-- Red Circle -->\n            <span class="emoji" title="Large Blue Circle">ğŸ”µ</span> <!-- Large Blue Circle -->\n            <span class="emoji" title="Small Orange Diamond">ğŸ”¸</span> <!-- Small Orange Diamond -->\n            <span class="emoji" title="Small Blue Diamond">ğŸ”¹</span> <!-- Small Blue Diamond -->\n            <span class="emoji" title="Triangle Pointing Right">â–¶ï¸</span> <!-- Triangle Pointing Right -->\n            <span class="emoji" title="Triangle Pointing Down">ğŸ”½</span> <!-- Triangle Pointing Down -->\n\n            <span class="emoji" title="Diamond Shape With A Dot Inside">ğŸ’ </span> <!-- Diamond Shape With A Dot Inside -->\n\n            <span class="emoji" title="Chart Increasing">ğŸ“ˆ</span> <!-- Chart Increasing -->\n            <span class="emoji" title="Mobile Phone">ğŸ“±</span> <!-- Mobile Phone -->\n            <span class="emoji" title="Laptop">ğŸ’»</span> <!-- Laptop -->\n            <span class="emoji" title="Soccer Ball">âš½</span> <!-- Soccer Ball -->\n            <span class="emoji" title="Basketball">ğŸ€</span> <!-- Basketball -->\n            <span class="emoji" title="Video Game">ğŸ®</span> <!-- Video Game -->\n            <span class="emoji" title="Musical Note">ğŸµ</span> <!-- Musical Note -->\n            <span class="emoji" title="Clapper Board">ğŸ¬</span> <!-- Clapper Board -->\n            <span class="emoji" title="Books">ğŸ“š</span> <!-- Books -->\n            <span class="emoji" title="Direct Hit">ğŸ¯</span> <!-- Direct Hit -->\n            <span class="emoji" title="Memo">ğŸ“</span> <!-- Memo -->\n            <span class="emoji" title="Loudspeaker">ğŸ“¢</span> <!-- Loudspeaker -->\n            <span class="emoji" title="Laptop">ğŸ’»</span> <!-- Laptop -->\n            <span class="emoji" title="Chart Increasing">ğŸ“ˆ</span> <!-- Chart Increasing -->\n            <span class="emoji" title="Video Game">ğŸ®</span> <!-- Video Game -->\n            <span class="emoji" title="Studio Microphone">ğŸ™ï¸</span> <!-- Studio Microphone -->\n\n        </div>\n        \n        <h6 class="mt-3 mb-1">Flags</h6>\n        <div class="emoji-container">\n            <span class="emoji" title="Australia">ğŸ‡¦ğŸ‡º</span> <!-- Australia -->\n            <span class="emoji" title="Bangladesh">ğŸ‡§ğŸ‡©</span> <!-- Bangladesh -->\n            <span class="emoji" title="Brazil">ğŸ‡§ğŸ‡·</span> <!-- Brazil -->\n            <span class="emoji" title="Canada">ğŸ‡¨ğŸ‡¦</span> <!-- Canada -->\n            <span class="emoji" title="China">ğŸ‡¨ğŸ‡³</span> <!-- China -->\n            <span class="emoji" title="Egypt">ğŸ‡ªğŸ‡¬</span> <!-- Egypt -->\n            <span class="emoji" title="Egypt">ğŸ‡ªğŸ‡¬</span> <!-- Flag: Egypt -->\n            <span class="emoji" title="Germany">ğŸ‡©ğŸ‡ª</span> <!-- Flag: Germany -->\n            <span class="emoji" title="Indonesia">ğŸ‡®ğŸ‡©</span> <!-- Flag: Indonesia -->\n            <span class="emoji" title="Israel">ğŸ‡®ğŸ‡±</span> <!-- Flag: Israel -->\n            <span class="emoji" title="Palestine">ğŸ‡µğŸ‡¸</span> <!-- Flag: Palestine -->\n            <span class="emoji" title="Russia">ğŸ‡·ğŸ‡º</span> <!-- Flag: Russia -->\n            <span class="emoji" title="Saudi Arabia">ğŸ‡¸ğŸ‡¦</span> <!-- Flag: Saudi Arabia -->\n            <span class="emoji" title="South Africa">ğŸ‡¿ğŸ‡¦</span> <!-- Flag: South Africa -->\n            <span class="emoji" title="Spain">ğŸ‡ªğŸ‡¸</span> <!-- Flag: Spain -->\n            <span class="emoji" title="United Arab Emirates">ğŸ‡¦ğŸ‡ª</span> <!-- Flag: United Arab Emirates -->\n            <span class="emoji" title="France">ğŸ‡«ğŸ‡·</span> <!-- France -->\n            <span class="emoji" title="Germany">ğŸ‡©ğŸ‡ª</span> <!-- Germany -->\n            <span class="emoji" title="India">ğŸ‡®ğŸ‡³</span> <!-- India -->\n            <span class="emoji" title="Indonesia">ğŸ‡®ğŸ‡©</span> <!-- Indonesia -->\n            <span class="emoji" title="Israel">ğŸ‡®ğŸ‡±</span> <!-- Israel -->\n            <span class="emoji" title="Italy">ğŸ‡®ğŸ‡¹</span> <!-- Italy -->\n            <span class="emoji" title="Japan">ğŸ‡¯ğŸ‡µ</span> <!-- Japan -->\n            <span class="emoji" title="Malaysia">ğŸ‡²ğŸ‡¾</span> <!-- Malaysia -->\n            <span class="emoji" title="Mexico">ğŸ‡²ğŸ‡½</span> <!-- Mexico -->\n            <span class="emoji" title="Nigeria">ğŸ‡³ğŸ‡¬</span> <!-- Nigeria -->\n            <span class="emoji" title="Palestine">ğŸ‡µğŸ‡¸</span> <!-- Palestine -->\n            <span class="emoji" title="Philippines">ğŸ‡µğŸ‡­</span> <!-- Philippines -->\n            <span class="emoji" title="Russia">ğŸ‡·ğŸ‡º</span> <!-- Russia -->\n            <span class="emoji" title="Saudi Arabia">ğŸ‡¸ğŸ‡¦</span> <!-- Saudi Arabia -->\n            <span class="emoji" title="Singapore">ğŸ‡¸ğŸ‡¬</span> <!-- Singapore -->\n            <span class="emoji" title="South Africa">ğŸ‡¿ğŸ‡¦</span> <!-- South Africa -->\n            <span class="emoji" title="South Korea">ğŸ‡°ğŸ‡·</span> <!-- South Korea -->\n            <span class="emoji" title="Turkey">ğŸ‡¹ğŸ‡·</span> <!-- Turkey -->\n            <span class="emoji" title="United Arab Emirates">ğŸ‡¦ğŸ‡ª</span> <!-- United Arab Emirates -->\n            <span class="emoji" title="United Kingdom">ğŸ‡¬ğŸ‡§</span> <!-- United Kingdom -->\n            <span class="emoji" title="United States">ğŸ‡ºğŸ‡¸</span> <!-- United States -->\n            <span class="emoji" title="Vietnam">ğŸ‡»ğŸ‡³</span> <!-- Vietnam -->\n\n        </div>\n    </div>\n</div>\n                        \n                        <div class="tab-pane fade" id="giphy" role="tabpanel">\n                            <div class="mb-3">\n                                <label for="giphySearch" class="form-label">Search for GIFs:</label>\n                                <div class="input-group">\n                                    <input type="text" class="form-control" id="giphySearch" placeholder="Enter a search term...">\n                                    <button class="btn btn-primary" id="searchGiphyBtn">Search</button>\n                                </div>\n                            </div>\n                            <div id="giphyResults" class="mt-3 d-flex flex-wrap gap-2">\n                                <div class="text-center w-100 text-muted">\n                                   \n                                </div>\n                            </div>\n                        </div>\n                        \n                        <div class="tab-pane fade" id="upload" role="tabpanel">\n                            <div class="mb-3">\n                                <label for="imageUpload" class="form-label">Upload an image:</label>\n                                <input class="form-control" type="file" id="imageUpload" accept="image/*">\n                                <div class="form-text">For best results, use an image larger than 500x300px.</div>\n                            </div>\n                            <div id="uploadPreview" class="d-none mt-3">\n                                <p>Image preview:</p>\n                                <img id="uploadedImage" class="img-thumbnail" style="max-height: 100px;">\n                                <button class="btn btn-sm btn-danger mt-2" id="removeImage">Remove Image</button>\n                            </div>\n\n                            <div class="mt-3 mb-3" id="backgroundControls" style="display: none;">\n                                <label class="form-label">Scaling:</label>\n                                <div class="btn-group" role="group">\n                                    <input type="radio" class="btn-check" name="bgScale" id="bgContain" autocomplete="off" checked>\n                                    <label class="btn btn-outline-primary" for="bgContain">Contain</label>\n                                    \n                                    <input type="radio" class="btn-check" name="bgScale" id="bgCover" autocomplete="off">\n                                    <label class="btn btn-outline-primary" for="bgCover">Cover</label>\n                                    \n                                    <input type="radio" class="btn-check" name="bgScale" id="bgActual" autocomplete="off">\n                                    <label class="btn btn-outline-primary" for="bgActual">Actual Size</label>\n                                </div>\n                                \n                                <div class="mt-2">\n                                    <label for="bgOpacity" class="form-label">Darkness: <span id="bgOpacityValue">20</span>%</label>\n                                    <input type="range" class="form-range" id="bgOpacity" min="0" max="80" step="5" value="20">\n                                    \n                                </div>\n                            </div>\n\n                        </div>\n                        \n                        <div class="tab-pane fade" id="featured" role="tabpanel">\n                            <div class="mb-3">\n                                <label for="featuredSearch" class="form-label">Search for featured images:</label>\n                                <div class="input-group">\n                                    <input type="text" class="form-control" id="featuredSearch" placeholder="Search by a keyword">\n                                    <button class="btn btn-primary" id="searchFeaturedBtn">Search</button>\n                                </div>\n                            </div>\n                            <div id="featuredResults" class="mt-3 d-flex flex-wrap">\n                                <div class="text-center w-100 text-muted">\n                                    <div class="spinner-border text-primary" role="status">\n                                        <span class="visually-hidden">Loading...</span>\n                                    </div>\n                                    <p class="mt-2">Loading featured images...</p>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n                \n          \n\n            </div>\n            \n            <div class="col-md-6">\n                <div class="card-preview" id="cardPreview">\n                    <div class="card-text" id="previewText">What\'s on your mind?</div>\n                    <div class="powered-by" id="poweredByText">Powered by MyPoint.Cards</div>\n                </div>\n                <div class="mt-3 preview-container">\n\n    \n                    <div class="button-container justify-content-between gap-2">\n                        <button class="btn btn-primary flex-grow-1" id="downloadBtn">\n                            <i class="fas fa-download"></i> Download\n                        </button>\n                        <button class="btn btn-info text-white flex-grow-1" id="twitterBtn">\n                            Share on X\n                        </button>\n                        <button class="btn btn-secondary flex-grow-1" id="resetBtn">\n                            <i class="fas fa-undo"></i> Reset\n                        </button>\n                        <button class="btn btn-secondary flex-grow-1" id="helpBtn">\n                            <i class="fas fa-circle-info"></i> Help\n                        </button>\n                    </div>\n\n                </div>\n\n\n            </div>\n        </div>\n        \n        <div class="text-center footer-container text-muted mt-5">\n            <p class="m-0"><a href="https://mypoint.cards">MyPoint.Cards</a><br><span style="font-style: italic;">make your point stand out in any feed</span></p>\n        </div>\n    </div>\n    \n    <!-- Bootstrap JS -->\n    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>\n    <!-- html2canvas for image capture -->\n    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>\n    \n    <script>\n        // DOM Elements\n        const isMobile = window.matchMedia("(max-width: 768px)").matches;\n        const cardPreview = document.getElementById(\'cardPreview\');\n        const previewText = document.getElementById(\'previewText\');\n        const cardText = document.getElementById(\'cardText\');\n        const colorBoxes = document.querySelectorAll(\'.color-box\');\n        const customColor = document.getElementById(\'customColor\');\n        const imageUpload = document.getElementById(\'imageUpload\');\n        const uploadPreview = document.getElementById(\'uploadPreview\');\n        const uploadedImage = document.getElementById(\'uploadedImage\');\n        const removeImage = document.getElementById(\'removeImage\');\n        const downloadBtn = document.getElementById(\'downloadBtn\');\n        const twitterBtn = document.getElementById(\'twitterBtn\');\n        const resetBtn = document.getElementById(\'resetBtn\');\n        const helpBtn = document.getElementById(\'helpBtn\');\n        const emojis = document.querySelectorAll(\'.emoji\');\n        const giphySearch = document.getElementById(\'giphySearch\');\n        const searchGiphyBtn = document.getElementById(\'searchGiphyBtn\');\n        const giphyResults = document.getElementById(\'giphyResults\');\n        const featuredTab = document.getElementById(\'featured-tab\');\n        const featuredSearch = document.getElementById(\'featuredSearch\');\n        const searchFeaturedBtn = document.getElementById(\'searchFeaturedBtn\');\n        const featuredResults = document.getElementById(\'featuredResults\');\n        \n        const gradientBoxes = document.querySelectorAll(\'.gradient-box\');\n        const gradientColor1 = document.getElementById(\'gradientColor1\');\n        const gradientColor2 = document.getElementById(\'gradientColor2\');\n        const gradientDirection = document.getElementById(\'gradientDirection\');\n        const applyCustomGradient = document.getElementById(\'applyCustomGradient\');\n\n\n        // Giphy API Key (limited for demo purposes)\n        const GIPHY_API_KEY = \'GlVGYHkr3WSBnllca54iNt0yFbjz7L65\';\n\n        // Featured images API endpoint\n        const FEATURED_API_ENDPOINT = \'https://featured.mypoint.cards\';\n        \n        // Local fallback data for featured images since the external API has CORS restrictions\n        const FALLBACK_FEATURED_DATA = {\n            featured: {\n                "1": {"image-url": "https://featured.mypoint.cards/assets/default.webp", "category": "technology, startup", "tags": "ai, image generation, llm"}\n            }\n        };\n        \n        // Variables\n        let hasBackgroundImage = false;\n        let backgroundImageSource = null; // \'upload\', \'giphy\', \'featured\', or null\n        let featuredImages = null;\n\n        let corsBlocked = true; // Assume CORS is blocked to avoid repeated attempts\n\n        let giphyCurrentPage = 0;\n        const giphyResultsPerPage = 9;\n        const giphyMaxPages = 10;\n        let giphyTotalResults = [];\n        let giphyCurrentQuery = \'\';\n\n        const fontFamily = document.getElementById(\'fontFamily\');\n        const fontSize = document.getElementById(\'fontSize\');\n        const fontSizeValue = document.getElementById(\'fontSizeValue\');\n        const fontColor = document.getElementById(\'fontColor\');\n        const fontColorHex = document.getElementById(\'fontColorHex\');\n        const textShadow = document.getElementById(\'textShadow\');\n        const poweredBy = document.getElementById(\'poweredBy\');\n        const poweredByText = document.getElementById(\'poweredByText\');\n\n        const backgroundControls = document.getElementById(\'backgroundControls\');\n        const bgContain = document.getElementById(\'bgContain\');\n        const bgCover = document.getElementById(\'bgCover\');\n        const bgActual = document.getElementById(\'bgActual\');\n        const bgOpacity = document.getElementById(\'bgOpacity\');\n        const bgOpacityValue = document.getElementById(\'bgOpacityValue\');\n\n\n        // Variables for image positioning\n        let isDragging = false;\n        let dragStartX = 0;\n        let dragStartY = 0;\n        let initialBgPosX = 50; // Default position (center)\n        let initialBgPosY = 50; // Default position (center)\n        let currentBgPosX = 50;\n        let currentBgPosY = 50;\n\n        const alignLeft = document.getElementById(\'alignLeft\');\n        const alignCenter = document.getElementById(\'alignCenter\');\n        const alignRight = document.getElementById(\'alignRight\');\n\n        // Add these variables at the top with other DOM elements\n        const themeSwitch = document.getElementById(\'themeSwitch\');\n        const htmlElement = document.documentElement;\n\n        let featuredCurrentPage = 0;\n        const featuredResultsPerPage = 9; // 3x3 grid, similar to Giphy\n\n        let featuredMaxPages = 5\n        let featuredTotalResults = [];\n        let featuredCurrentQuery = \'\';\n\n        let appStartTime = null;\n        let totalTimeSpent = 0;\n        let userActivityTimeout = null;\n        let isUserActive = true;\n        let cardDownloadCount = 0;\n        const INACTIVITY_TIMEOUT = 10000; // 10 sec of inactivity before pausing the timer\n        const ENABLE_USAGE_TRACKING = \'yes\'; // Set to \'yes\' to enable or \'no\' to disable local usage tracking\n\n        const lineHeight = document.getElementById(\'lineHeight\');\n        const lineHeightValue = document.getElementById(\'lineHeightValue\');\n\n        let textIsDragging = false;\n        let textDragStartX = 0;\n        let textDragStartY = 0;\n        let textPosX = 50; // Default to center\n        let textPosY = 50; // Default to center\n\n        let shareImageBlob = null;\n        let shareImageFormat = null;\n        let shareImageDataURL = null;\n\n        function setupClipboardPaste() {\n          // Listen for paste events on the document level to capture pastes anywhere\n          document.addEventListener(\'paste\', function(e) {\n            // Check if the event has clipboard data with images\n            if (e.clipboardData && e.clipboardData.items) {\n              // Loop through clipboard items\n              for (let i = 0; i < e.clipboardData.items.length; i++) {\n                const item = e.clipboardData.items[i];\n                \n                // Check if item is an image\n                if (item.type.indexOf(\'image\') !== -1) {\n                  // Get the image as a file\n                  const file = item.getAsFile();\n                  \n                  // Process the file as if it was uploaded\n                  processClipboardImage(file);\n                  \n                  // Prevent the default paste behavior\n                  e.preventDefault();\n                  return;\n                }\n              }\n            }\n          });\n        }\n\n        function processClipboardImage(file) {\n          if (file) {\n            // Show a loading indicator\n            const loadingOverlay = document.createElement(\'div\');\n            loadingOverlay.id = \'clipboardLoadingOverlay\';\n            loadingOverlay.style.position = \'absolute\';\n            loadingOverlay.style.top = \'0\';\n            loadingOverlay.style.left = \'0\';\n            loadingOverlay.style.width = \'100%\';\n            loadingOverlay.style.height = \'100%\';\n            loadingOverlay.style.background = \'rgba(0,0,0,0.5)\';\n            loadingOverlay.style.display = \'flex\';\n            loadingOverlay.style.justifyContent = \'center\';\n            loadingOverlay.style.alignItems = \'center\';\n            loadingOverlay.style.zIndex = \'10\';\n            loadingOverlay.style.borderRadius = \'12px\';\n            loadingOverlay.innerHTML = \'<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading image...</span></div>\';\n            \n            cardPreview.style.position = \'relative\';\n            cardPreview.appendChild(loadingOverlay);\n            \n            // Create a data URL from the file\n            const reader = new FileReader();\n            \n            reader.onload = function(event) {\n              // Show the thumbnail preview (simulate an upload)\n              uploadedImage.src = event.target.result;\n              uploadPreview.classList.remove(\'d-none\');\n              \n              // Set as background image\n              cardPreview.style.backgroundImage = `url(${event.target.result})`;\n              cardPreview.style.backgroundSize = \'contain\';\n              cardPreview.style.backgroundPosition = \'center\';\n              cardPreview.style.backgroundRepeat = \'no-repeat\';\n              \n              // Update the state variables\n              hasBackgroundImage = true;\n              backgroundImageSource = \'upload\';\n              \n              // Reset position to center\n              cardPreview.style.backgroundPosition = \'50% 50%\';\n              initialBgPosX = 50;\n              initialBgPosY = 50;\n              currentBgPosX = 50;\n              currentBgPosY = 50;\n              \n              // Apply the darkness overlay\n              applyBackgroundDarkness();\n              \n              // Update cursor style\n              updateCursorStyle();\n              \n              // Show background controls\n              showBackgroundControls();\n              \n              // Select appropriate scaling option\n              const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n              const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n              const isIOSSafari = isIOS && isSafari;\n              \n              if (isIOSSafari) {\n                // For iOS Safari, \'contain\' mode tends to work better\n                bgContain.checked = true;\n              }\n              \n              // Remove the loading overlay\n              if (document.getElementById(\'clipboardLoadingOverlay\')) {\n                cardPreview.removeChild(loadingOverlay);\n              }\n              \n              // Show a success message\n              showAlert(\'Pasted image applied as background!\', \'success\');\n            };\n            \n            reader.onerror = function() {\n              // Remove loading overlay\n              if (document.getElementById(\'clipboardLoadingOverlay\')) {\n                cardPreview.removeChild(loadingOverlay);\n              }\n              \n              // Show error message\n              showAlert(\'Failed to process clipboard image. Please try again.\', \'warning\');\n            };\n            \n            // Start reading the file\n            reader.readAsDataURL(file);\n          }\n        }\n\n        function preloadFonts() {\n          return new Promise((resolve) => {\n            // Get the currently selected font\n            const currentFont = fontFamily.value;\n            \n            // If no font is selected, resolve immediately\n            if (!currentFont) {\n              resolve();\n              return;\n            }\n            \n            // Create a temporary span to trigger font loading\n            const tempSpan = document.createElement(\'span\');\n            tempSpan.style.fontFamily = currentFont;\n            tempSpan.style.fontSize = \'0px\';\n            tempSpan.innerHTML = \'Font Preloader\';\n            \n            // Append to body temporarily\n            document.body.appendChild(tempSpan);\n            \n            // Check if the document fonts are loaded\n            if (document.fonts && document.fonts.ready) {\n              // Modern browsers support the font loading API\n              document.fonts.ready.then(() => {\n                // Cleanup\n                document.body.removeChild(tempSpan);\n                resolve();\n              }).catch(() => {\n                // On error, still resolve but after cleanup\n                document.body.removeChild(tempSpan);\n                resolve();\n              });\n            } else {\n              // Fallback for browsers without font loading API\n              // Give it a timeout to allow font to load\n              setTimeout(() => {\n                document.body.removeChild(tempSpan);\n                resolve();\n              }, 500);\n            }\n          });\n        }\n\n        function cleanupExistingToggles() {\n          // Find existing toggles and containers\n          const existingToggle = document.querySelector(\'.text-options-toggle\');\n          const existingContainer = document.querySelector(\'.text-options-container\');\n          \n          // If toggle exists, remove it\n          if (existingToggle && existingToggle.parentNode) {\n            existingToggle.parentNode.removeChild(existingToggle);\n          }\n          \n          // If container exists, move its children back to the text tab and remove it\n          if (existingContainer && existingContainer.parentNode) {\n            const textTab = document.getElementById(\'text\');\n            if (textTab) {\n              // Move all children back to the text tab\n              while (existingContainer.firstChild) {\n                textTab.appendChild(existingContainer.firstChild);\n              }\n              // Remove the empty container\n              existingContainer.parentNode.removeChild(existingContainer);\n            }\n          }\n        }\n\n        // Function to set up the text options toggle for mobile\n        function setupTextOptionsToggle() {\n        if (window.innerWidth > 768) return;\n\n        const textTab = document.getElementById(\'text\');\n        if (!textTab) return;\n\n        const cardTextContainer = textTab.querySelector(\'#cardText\')?.closest(\'.mb-3\');\n        if (!cardTextContainer) return;\n\n        // Check if already exists to avoid duplicate\n        if (textTab.querySelector(\'.text-options-container\')) return;\n\n        const optionsContainer = document.createElement(\'div\');\n        optionsContainer.className = \'text-options-container\';\n\n        // Select specific elements to move\n        const selectors = [\n        \'#fontFamily\',\n        \'#fontSize\',\n        \'#fontColor\',\n        \'#lineHeight\',\n        \'#textShadow\',\n        \'#poweredBy\',\n        \'#alignLeft\',\n        \'#alignCenter\',\n        \'#alignRight\',\n        \'input[name="imageFormat"]\'\n        ];\n\n        const elementsToMove = new Set();\n\n        selectors.forEach(selector => {\n        const el = textTab.querySelector(selector);\n        if (el) {\n          const parent = el.closest(\'.mb-3\') || el.closest(\'.d-flex\') || el;\n          elementsToMove.add(parent);\n        }\n        });\n\n        elementsToMove.forEach(el => optionsContainer.appendChild(el));\n\n        const toggleBtn = document.createElement(\'div\');\n        toggleBtn.className = \'text-options-toggle\';\n        toggleBtn.innerHTML = \'<i class="fas fa-cog"></i> Text Options\';\n\n        cardTextContainer.after(toggleBtn);\n        toggleBtn.after(optionsContainer);\n\n        toggleBtn.addEventListener(\'click\', function() {\n        optionsContainer.classList.toggle(\'visible\');\n        toggleBtn.innerHTML = optionsContainer.classList.contains(\'visible\')\n          ? \'<i class="fas fa-chevron-up"></i> Hide Options\'\n          : \'<i class="fas fa-cog"></i> Text Options\';\n        });\n        }\n\n\n        function initializeApp() {\n\n          addDraggingStyleIfNeeded();\n          initUsageCounter();\n          startTimeTracking();\n          \n          // Add CSS for the usage stats if not already added\n          if (!document.getElementById(\'usageStatsStyle\')) {\n            const style = document.createElement(\'style\');\n            style.id = \'usageStatsStyle\';\n            style.textContent = `\n              #usageStats {\n                color: #6c757d;\n                font-size: 0.8em;\n                margin-top: 0.25rem;\n              }\n              \n              [data-bs-theme="dark"] #usageStats {\n                color: #adb5bd;\n              }\n              \n              /* iOS optimizations */\n              .ios-loading {\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                position: fixed;\n                top: 0;\n                left: 0;\n                right: 0;\n                bottom: 0;\n                background-color: rgba(0,0,0,0.7);\n                z-index: 9999;\n                color: white;\n                flex-direction: column;\n                gap: 15px;\n              }\n              \n              .ios-loading .spinner {\n                width: 50px;\n                height: 50px;\n                border: 5px solid rgba(255,255,255,0.3);\n                border-radius: 50%;\n                border-top-color: white;\n                animation: ios-spin 1s infinite linear;\n              }\n              \n              @keyframes ios-spin {\n                0% { transform: rotate(0deg); }\n                100% { transform: rotate(360deg); }\n              }\n            `;\n            document.head.appendChild(style);\n          }\n          \n          // Only set up the interval if tracking is enabled\n          if (ENABLE_USAGE_TRACKING === \'yes\') {\n            setInterval(function() {\n              if (appStartTime) {\n                const sessionTime = Math.floor((new Date() - appStartTime) / 1000);\n                const displayTime = totalTimeSpent + sessionTime;\n                const count = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n                const downloads = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n                updateUsageStats(parseInt(count), displayTime, downloads);\n              }\n            }, 1000);\n          }\n          \n          makeTextDraggable();\n          setupTextDragging();\n          setupInlineTextEditing();\n          addFormatSelection();\n          initializeSharing();\n          \n          // Initialize featured images\n          initFeaturedImages();\n          \n          // Load saved preferences\n          loadSavedPreferences();\n          \n          // Check for and apply system theme preference\n          initTheme();\n          \n          // Add a listener for the featured tab to ensure handlers are set up\n          featuredTab.addEventListener(\'click\', function() {\n            // If we already have featured images, just display them\n            if (featuredImages) {\n              displayFeaturedImages(featuredImages);\n              // After displaying, set up the handlers\n              setTimeout(setupFeaturedImageHandlers, 100);\n            } else {\n              // Otherwise, try to load them\n              loadFeaturedImages();\n              // Set up handlers after a delay to ensure images are rendered\n              setTimeout(setupFeaturedImageHandlers, 500);\n            }\n          });\n          \n          // Override the Giphy search to ensure our enhanced handlers are used\n          const originalSearchGiphyBtn = searchGiphyBtn.onclick;\n          searchGiphyBtn.onclick = function() {\n            searchGiphy(0);\n            // Set up handlers after images load\n            setTimeout(setupGiphyImageHandlers, 500);\n          };\n          \n          // Enhanced keyboard handling for Giphy search\n          giphySearch.addEventListener(\'keypress\', function(e) {\n            if (e.key === \'Enter\') {\n              searchGiphy(0);\n              // Set up handlers after images load\n              setTimeout(setupGiphyImageHandlers, 500);\n            }\n          });\n          \n          // Detect when iOS Safari is about to navigate away\n          window.addEventListener(\'pagehide\', function() {\n            // Save any unsaved state\n            savePreferences();\n            stopTimeTracking();\n          });\n          \n          // Fix for iOS Safari orientation change\n          window.addEventListener(\'orientationchange\', function() {\n            // Short delay to allow the browser to adjust\n            setTimeout(function() {\n              // Refresh image positioning\n              if (hasBackgroundImage) {\n                cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;\n              }\n            }, 300);\n          });\n          \n          // Update button labels for the device\n          updateButtonLabels();\n          \n          // If on iOS, check for iOS 17.4+ which has better support\n          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n\n\n\n\n          if (isIOS) {\n            // Attempt to detect iOS version\n            const match = navigator.userAgent.match(/OS (\\d+)_(\\d+)_?(\\d+)?/);\n            if (match) {\n              const version = [\n                parseInt(match[1], 10),\n                parseInt(match[2], 10),\n                parseInt(match[3] || 0, 10)\n              ];\n              \n              // iOS 17.4+ has better canvas support\n              const hasImprovedCanvasSupport = (version[0] > 17 || (version[0] === 17 && version[1] >= 4));\n              \n              if (!hasImprovedCanvasSupport) {\n                // Add warning for older iOS versions\n                // const warningEl = document.createElement(\'div\');\n                // warningEl.className = \'alert alert-warning text-center\';\n                // warningEl.innerHTML = \'Texting cards require saving to Photos first.\';\n                \n                // // Insert after the toolbar\n                // const toolbar = document.querySelector(\'.toolbar\');\n                // if (toolbar && toolbar.parentNode) {\n                //   toolbar.parentNode.insertBefore(warningEl, toolbar.nextSibling);\n                  \n                //   // Auto-dismiss after 10 seconds\n                //   setTimeout(() => {\n                //     if (warningEl.parentNode) {\n                //       warningEl.parentNode.removeChild(warningEl);\n                //     }\n                //   }, 10000);\n                // }\n              }\n            }\n          }\n        }\n\n\n        // Create a special version of html2canvas for iOS\n        async function createIOSFriendlyCanvas(element, options = {}) {\n          // Check if this is iOS Safari\n          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n          const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n          const isIOSSafari = isIOS && isSafari;\n          \n          if (!isIOSSafari) {\n            // Use regular html2canvas for non-iOS Safari\n            return html2canvas(element, options);\n          }\n          \n          // Show loading indicator\n          const hideLoading = showIOSLoadingOverlay(\'Creating image...\');\n          \n          try {\n            // Create a canvas with WebKit-specific optimizations\n            const canvas = document.createElement(\'canvas\');\n            const rect = element.getBoundingClientRect();\n            \n            // Set canvas dimensions\n            canvas.width = rect.width * 1.5;\n            canvas.height = rect.height * 1.5;\n            \n            // Create context with optimization flags to help WebKit\n            const ctx = canvas.getContext(\'2d\', {\n              alpha: true,\n              willReadFrequently: true,\n              desynchronized: false\n            });\n            \n            // Make the canvas visible in the DOM temporarily\n            // This forces WebKit to use hardware acceleration\n            canvas.style.position = \'fixed\';\n            canvas.style.top = \'0\';\n            canvas.style.left = \'0\';\n            canvas.style.zIndex = \'-1\';\n            canvas.style.opacity = \'0.01\'; // Nearly invisible but still rendered\n            document.body.appendChild(canvas);\n            \n            // Force a reflow to ensure the canvas is fully initialized\n            canvas.getBoundingClientRect();\n            \n            // Get background information\n            const computedStyle = getComputedStyle(element);\n            const backgroundColor = computedStyle.backgroundColor;\n            const backgroundImage = computedStyle.backgroundImage;\n            \n            // Draw a solid color first - use a bright visible color to ensure rendering\n            ctx.fillStyle = \'#FFFFFF\'; // White background first\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            \n            // Then draw the actual background color\n            ctx.fillStyle = backgroundColor || \'#ED213A\'; // App\'s default red if not set\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            \n            // For gradients or solid colors from UI selections\n            if (!hasBackgroundImage) {\n              const activeGradientBox = document.querySelector(\'.gradient-box.active\');\n              const activeColorBox = document.querySelector(\'.color-box.active\');\n              \n              if (activeGradientBox) {\n                // Handle gradient backgrounds\n                const gradientValue = activeGradientBox.getAttribute(\'data-gradient\');\n                if (gradientValue && gradientValue.includes(\'linear-gradient\')) {\n                  const gradientMatch = gradientValue.match(/linear-gradient\\(([^)]+)\\)/);\n                  if (gradientMatch && gradientMatch[1]) {\n                    const parts = gradientMatch[1].split(\',\').map(part => part.trim());\n                    const direction = parts[0];\n                    const colorStops = parts.slice(1);\n                    \n                    // Create gradient based on direction\n                    let gradient;\n                    if (direction.includes(\'to right\')) {\n                      gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\n                    } else if (direction.includes(\'to left\')) {\n                      gradient = ctx.createLinearGradient(canvas.width, 0, 0, 0);\n                    } else if (direction.includes(\'to bottom\')) {\n                      gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n                    } else if (direction.includes(\'to top\')) {\n                      gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);\n                    } else if (direction.includes(\'45deg\')) {\n                      gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);\n                    } else if (direction.includes(\'135deg\')) {\n                      gradient = ctx.createLinearGradient(0, canvas.height, canvas.width, 0);\n                    } else if (direction.includes(\'225deg\')) {\n                      gradient = ctx.createLinearGradient(canvas.width, canvas.height, 0, 0);\n                    } else if (direction.includes(\'315deg\')) {\n                      gradient = ctx.createLinearGradient(canvas.width, 0, 0, canvas.height);\n                    } else {\n                      gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\n                    }\n                    \n                    // Add color stops\n                    if (colorStops.length >= 2) {\n                      colorStops.forEach((color, index) => {\n                        gradient.addColorStop(index / (colorStops.length - 1), color);\n                      });\n                      \n                      // Draw the gradient with a small delay to ensure rendering\n                      ctx.fillStyle = gradient;\n                      ctx.fillRect(0, 0, canvas.width, canvas.height);\n                    }\n                  }\n                }\n              } else if (activeColorBox) {\n                // Handle solid color backgrounds\n                const colorValue = activeColorBox.getAttribute(\'data-color\');\n                if (colorValue) {\n                  ctx.fillStyle = colorValue;\n                  ctx.fillRect(0, 0, canvas.width, canvas.height);\n                }\n              } else if (customColor && customColor.value) {\n                // Handle custom color\n                ctx.fillStyle = customColor.value;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n              }\n              \n              // Add a subtle pattern to force proper rendering\n              // This tricks WebKit into preserving the background\n              ctx.fillStyle = \'rgba(255,255,255,0.01)\';\n              for (let i = 0; i < canvas.width; i += 20) {\n                for (let j = 0; j < canvas.height; j += 20) {\n                  ctx.fillRect(i, j, 1, 1);\n                }\n              }\n              \n              // Force a composite operation to ensure proper rendering\n              ctx.globalCompositeOperation = \'source-over\';\n            } else {\n              // Handle background image\n              const img = new Image();\n              img.crossOrigin = \'anonymous\';\n              \n              // Get the background image URL\n              let bgImage = computedStyle.backgroundImage;\n              let imageUrl = \'\';\n              \n              if (bgImage.includes(\'url(\')) {\n                imageUrl = bgImage.match(/url\\([\'"]?(.*?)[\'"]?\\)/)[1];\n              }\n              \n              if (imageUrl) {\n                // Use a timeout to prevent hanging\n                const imageLoadPromise = new Promise((resolve) => {\n                  img.onload = () => resolve(true);\n                  img.onerror = () => resolve(false);\n                  \n                  // Set a timeout in case the image loading hangs\n                  setTimeout(() => resolve(false), 3000);\n                  \n                  // Start loading the image\n                  img.src = imageUrl;\n                });\n                \n                // Wait for image to load or timeout\n                const imageLoaded = await imageLoadPromise;\n                \n                if (imageLoaded) {\n                  // Draw the image according to the background-size property\n                  if (computedStyle.backgroundSize === \'cover\') {\n                    drawImageCover(ctx, img, 0, 0, canvas.width, canvas.height);\n                  } else if (computedStyle.backgroundSize === \'contain\') {\n                    drawImageContain(ctx, img, 0, 0, canvas.width, canvas.height);\n                  } else {\n                    // Default - just draw the image\n                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n                  }\n                  \n                  // Apply darkness overlay\n                  const opacity = parseInt(bgOpacity.value) / 100;\n                  if (opacity > 0) {\n                    ctx.fillStyle = `rgba(0,0,0,${opacity})`;\n                    ctx.fillRect(0, 0, canvas.width, canvas.height);\n                  }\n                }\n              }\n            }\n            \n            // Draw the text\n            const textElement = element.querySelector(\'.card-text\');\n            if (textElement) {\n              const text = textElement.innerText;\n              const textStyle = getComputedStyle(textElement);\n              const fontSize = parseInt(textStyle.fontSize) * 1.5;\n              const fontFamily = textStyle.fontFamily;\n              const textColor = textStyle.color;\n              const textAlign = textStyle.textAlign;\n              \n              // Important: Get the actual position from the element\'s styles\n              // This is what preserves custom text positioning\n              const elementRect = textElement.getBoundingClientRect();\n              const containerRect = element.getBoundingClientRect();\n              \n              // If using absolute positioning (left/top), preserve the position\n              // (Note: this assumes text is positioned with "transform: translate(-50%, -50%)")\n              let textPosX = 50; // Default center\n              let textPosY = 50; // Default center\n              \n              // If custom position was set via left/top CSS properties\n              if (textElement.style.left) {\n                textPosX = parseFloat(textElement.style.left);\n              }\n              if (textElement.style.top) {\n                textPosY = parseFloat(textElement.style.top);\n              }\n              \n              // Convert percentage position to canvas pixels\n              const xPos = (textPosX / 100) * canvas.width;\n              const yPos = (textPosY / 100) * canvas.height;\n              \n              let fontFamilyWithFallbacks = fontFamily;\n              \n              if (!fontFamilyWithFallbacks.includes(\',\')) {\n                  // If there\'s no fallback specified, add some standard ones\n                  fontFamilyWithFallbacks = `${fontFamily}, -apple-system, BlinkMacSystemFont, \'Segoe UI\', Roboto, Oxygen, Ubuntu, Cantarell, \'Open Sans\', \'Helvetica Neue\', sans-serif`;\n              }\n              \n              ctx.font = `${fontSize}px ${fontFamilyWithFallbacks}`;\n\n              if (isIOSSafari) {\n                  // Try to extract weight from fontFamily if it contains a weight specification\n                  let fontWeight = \'normal\';\n                  if (textStyle.fontWeight) {\n                    fontWeight = textStyle.fontWeight;\n                  }\n                  \n                  // Apply the font twice - this trick helps Safari render the font correctly\n                  ctx.font = `${fontWeight} ${fontSize}px ${fontFamilyWithFallbacks}`;\n                  \n                  // Force text rendering to better quality\n                  ctx.textRendering = \'optimizeLegibility\';\n                  ctx.imageSmoothingEnabled = true;\n                  ctx.imageSmoothingQuality = \'high\';\n               }\n\n              ctx.fillStyle = textColor;\n              ctx.textAlign = textAlign || \'center\';\n              \n              // Draw text at the proper position\n              if (textAlign === \'left\') {\n                // For left-aligned text, offset from the position\n                const xOffset = -((elementRect.width / 2) - 20);\n                drawWrappedText(ctx, text, xPos + xOffset, yPos, canvas.width - 40, fontSize * 1.2);\n              } else if (textAlign === \'right\') {\n                // For right-aligned text, offset from the position\n                const xOffset = (elementRect.width / 2) - 20;\n                drawWrappedText(ctx, text, xPos + xOffset, yPos, canvas.width - 40, fontSize * 1.2);\n              } else {\n                // For center-aligned text, use the position directly\n                drawWrappedText(ctx, text, xPos, yPos, canvas.width - 40, fontSize * 1.2);\n              }\n              \n              // Apply text shadow if enabled\n              if (textElement.style.textShadow && textElement.style.textShadow !== \'none\') {\n                ctx.shadowColor = \'rgba(0, 0, 0, 0.5)\';\n                ctx.shadowBlur = 4;\n                ctx.shadowOffsetX = 0;\n                ctx.shadowOffsetY = 2;\n              }\n            }\n            \n            // Draw "Powered by" text if enabled\n            const poweredByElement = element.querySelector(\'.powered-by\');\n            if (poweredByElement && poweredBy.checked) {\n              ctx.font = \'10px Arial\';\n              ctx.fillStyle = \'rgba(255, 255, 255, 0.7)\';\n              ctx.textAlign = \'right\';\n              ctx.fillText(\'Powered by MyPoint.Cards\', canvas.width - 10, canvas.height - 10);\n            }\n            \n            // Force another composite operation to ensure rendering\n            ctx.globalCompositeOperation = \'destination-over\';\n            ctx.globalCompositeOperation = \'source-over\';\n            \n            // Allow a moment for WebKit to process the rendering\n            await new Promise(resolve => setTimeout(resolve, 50));\n            \n            // Create a temporary image element to finalize the canvas\n            // This extra step helps ensure the canvas content is fully rendered\n            const tempImage = new Image();\n            tempImage.width = canvas.width;\n            tempImage.height = canvas.height;\n            \n            // Convert canvas to an image and back to canvas\n            // This forces WebKit to finalize all rendering operations\n            tempImage.src = canvas.toDataURL(\'image/png\');\n            \n            // Wait for the image to load\n            await new Promise(resolve => {\n              tempImage.onload = resolve;\n              tempImage.onerror = resolve; // Continue even if there\'s an error\n            });\n            \n            // Create a final canvas\n            const finalCanvas = document.createElement(\'canvas\');\n            finalCanvas.width = canvas.width;\n            finalCanvas.height = canvas.height;\n            \n            const finalCtx = finalCanvas.getContext(\'2d\');\n            finalCtx.drawImage(tempImage, 0, 0);\n            \n            // Ensure the whole compositing pipeline has flushed with a double requestAnimationFrame\n            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));\n            \n            // Remove the original canvas from DOM\n            document.body.removeChild(canvas);\n            \n            return finalCanvas;\n          } catch (error) {\n            console.error(\'iOS friendly canvas creation failed:\', error);\n            \n            // Fallback to simplified html2canvas with minimal options\n            try {\n              return await html2canvas(element, {\n                scale: 1, // Lower scale\n                useCORS: true,\n                allowTaint: true,\n                logging: false,\n                backgroundColor: null,\n                removeContainer: true,\n                imageTimeout: 0 // No timeout\n              });\n            } catch (fallbackError) {\n              console.error(\'Fallback canvas creation failed:\', fallbackError);\n              throw fallbackError;\n            }\n          } finally {\n            // Hide loading overlay\n            if (hideLoading) hideLoading();\n          }\n        }\n\n        // Helper function to draw text with wrapping\n        function XXX_drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {\n          const words = text.split(\' \');\n          let line = \'\';\n          let lines = [];\n          \n          // Split text into lines\n          for (let n = 0; n < words.length; n++) {\n            const testLine = line + words[n] + \' \';\n            const metrics = ctx.measureText(testLine);\n            const testWidth = metrics.width;\n            \n            if (testWidth > maxWidth && n > 0) {\n              lines.push(line);\n              line = words[n] + \' \';\n            } else {\n              line = testLine;\n            }\n          }\n          lines.push(line);\n          \n          // Calculate starting Y position to center text vertically\n          const totalHeight = lines.length * lineHeight;\n          let textY = y - (totalHeight / 2) + (lineHeight / 2);\n          \n          // Draw each line\n          for (let i = 0; i < lines.length; i++) {\n            ctx.fillText(lines[i], x, textY);\n            textY += lineHeight;\n          }\n        }\n\n        function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {\n          const words = text.split(\' \');\n          let line = \'\';\n          let lines = [];\n          \n          // Split text into lines\n          for (let n = 0; n < words.length; n++) {\n            const testLine = line + words[n] + \' \';\n            const metrics = ctx.measureText(testLine);\n            const testWidth = metrics.width;\n            \n            if (testWidth > maxWidth && n > 0) {\n              lines.push(line);\n              line = words[n] + \' \';\n            } else {\n              line = testLine;\n            }\n          }\n          lines.push(line);\n          \n          // Calculate starting Y position to center text vertically around the specified y\n          const totalHeight = lines.length * lineHeight;\n          let textY = y - (totalHeight / 2) + (lineHeight / 2);\n          \n          // Draw each line\n          for (let i = 0; i < lines.length; i++) {\n            ctx.fillText(lines[i], x, textY);\n            textY += lineHeight;\n          }\n        }\n\n        // Helper functions for drawing images with cover/contain\n        function drawImageCover(ctx, img, x, y, width, height) {\n          const imgRatio = img.width / img.height;\n          const containerRatio = width / height;\n          \n          let drawWidth, drawHeight, offsetX, offsetY;\n          \n          if (imgRatio > containerRatio) {\n            // Image is wider than container relative to height\n            drawHeight = height;\n            drawWidth = height * imgRatio;\n            offsetX = (width - drawWidth) / 2;\n            offsetY = 0;\n          } else {\n            // Image is taller than container relative to width\n            drawWidth = width;\n            drawHeight = width / imgRatio;\n            offsetX = 0;\n            offsetY = (height - drawHeight) / 2;\n          }\n          \n          ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);\n        }\n\n        function drawImageContain(ctx, img, x, y, width, height) {\n          const imgRatio = img.width / img.height;\n          const containerRatio = width / height;\n          \n          let drawWidth, drawHeight, offsetX, offsetY;\n          \n          if (imgRatio > containerRatio) {\n            // Image is wider than container relative to height\n            drawWidth = width;\n            drawHeight = width / imgRatio;\n            offsetX = 0;\n            offsetY = (height - drawHeight) / 2;\n          } else {\n            // Image is taller than container relative to width\n            drawHeight = height;\n            drawWidth = height * imgRatio;\n            offsetX = (width - drawWidth) / 2;\n            offsetY = 0;\n          }\n          \n          ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);\n        }\n\n        async function handleImageExport(buttonType) {\n          // Disable button and show loading state\n          const button = buttonType === \'download\' ? downloadBtn : twitterBtn;\n          const originalButtonText = button.innerHTML;\n          button.disabled = true;\n          button.innerHTML = \'<i class="fas fa-spinner fa-spin"></i> Processing...\';\n\n          // Save preferences before download/sharing\n          savePreferences();\n\n          // Get the selected format\n          const selectedFormat = document.querySelector(\'input[name="imageFormat"]:checked\').value;\n          const mimeType = \'image/\' + (selectedFormat === \'jpg\' ? \'jpeg\' : selectedFormat);\n          const fileExtension = selectedFormat;\n          \n          // Different quality settings based on format\n          const quality = selectedFormat === \'webp\' ? 0.92 : \n                         selectedFormat === \'jpg\' ? 0.9 : 1.0;\n\n          // Check if this is an iOS device\n          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n          const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n          const isIOSSafari = isIOS && isSafari;\n          \n          await preloadFonts();\n\n          // Check if we\'re dealing with an external background image\n          const hasExternalImage = hasBackgroundImage && \n            (backgroundImageSource === \'giphy\' || backgroundImageSource === \'featured\' || backgroundImageSource === \'upload\');\n\n          // Prepare the card for export and get the restore function\n          const restoreStyles = prepareCardForExport();\n\n          try {\n            // For iOS Safari, use our custom canvas renderer\n            if (isIOSSafari) {\n              const canvas = await createIOSFriendlyCanvas(cardPreview, {\n                useCORS: true,\n                allowTaint: true,\n                backgroundColor: selectedFormat === \'jpg\' ? \'#ffffff\' : null,\n                scale: 1.5, // Lower scale for better performance\n                logging: false\n              });\n              \n              // Process canvas result using a more iOS-friendly approach\n              try {\n                // Modern browsers support toBlob directly\n                canvas.toBlob(async function(blob) {\n                  try {\n                    // Create a proper File object with name and type\n                    const file = new File([blob], `mypointcard.${fileExtension}`, {\n                      type: mimeType,\n                      lastModified: new Date().getTime()\n                    });\n                    \n                    if (buttonType === \'download\') {\n                      // Try the direct sharing first\n                      if (navigator.canShare && navigator.canShare({ files: [file] })) {\n                        try {\n                          await navigator.share({\n                            files: [file],\n                            title: \'My Point Card\'\n                          });\n                          \n                          // Increment download count\n                          cardDownloadCount++;\n                          localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                          showAlert(`Card shared successfully!`, \'success\');\n                        } catch (shareError) {\n                          // Only show error if not an abort\n                          if (shareError.name !== \'AbortError\') {\n                            console.error(\'Share error:\', shareError);\n                            \n                            // Fallback to traditional download\n                            const blobUrl = URL.createObjectURL(blob);\n                            const link = document.createElement(\'a\');\n                            link.href = blobUrl;\n                            link.download = `mypointcard.${fileExtension}`;\n                            document.body.appendChild(link);\n                            link.click();\n                            document.body.removeChild(link);\n                            URL.revokeObjectURL(blobUrl);\n                            \n                            cardDownloadCount++;\n                            localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                            showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, \'success\');\n                          }\n                        }\n                      } else {\n                        // Fallback for browsers without share API\n                        const blobUrl = URL.createObjectURL(blob);\n                        const link = document.createElement(\'a\');\n                        link.href = blobUrl;\n                        link.download = `mypointcard.${fileExtension}`;\n                        document.body.appendChild(link);\n                        link.click();\n                        document.body.removeChild(link);\n                        URL.revokeObjectURL(blobUrl);\n                        \n                        cardDownloadCount++;\n                        localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                        showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, \'success\');\n                      }\n                    } else if (buttonType === \'twitter\') {\n                      // For Twitter, try to share directly if sharing API is available\n                      if (navigator.canShare && navigator.canShare({ files: [file] })) {\n                        try {\n                          await navigator.share({\n                            files: [file],\n                            title: \'My Point Card\',\n                            text: \'Check out my card created with MyPointCards!\'\n                          });\n                          cardDownloadCount++;\n                          localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                          showAlert(`Card shared successfully!`, \'success\');\n                        } catch (shareError) {\n                          // Only show error if not an abort\n                          if (shareError.name !== \'AbortError\') {\n                            // Fallback: Download file and open Twitter\n                            const blobUrl = URL.createObjectURL(blob);\n                            const link = document.createElement(\'a\');\n                            link.href = blobUrl;\n                            link.download = `mypointcard.${fileExtension}`;\n                            document.body.appendChild(link);\n                            link.click();\n                            document.body.removeChild(link);\n                            URL.revokeObjectURL(blobUrl);\n                            \n                            window.open(\'https://x.com/compose/tweet\', \'_blank\');\n                            cardDownloadCount++;\n                            localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                            showAlert(`Card saved as ${fileExtension.toUpperCase()}! Please upload it to your X post.`, \'success\');\n                          }\n                        }\n                      } else {\n                        // Fallback for browsers without share API\n                        const blobUrl = URL.createObjectURL(blob);\n                        const link = document.createElement(\'a\');\n                        link.href = blobUrl;\n                        link.download = `mypointcard.${fileExtension}`;\n                        document.body.appendChild(link);\n                        link.click();\n                        document.body.removeChild(link);\n                        URL.revokeObjectURL(blobUrl);\n                        \n                        window.open(\'https://x.com/compose/tweet\', \'_blank\');\n                        cardDownloadCount++;\n                        localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                        showAlert(`Card saved as ${fileExtension.toUpperCase()}! Please upload it to your X post.`, \'success\');\n                      }\n                    }\n                  } finally {\n                    // Re-enable the button after processing completes\n                    restoreStyles();\n                    button.disabled = false;\n                    button.innerHTML = originalButtonText;\n                  }\n                }, mimeType, quality);\n              } catch (err) {\n                console.error(\'Error processing canvas on iOS:\', err);\n                showAlert(\'Unable to process image. Try using a solid color background.\', \'warning\');\n                restoreStyles();\n                button.disabled = false;\n                button.innerHTML = originalButtonText;\n              }\n            } else {\n              // For other browsers, use standard html2canvas with some optimizations\n              const canvas = await html2canvas(cardPreview, {\n                allowTaint: false,\n                useCORS: true,\n                scale: 2,\n                backgroundColor: selectedFormat === \'jpg\' ? \'#ffffff\' : null,\n                logging: false\n              });\n              \n              // Use toBlob for non-iOS browsers\n              canvas.toBlob(function(blob) {\n                try {\n                  // Create download link\n                  const link = document.createElement(\'a\');\n                  link.href = URL.createObjectURL(blob);\n                  link.download = `mypointcard.${fileExtension}`;\n                  document.body.appendChild(link);\n                  link.click();\n                  document.body.removeChild(link);\n                  URL.revokeObjectURL(link.href);\n                  \n                  // Increment download count\n                  cardDownloadCount++;\n                  localStorage.setItem(\'myPointCardDownloadCount\', cardDownloadCount.toString());\n                  \n                  // If it\'s Twitter, also open Twitter\n                  if (buttonType === \'twitter\') {\n                    window.open(\'https://x.com/compose/tweet\', \'_blank\');\n                    showAlert(`Card saved as ${selectedFormat.toUpperCase()}! Please upload it to your X post.`, \'success\');\n                  } else {\n                    showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, \'success\');\n                  }\n                } catch (err) {\n                  console.error(\'Error generating download:\', err);\n                  showAlert(\'Unable to save image. Please try again.\', \'warning\');\n                } finally {\n                  restoreStyles();\n                  button.disabled = false;\n                  button.innerHTML = originalButtonText;\n                }\n              }, mimeType, quality);\n            }\n          } catch (err) {\n            console.error(\'Error generating image:\', err);\n            restoreStyles();\n            \n            // Show a more helpful error message\n            showAlert(\'Could not generate image. Try using a solid color background instead of an image.\', \'warning\');\n            \n            button.disabled = false;\n            button.innerHTML = originalButtonText;\n          }\n        }\n\n\n        // Add this function for showing a loading overlay on iOS\n        function showIOSLoadingOverlay(message = \'Processing...\') {\n          // Create overlay element\n          const overlay = document.createElement(\'div\');\n          overlay.style.position = \'fixed\';\n          overlay.style.top = \'0\';\n          overlay.style.left = \'0\';\n          overlay.style.width = \'100%\';\n          overlay.style.height = \'100%\';\n          overlay.style.backgroundColor = \'rgba(0,0,0,0.8)\';\n          overlay.style.display = \'flex\';\n          overlay.style.justifyContent = \'center\';\n          overlay.style.alignItems = \'center\';\n          overlay.style.flexDirection = \'column\';\n          overlay.style.zIndex = \'9999\';\n          \n          // Create spinner\n          const spinner = document.createElement(\'div\');\n          spinner.style.width = \'40px\';\n          spinner.style.height = \'40px\';\n          spinner.style.border = \'4px solid rgba(255,255,255,0.3)\';\n          spinner.style.borderTop = \'4px solid white\';\n          spinner.style.borderRadius = \'50%\';\n          spinner.style.animation = \'spin 1s linear infinite\';\n          \n          // Add animation style\n          const style = document.createElement(\'style\');\n          style.textContent = \'@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }\';\n          document.head.appendChild(style);\n          \n          // Create message\n          const messageDiv = document.createElement(\'div\');\n          messageDiv.style.color = \'white\';\n          messageDiv.style.marginTop = \'15px\';\n          messageDiv.textContent = message;\n          \n          // Add elements to overlay\n          overlay.appendChild(spinner);\n          overlay.appendChild(messageDiv);\n          document.body.appendChild(overlay);\n          \n          // Return function to hide overlay\n          return function() {\n            document.body.removeChild(overlay);\n          };\n        }\n\n        // Add a new function for Featured Images that works better on iOS\n        async function applyFeaturedImageIOSFriendly(imageUrl) {\n          try {\n            // Show loading indicator\n            const loadingOverlay = document.createElement(\'div\');\n            loadingOverlay.style.position = \'absolute\';\n            loadingOverlay.style.top = \'0\';\n            loadingOverlay.style.left = \'0\';\n            loadingOverlay.style.width = \'100%\';\n            loadingOverlay.style.height = \'100%\';\n            loadingOverlay.style.background = \'rgba(0,0,0,0.5)\';\n            loadingOverlay.style.display = \'flex\';\n            loadingOverlay.style.justifyContent = \'center\';\n            loadingOverlay.style.alignItems = \'center\';\n            loadingOverlay.style.zIndex = \'10\';\n            loadingOverlay.style.borderRadius = \'12px\';\n            loadingOverlay.innerHTML = \'<div class="spinner-border text-light" role="status"></div>\';\n            \n            cardPreview.style.position = \'relative\';\n            cardPreview.appendChild(loadingOverlay);\n            \n            // For iOS Safari, first try to convert to a Data URL\n            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n            const isIOSSafari = isIOS && isSafari;\n            \n            if (isIOSSafari) {\n              try {\n                // Create a new Image object\n                const img = new Image();\n                img.crossOrigin = \'anonymous\';\n                \n                // Create a Promise to handle the image loading\n                const dataUrl = await new Promise((resolve, reject) => {\n                  img.onload = function() {\n                    // Create a canvas to convert the image\n                    const canvas = document.createElement(\'canvas\');\n                    canvas.width = img.width;\n                    canvas.height = img.height;\n                    \n                    // Draw the image to the canvas\n                    const ctx = canvas.getContext(\'2d\');\n                    ctx.drawImage(img, 0, 0);\n                    \n                    // Get the data URL\n                    try {\n                      const dataUrl = canvas.toDataURL(\'image/png\');\n                      resolve(dataUrl);\n                    } catch (err) {\n                      reject(err);\n                    }\n                  };\n                  \n                  img.onerror = function() {\n                    reject(new Error(\'Failed to load image\'));\n                  };\n                  \n                  // Set a timeout to avoid hanging\n                  setTimeout(() => {\n                    reject(new Error(\'Image loading timed out\'));\n                  }, 5000);\n                  \n                  // Start loading the image\n                  img.src = imageUrl;\n                });\n                \n                // Apply the data URL as a background\n                cardPreview.style.backgroundImage = `url(${dataUrl})`;\n              } catch (err) {\n                console.warn(\'Failed to create data URL, falling back to direct URL:\', err);\n                cardPreview.style.backgroundImage = `url(${imageUrl})`;\n              }\n            } else {\n              // For other browsers, just use the URL directly\n              cardPreview.style.backgroundImage = `url(${imageUrl})`;\n            }\n            \n            // Setup the background\n            cardPreview.style.backgroundSize = \'contain\';\n            cardPreview.style.backgroundPosition = \'center\';\n            cardPreview.style.backgroundRepeat = \'no-repeat\';\n            \n            // Update state\n            hasBackgroundImage = true;\n            backgroundImageSource = \'featured\';\n            \n            // Reset position\n            cardPreview.style.backgroundPosition = \'50% 50%\';\n            initialBgPosX = 50;\n            initialBgPosY = 50;\n            currentBgPosX = 50;\n            currentBgPosY = 50;\n            \n            // Show background controls\n            showBackgroundControls();\n            \n            // Update cursor\n            updateCursorStyle();\n            \n            // Apply background darkness\n            applyBackgroundDarkness();\n            \n            return true;\n          } catch (error) {\n            console.error(\'Error applying featured image:\', error);\n            return false;\n          } finally {\n            // Remove any loading overlays\n            const loadingOverlay = cardPreview.querySelector(\'div[style*="background: rgba(0,0,0,0.5)"]\');\n            if (loadingOverlay) {\n              cardPreview.removeChild(loadingOverlay);\n            }\n          }\n        }\n\n        // Create a function to update the Featured Images to use the iOS-friendly function\n        function updateFeaturedImageHandlers() {\n          const featuredImgs = document.querySelectorAll(\'.featured-image\');\n          featuredImgs.forEach(img => {\n            // Clone and replace to remove old event listeners\n            const newImg = img.cloneNode(true);\n            img.parentNode.replaceChild(newImg, img);\n            \n            // Add new event listener that uses the iOS-friendly function\n            newImg.addEventListener(\'click\', async () => {\n              const imageUrl = newImg.dataset.originalUrl || newImg.src;\n              const success = await applyFeaturedImageIOSFriendly(imageUrl);\n              \n              if (success) {\n                showAlert(\'Featured image applied as background!\', \'success\');\n              } else {\n                showAlert(\'Could not apply image. Try another one.\', \'warning\');\n              }\n            });\n          });\n        }\n\n        // Helper function for detecting iOS device\n        function isIOSDevice() {\n          return /iPhone|iPad|iPod/i.test(navigator.userAgent) && \n                 !window.MSStream; // Exclude iPad with Windows\n        }\n\n\n        // Update download button to show "Share" on mobile and "Download" on desktop\n        function updateButtonLabels() {\n          const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n          \n          if (isMobileDevice) {\n            // Change download button to "Share"\n            downloadBtn.innerHTML = \'<i class="fas fa-share-alt"></i> Share\';\n            \n            // Hide Twitter button on mobile\n            if (twitterBtn) {\n              twitterBtn.style.display = \'none\';\n            }\n            \n          } else {\n            // Desktop button labels\n            downloadBtn.innerHTML = \'<i class="fas fa-download"></i> Download\';\n            \n            // Ensure Twitter button is visible on desktop\n            // if (twitterBtn) {\n            //   twitterBtn.style.display = \'block\';\n            // }\n          }\n        }\n\n        // Initialize all sharing functionality - simplest version\n        function initializeSharing() {\n          // Make sure share modal exists in the DOM\n          // ensureShareModalExists();\n          \n          // Update button labels based on device\n          updateButtonLabels();\n          \n          // Replace the onclick handlers directly\n          downloadBtn.onclick = function(e) {\n            e.preventDefault();\n            handleImageExport(\'download\');\n          };\n          \n          twitterBtn.onclick = function(e) {\n            e.preventDefault();\n            handleImageExport(\'twitter\');\n          };\n        }\n\n        function setupInlineTextEditing() {\n          // Add double-click handler to the previewText\n          previewText.addEventListener(\'dblclick\', function(e) {\n            e.stopPropagation();\n            \n            // Get current styles before making the element editable\n            const currentStyles = {\n              fontFamily: previewText.style.fontFamily,\n              fontSize: previewText.style.fontSize,\n              color: previewText.style.color,\n              textAlign: previewText.style.textAlign,\n              textShadow: previewText.style.textShadow,\n              lineHeight: previewText.style.lineHeight,\n              fontWeight: previewText.style.fontWeight\n            };\n            \n            // Store original position and styling\n            const originalPosition = {\n              left: previewText.style.left,\n              top: previewText.style.top,\n              transform: previewText.style.transform\n            };\n            \n            // Store original text\n            const originalText = previewText.innerText;\n            \n            // Make the element editable\n            previewText.setAttribute(\'contenteditable\', \'true\');\n            previewText.focus();\n            \n            // Select all text\n            const selection = window.getSelection();\n            const range = document.createRange();\n            range.selectNodeContents(previewText);\n            selection.removeAllRanges();\n            selection.addRange(range);\n            \n            // Add a visual indicator that the text is being edited\n            previewText.style.outline = \'2px dashed rgba(255, 255, 255, 0.7)\';\n            previewText.style.outlineOffset = \'4px\';\n            previewText.style.cursor = \'text\';\n            \n            // Show a small helper message\n            const editingMessage = document.createElement(\'div\');\n            editingMessage.innerHTML = \'Editing text... <br>Press Enter to save or Escape to cancel\';\n            editingMessage.style.position = \'absolute\';\n            editingMessage.style.bottom = \'10px\';\n            editingMessage.style.left = \'50%\';\n            editingMessage.style.transform = \'translateX(-50%)\';\n            editingMessage.style.backgroundColor = \'rgba(0, 0, 0, 0.7)\';\n            editingMessage.style.color = \'white\';\n            editingMessage.style.padding = \'8px 12px\';\n            editingMessage.style.borderRadius = \'4px\';\n            editingMessage.style.fontSize = \'12px\';\n            editingMessage.style.textAlign = \'center\';\n            editingMessage.style.zIndex = \'1000\';\n            editingMessage.id = \'editing-message\';\n            \n            cardPreview.appendChild(editingMessage);\n            // Set a timeout to auto-dismiss the editing message after 5 seconds\n            setTimeout(() => {\n                const message = document.getElementById(\'editing-message\');\n                if (message) {\n                    message.remove();\n                }\n            }, 5000);\n\n            \n            // Function to apply changes and sync with textarea\n            function applyChanges() {\n              const newText = previewText.innerText.trim();\n              \n              // Update textarea with the new text from preview\n              cardText.value = newText;\n              \n              // Remove contenteditable attribute\n              previewText.removeAttribute(\'contenteditable\');\n              \n              // Restore cursor style\n              previewText.style.cursor = \'move\';\n              \n              // Remove outline\n              previewText.style.outline = \'none\';\n              \n              // Remove helper message\n              const message = document.getElementById(\'editing-message\');\n              if (message) {\n                message.remove();\n              }\n              \n              // Reset original styling\n              for (const [property, value] of Object.entries(currentStyles)) {\n                previewText.style[property] = value;\n              }\n              \n              // Re-apply original position\n              previewText.style.left = originalPosition.left;\n              previewText.style.top = originalPosition.top;\n              previewText.style.transform = originalPosition.transform;\n              \n              // Save the changes to preferences\n              savePreferences();\n            }\n            \n            // Function to cancel changes\n            function cancelChanges() {\n              // Restore the original text\n              previewText.innerText = originalText;\n              \n              // Remove contenteditable\n              previewText.removeAttribute(\'contenteditable\');\n              \n              // Restore cursor style\n              previewText.style.cursor = \'move\';\n              \n              // Remove outline\n              previewText.style.outline = \'none\';\n              \n              // Remove helper message\n              const message = document.getElementById(\'editing-message\');\n              if (message) {\n                message.remove();\n              }\n              \n              // Reset original styling\n              for (const [property, value] of Object.entries(currentStyles)) {\n                previewText.style[property] = value;\n              }\n              \n              // Re-apply original position\n              previewText.style.left = originalPosition.left;\n              previewText.style.top = originalPosition.top;\n              previewText.style.transform = originalPosition.transform;\n            }\n            \n            // Handle Enter key to save changes\n            previewText.addEventListener(\'keydown\', function(evt) {\n              if (evt.key === \'Enter\' && !evt.shiftKey) {\n                evt.preventDefault();\n                applyChanges();\n              } else if (evt.key === \'Escape\') {\n                evt.preventDefault();\n                cancelChanges();\n              }\n            }, { once: true });\n            \n            // Handle clicking outside to save changes\n            function handleClickOutside(evt) {\n              if (!previewText.contains(evt.target) && previewText.getAttribute(\'contenteditable\') === \'true\') {\n                applyChanges();\n                document.removeEventListener(\'mousedown\', handleClickOutside);\n              }\n            }\n            \n            // Add the click outside listener after a short delay to avoid immediate trigger\n            setTimeout(() => {\n              document.addEventListener(\'mousedown\', handleClickOutside);\n            }, 100);\n          });\n        }\n\n        function addFormatSelection() {\n          // Find the text tab content\n          const textTab = document.getElementById(\'text\');\n          \n          // Create the format selection section\n          const formatSection = document.createElement(\'div\');\n          formatSection.className = \'mb-3 mt-4\';\n          formatSection.innerHTML = `\n            <label class="form-label">Download As:</label>\n            <div class="d-flex flex-wrap">\n              <div class="form-check me-3">\n                <input class="form-check-input" type="radio" name="imageFormat" id="formatWebP" value="webp" checked>\n                <label class="form-check-label" for="formatWebP">\n                  WebP\n                </label>\n              </div>\n              <div class="form-check me-3">\n                <input class="form-check-input" type="radio" name="imageFormat" id="formatPNG" value="png">\n                <label class="form-check-label" for="formatPNG">\n                  PNG \n                </label>\n              </div>\n              <div class="form-check">\n                <input class="form-check-input" type="radio" name="imageFormat" id="formatJPG" value="jpg">\n                <label class="form-check-label" for="formatJPG">\n                  JPG\n                </label>\n              </div>\n            </div>\n          `;\n          \n          // Find where to insert this section (before the closing tag of the text tab)\n          const existingDivs = textTab.querySelectorAll(\'.mb-3\');\n          if (existingDivs.length > 0) {\n            const lastDiv = existingDivs[existingDivs.length - 1];\n            lastDiv.parentNode.insertBefore(formatSection, lastDiv.nextSibling);\n          } else {\n            textTab.appendChild(formatSection);\n          }\n          \n          // Add to savePreferences function\n          const originalSavePreferences = savePreferences;\n          savePreferences = function() {\n            originalSavePreferences();\n            \n            // Save selected format\n            const selectedFormat = document.querySelector(\'input[name="imageFormat"]:checked\').value;\n            localStorage.setItem(\'myPointCardImageFormat\', selectedFormat);\n          }\n          \n          // Add to loadSavedPreferences function\n          const originalLoadSavedPreferences = loadSavedPreferences;\n          loadSavedPreferences = function() {\n            originalLoadSavedPreferences();\n            \n            // Load saved format preference\n            const savedFormat = localStorage.getItem(\'myPointCardImageFormat\');\n            if (savedFormat) {\n              const formatRadio = document.getElementById(\'format\' + savedFormat.toUpperCase().charAt(0) + savedFormat.slice(1));\n              if (formatRadio) {\n                formatRadio.checked = true;\n              }\n            }\n          }\n        }\n\n\n        function makeTextDraggable() {\n          previewText.style.position = \'absolute\';\n          previewText.style.transform = \'translate(-50%, -50%)\';\n          previewText.style.left = \'50%\';\n          previewText.style.top = \'50%\';\n          previewText.style.cursor = \'move\';\n          \n          // Update the tooltip to include double-click information\n          previewText.title = "Drag to reposition or double-click to edit text";\n          \n          // Add visual indicator when hovering\n          previewText.addEventListener(\'mouseover\', function() {\n            if (previewText.style.boxShadow !== \'0 0 8px rgba(0, 123, 255, 0.5)\') {\n              previewText.dataset.originalBoxShadow = previewText.style.boxShadow;\n              previewText.style.boxShadow = \'0 0 8px rgba(0, 123, 255, 0.5)\';\n            }\n          });\n          \n          previewText.addEventListener(\'mouseout\', function() {\n            if (!textIsDragging && previewText.dataset.originalBoxShadow !== undefined) {\n              previewText.style.boxShadow = previewText.dataset.originalBoxShadow;\n            }\n          });\n        }\n\n        function setupTextDragging() {\n          // Mouse events\n          previewText.addEventListener(\'mousedown\', function(e) {\n            textIsDragging = true;\n            textDragStartX = e.clientX;\n            textDragStartY = e.clientY;\n            \n            // Get current position\n            const rect = cardPreview.getBoundingClientRect();\n            const textRect = previewText.getBoundingClientRect();\n            \n            // Calculate current position in percentage\n            textPosX = ((textRect.left + textRect.width/2) - rect.left) / rect.width * 100;\n            textPosY = ((textRect.top + textRect.height/2) - rect.top) / rect.height * 100;\n            \n            // Change cursor to indicate dragging\n            previewText.style.cursor = \'grabbing\';\n            \n            // Stop event propagation to prevent the card preview\'s drag handler from triggering\n            e.stopPropagation();\n            e.preventDefault();\n          });\n          \n          document.addEventListener(\'mousemove\', function(e) {\n            if (textIsDragging) {\n              const deltaX = e.clientX - textDragStartX;\n              const deltaY = e.clientY - textDragStartY;\n              \n              const rect = cardPreview.getBoundingClientRect();\n              \n              // Update position in percentages\n              const newPosX = textPosX + (deltaX / rect.width * 100);\n              const newPosY = textPosY + (deltaY / rect.height * 100);\n              \n              // Apply constraints to keep text within bounds\n              const boundedX = Math.min(Math.max(newPosX, 10), 90);\n              const boundedY = Math.min(Math.max(newPosY, 10), 90);\n              \n              // Update position\n              previewText.style.left = boundedX + \'%\';\n              previewText.style.top = boundedY + \'%\';\n              \n              // Save new positions for when dragging ends\n              textPosX = boundedX;\n              textPosY = boundedY;\n              \n              textDragStartX = e.clientX;\n              textDragStartY = e.clientY;\n              \n              // Stop event propagation\n              e.stopPropagation();\n            }\n          });\n          \n          document.addEventListener(\'mouseup\', function(e) {\n            if (textIsDragging) {\n              textIsDragging = false;\n              previewText.style.cursor = \'move\';\n              \n              // Save the position to preferences\n              savePreferences();\n              \n              // Restore normal box shadow\n              if (previewText.dataset.originalBoxShadow !== undefined) {\n                previewText.style.boxShadow = previewText.dataset.originalBoxShadow;\n              }\n              \n              // Stop event propagation only if we were dragging text\n              e.stopPropagation();\n            }\n          });\n          \n          // Touch events for mobile\n          previewText.addEventListener(\'touchstart\', function(e) {\n            if (e.touches.length === 1) {\n              textIsDragging = true;\n              textDragStartX = e.touches[0].clientX;\n              textDragStartY = e.touches[0].clientY;\n              \n              // Calculate current position (same as in mousedown)\n              const rect = cardPreview.getBoundingClientRect();\n              const textRect = previewText.getBoundingClientRect();\n              textPosX = ((textRect.left + textRect.width/2) - rect.left) / rect.width * 100;\n              textPosY = ((textRect.top + textRect.height/2) - rect.top) / rect.height * 100;\n              \n              // Stop event propagation\n              e.stopPropagation();\n            }\n          });\n          \n          previewText.addEventListener(\'touchmove\', function(e) {\n            if (textIsDragging && e.touches.length === 1) {\n              const touch = e.touches[0];\n              const deltaX = touch.clientX - textDragStartX;\n              const deltaY = touch.clientY - textDragStartY;\n              \n              const rect = cardPreview.getBoundingClientRect();\n              \n              // Same logic as mousemove\n              const newPosX = textPosX + (deltaX / rect.width * 100);\n              const newPosY = textPosY + (deltaY / rect.height * 100);\n              \n              const boundedX = Math.min(Math.max(newPosX, 10), 90);\n              const boundedY = Math.min(Math.max(newPosY, 10), 90);\n              \n              previewText.style.left = boundedX + \'%\';\n              previewText.style.top = boundedY + \'%\';\n              \n              textPosX = boundedX;\n              textPosY = boundedY;\n              \n              textDragStartX = touch.clientX;\n              textDragStartY = touch.clientY;\n              \n              // Stop event propagation and prevent scrolling\n              e.stopPropagation();\n              e.preventDefault();\n            }\n          });\n          \n          previewText.addEventListener(\'touchend\', function(e) {\n            if (textIsDragging) {\n              textIsDragging = false;\n              savePreferences();\n              \n              // Stop event propagation\n              e.stopPropagation();\n            }\n          });\n          \n          previewText.addEventListener(\'touchcancel\', function(e) {\n            textIsDragging = false;\n            e.stopPropagation();\n          });\n        }\n\n        function setupUserActivityTracking() {\n            // Reset activity timer whenever user interacts with the page\n            document.addEventListener(\'mousemove\', resetUserActivityTimer);\n            document.addEventListener(\'mousedown\', resetUserActivityTimer);\n            document.addEventListener(\'keypress\', resetUserActivityTimer);\n            document.addEventListener(\'scroll\', resetUserActivityTimer);\n            document.addEventListener(\'touchstart\', resetUserActivityTimer);\n            \n            // Initialize the activity timer\n            resetUserActivityTimer();\n        }\n\n        function resetUserActivityTimer() {\n            // User is active now\n            if (!isUserActive) {\n                // If user was inactive and now active, restart the timer\n                isUserActive = true;\n                appStartTime = new Date();\n            }\n            \n            // Clear any existing timeout\n            if (userActivityTimeout) {\n                clearTimeout(userActivityTimeout);\n            }\n            \n            // Set a new timeout\n            userActivityTimeout = setTimeout(function() {\n                // User has been inactive for the timeout period\n                if (isUserActive && appStartTime) {\n                    // Save the time elapsed since they were last active\n                    const now = new Date();\n                    const sessionTime = Math.floor((now - appStartTime) / 1000);\n                    totalTimeSpent += sessionTime;\n                    localStorage.setItem(\'myPointCardTimeSpent\', totalTimeSpent.toString());\n                    appStartTime = null;\n                    isUserActive = false;\n                    \n                    // Update the display\n                    const count = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n                    const downloads = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n                    updateUsageStats(count, totalTimeSpent, downloads);\n                }\n            }, INACTIVITY_TIMEOUT);\n        }\n\n\n        function initUsageCounter() {\n\n            // Skip if tracking is disabled\n            if (ENABLE_USAGE_TRACKING !== \'yes\') return;\n\n\n            // Get current count from localStorage\n            const usageCount = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n            \n            // Increment by 1 for this session\n            const newUsageCount = usageCount + 1;\n            \n            // Store the incremented value back\n            localStorage.setItem(\'myPointCardUsageCount\', newUsageCount.toString());\n            \n            // Load time spent\n            totalTimeSpent = parseInt(localStorage.getItem(\'myPointCardTimeSpent\') || \'0\');\n            \n            // Load download count - NEW\n            cardDownloadCount = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n            \n            // Update the display\n            updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);\n        }\n\n\n        // Add this function to handle time formatting\n        function formatTime(seconds) {\n            const hours = Math.floor(seconds / 3600);\n            const minutes = Math.floor((seconds % 3600) / 60);\n            const secs = Math.floor(seconds % 60);\n            return `${hours.toString().padStart(2, \'0\')}:${minutes.toString().padStart(2, \'0\')}:${secs.toString().padStart(2, \'0\')}`;\n        }\n\n        // Update the loadSavedPreferences function to load usage data\n        function loadSavedPreferences() {\n\n\n            const savedLineHeight = localStorage.getItem(\'myPointCardLineHeight\');\n            if (savedLineHeight) {\n                lineHeight.value = savedLineHeight;\n                lineHeightValue.textContent = savedLineHeight;\n                previewText.style.lineHeight = savedLineHeight;\n            }\n\n            const savedPoweredBy = localStorage.getItem(\'myPointCardPoweredBy\');\n            if (savedPoweredBy !== null) {\n                const showPoweredBy = savedPoweredBy === \'true\';\n                poweredBy.checked = showPoweredBy;\n                poweredByText.style.display = showPoweredBy ? \'block\' : \'none\';\n            }\n            \n            // Other existing preferences loading...\n            const savedFontFamily = localStorage.getItem(\'myPointCardFontFamily\');\n            if (savedFontFamily) {\n                fontFamily.value = savedFontFamily;\n                previewText.style.fontFamily = savedFontFamily;\n            }\n            \n            const savedFontSize = localStorage.getItem(\'myPointCardFontSize\');\n            if (savedFontSize) {\n                fontSize.value = savedFontSize;\n                fontSizeValue.textContent = savedFontSize;\n                previewText.style.fontSize = `${savedFontSize}px`;\n            }\n            \n            const savedFontColor = localStorage.getItem(\'myPointCardFontColor\');\n            if (savedFontColor) {\n                fontColor.value = savedFontColor;\n                fontColorHex.textContent = savedFontColor;\n                previewText.style.color = savedFontColor;\n            }\n            \n            const savedTextShadow = localStorage.getItem(\'myPointCardTextShadow\');\n            if (savedTextShadow !== null) {\n                const useTextShadow = savedTextShadow === \'true\';\n                textShadow.checked = useTextShadow;\n                previewText.style.textShadow = useTextShadow ? \'0 2px 4px rgba(0, 0, 0, 0.5)\' : \'none\';\n            }\n\n            // Load text alignment preference\n            const savedTextAlign = localStorage.getItem(\'myPointCardTextAlign\');\n            if (savedTextAlign) {\n                switch(savedTextAlign) {\n                    case \'left\':\n                        alignLeft.checked = true;\n                        previewText.style.textAlign = \'left\';\n                        break;\n                    case \'right\':\n                        alignRight.checked = true;\n                        previewText.style.textAlign = \'right\';\n                        break;\n                    default:\n                        alignCenter.checked = true;\n                        previewText.style.textAlign = \'center\';\n                }\n            } else {\n                // Default to center if no preference is saved\n                alignCenter.checked = true;\n                previewText.style.textAlign = \'center\';\n            }\n\n            // Load usage tracking data\n            const usageCount = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n            const timeSpent = localStorage.getItem(\'myPointCardTimeSpent\') || 0;\n\n             // Load download count\n             cardDownloadCount = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n    \n\n            \n            // Update usage count and display it\n            const newUsageCount = parseInt(usageCount) + 1;\n            localStorage.setItem(\'myPointCardUsageCount\', newUsageCount.toString());\n            totalTimeSpent = parseInt(timeSpent);\n            \n            // Update the UI to show usage stats with download count\n            updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);\n\n            const savedTextPosX = localStorage.getItem(\'myPointCardTextPosX\');\n            const savedTextPosY = localStorage.getItem(\'myPointCardTextPosY\');\n          \n            if (savedTextPosX && savedTextPosY) {\n                textPosX = parseFloat(savedTextPosX);\n                textPosY = parseFloat(savedTextPosY);\n                previewText.style.left = textPosX + \'%\';\n                previewText.style.top = textPosY + \'%\';\n             }\n\n        }\n\n        function updateUsageStats(count, timeInSeconds, downloads) {\n            if (ENABLE_USAGE_TRACKING !== \'yes\') return;\n\n            const formattedTime = formatTime(timeInSeconds);\n            \n            // Find the container first - this is a crucial part\n            const footerContainer = document.querySelector(\'.footer-container\');\n            if (!footerContainer) return;\n            \n            // Check if the stats element already exists\n            let statsElement = document.getElementById(\'usageStats\');\n            \n            if (!statsElement) {\n                // Create a new element if it doesn\'t exist\n                statsElement = document.createElement(\'p\');\n                statsElement.id = \'usageStats\';\n                statsElement.className = \'text-muted\';\n                statsElement.style.fontSize = \'0.75em\';\n                statsElement.style.color = \'#6c757d\';\n                statsElement.style.margin = \'0\';\n                statsElement.style.marginTop = \'5px\';\n                \n                // Make sure to append to the container\n                footerContainer.appendChild(statsElement);\n            }\n            \n            // Update the text with download count\n            statsElement.textContent = `Loaded ${count} times for ${formattedTime} & created ${downloads} cards`;\n        }\n\n        function startTimeTracking() {\n\n             // Skip if tracking is disabled\n            if (ENABLE_USAGE_TRACKING !== \'yes\') return;\n\n            appStartTime = new Date();\n            isUserActive = true;\n            \n            // Set up event handlers for tracking when user leaves/closes\n            window.addEventListener(\'beforeunload\', stopTimeTracking);\n            document.addEventListener(\'visibilitychange\', handleVisibilityChange);\n            \n            // Set up activity tracking\n            setupUserActivityTracking();\n        }\n\n        function handleVisibilityChange() {\n            if (document.hidden) {\n                // User switched tabs or minimized window\n                if (isUserActive && appStartTime) {\n                    const now = new Date();\n                    const sessionTime = Math.floor((now - appStartTime) / 1000);\n                    totalTimeSpent += sessionTime;\n                    localStorage.setItem(\'myPointCardTimeSpent\', totalTimeSpent.toString());\n                    appStartTime = null;\n                    isUserActive = false;\n                }\n            } else {\n                // User returned to tab - reset activity timer\n                resetUserActivityTimer();\n            }\n        }\n        function stopTimeTracking() {\n\n            // Skip if tracking is disabled\n            if (ENABLE_USAGE_TRACKING !== \'yes\') return;\n\n            if (appStartTime) {\n                const now = new Date();\n                const sessionTime = Math.floor((now - appStartTime) / 1000); // Time in seconds\n                appStartTime = null;\n                \n                // Update total time\n                totalTimeSpent += sessionTime;\n                localStorage.setItem(\'myPointCardTimeSpent\', totalTimeSpent);\n                \n                // Update the stats display\n                const count = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'1\');\n                const downloads = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n                updateUsageStats(count, totalTimeSpent, downloads);\n            }\n        }\n\n\n        // Add CSS class for dragging indicator\n        function addDraggingStyleIfNeeded() {\n            // Check if the style already exists\n            if (!document.getElementById(\'draggingStyle\')) {\n                const style = document.createElement(\'style\');\n                style.id = \'draggingStyle\';\n                style.textContent = `\n                    .card-preview.dragging {\n                        cursor: move !important;\n                        cursor: grabbing !important;\n                        border: 2px dashed rgba(255, 255, 255, 0.5) !important;\n                    }\n                    \n                    .card-preview:hover {\n                        cursor: ${hasBackgroundImage ? \'grab\' : \'default\'};\n                    }\n                    \n                    @media (max-width: 768px) {\n                        #dragHint {\n                            padding: 8px;\n                            background-color: rgba(0, 0, 0, 0.05);\n                            border-radius: 4px;\n                            font-weight: 500;\n                        }\n                    }\n                `;\n                document.head.appendChild(style);\n            }\n        }\n\n\n        // Call this function when the page loads\n        document.addEventListener(\'DOMContentLoaded\', function() {\n\n\n            // Add CSS for the usage stats\n            const style = document.createElement(\'style\');\n            style.textContent = `\n                #usageStats {\n                    color: #6c757d;\n                    font-size: 0.8em;\n                    margin-top: 0.25rem;\n                }\n                \n                [data-bs-theme="dark"] #usageStats {\n                    color: #adb5bd;\n                }\n            `;\n            document.head.appendChild(style);\n\n            // Only set up the interval if tracking is enabled\n            if (ENABLE_USAGE_TRACKING === \'yes\') {\n                setInterval(function() {\n                    if (appStartTime) {\n                        const sessionTime = Math.floor((new Date() - appStartTime) / 1000);\n                        const displayTime = totalTimeSpent + sessionTime;\n                        const count = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n                        const downloads = parseInt(localStorage.getItem(\'myPointCardDownloadCount\') || \'0\');\n                        updateUsageStats(parseInt(count), displayTime, downloads);\n                    }\n                }, 1000);\n            }\n\n\n          setupClipboardPaste();\n\n\n          initializeApp();\n\n\n          // First clean up any existing toggles\n          cleanupExistingToggles();\n          \n          // Then set up a fresh one\n          setupTextOptionsToggle();\n          \n          // Handle tab switching\n          const textTab = document.getElementById(\'text-tab\');\n          if (textTab) {\n            textTab.addEventListener(\'click\', function() {\n              // Clean up first, then set up\n              setTimeout(function() {\n                cleanupExistingToggles();\n                setupTextOptionsToggle();\n              }, 100);\n            });\n          }\n          \n          // Handle window resize\n          let resizeTimer;\n          window.addEventListener(\'resize\', function() {\n            clearTimeout(resizeTimer);\n            resizeTimer = setTimeout(function() {\n              // If switching between desktop and mobile views\n              const isMobile = window.innerWidth <= 768;\n              \n              if (isMobile) {\n                // On mobile, clean up and recreate the toggle\n                cleanupExistingToggles();\n                setupTextOptionsToggle();\n              } else {\n                // On desktop, just clean up any toggles\n                cleanupExistingToggles();\n              }\n            }, 250);\n          });\n\n\n        });\n\n\n        // Update cursor style when background image status changes\n        function updateCursorStyle() {\n            if (hasBackgroundImage) {\n                cardPreview.style.cursor = \'grab\';\n            } else {\n                cardPreview.style.cursor = \'default\';\n            }\n        }\n\n        if (isMobile) {\n            // Create tip element\n            const mobileTip = document.createElement(\'div\');\n            mobileTip.id = \'mobileInfoTip\';\n            mobileTip.textContent = \'Tap an image to use it as background\';\n            document.body.appendChild(mobileTip);\n            \n            // Show tip when featured tab is clicked on mobile\n            featuredTab.addEventListener(\'click\', function() {\n                if (mobileTip) {\n                    mobileTip.style.display = \'block\';\n                    setTimeout(() => {\n                        mobileTip.style.display = \'none\';\n                    }, 3000);\n                }\n            });\n            \n            // Modify the featured image display function to show image info differently on mobile\n            const originalDisplayFeaturedImages = displayFeaturedImages;\n            displayFeaturedImages = function(images, searchTerm = \'\') {\n                originalDisplayFeaturedImages(images, searchTerm);\n                \n                if (isMobile) {\n                    // Add long-press handler to show info for mobile\n                    const featuredImgs = document.querySelectorAll(\'.featured-image\');\n                    featuredImgs.forEach(img => {\n                        let pressTimer;\n                        \n                        img.addEventListener(\'touchstart\', function(e) {\n                            pressTimer = setTimeout(function() {\n                                // Get the category and tags from the parent container\n                                const infoDiv = img.parentElement.querySelector(\'.image-info\');\n                                if (infoDiv) {\n                                    const infoText = infoDiv.textContent.trim();\n                                    alert(`Image Info: ${infoText}`);\n                                }\n                            }, 800); // Long press threshold - 800ms\n                        });\n                        \n                        img.addEventListener(\'touchend\', function() {\n                            clearTimeout(pressTimer);\n                        });\n                        \n                        img.addEventListener(\'touchmove\', function() {\n                            clearTimeout(pressTimer);\n                        });\n                    });\n                }\n            };\n        }\n\n        function applyBackgroundDarkness() {\n            if (hasBackgroundImage) {\n                const opacity = parseInt(bgOpacity.value);\n                bgOpacityValue.textContent = opacity;\n                \n                // Get the current background image style\n                let bgImageUrl = cardPreview.style.backgroundImage;\n                \n                // If it already has a linear gradient, extract just the URL part\n                if (bgImageUrl.includes(\'linear-gradient\')) {\n                    // Find where the URL starts (after the gradient)\n                    const urlStartIndex = bgImageUrl.lastIndexOf(\'url(\');\n                    if (urlStartIndex !== -1) {\n                        bgImageUrl = bgImageUrl.substring(urlStartIndex);\n                    }\n                }\n                \n                // Apply the appropriate background image based on the opacity setting\n                if (opacity === 0) {\n                    // If opacity is 0, use just the image without any darkness overlay\n                    cardPreview.style.backgroundImage = bgImageUrl;\n                } else {\n                    // Apply the gradient overlay with specified opacity\n                    cardPreview.style.backgroundImage = \n                        `linear-gradient(rgba(0,0,0,${opacity/100}), rgba(0,0,0,${opacity/100})), ${bgImageUrl}`;\n                }\n            }\n        }\n\n\n        // Hook this into existing functions that change background image status\n        const originalApplyBackgroundDarkness = applyBackgroundDarkness;\n        applyBackgroundDarkness = function() {\n            originalApplyBackgroundDarkness();\n            updateCursorStyle();\n        };\n\n        // Ensure we update cursor style after removing background images too\n        const originalRemoveImage = removeImage.onclick;\n        removeImage.onclick = function() {\n            if (typeof originalRemoveImage === \'function\') {\n                originalRemoveImage();\n            } else {\n                // Fallback - copy existing functionality\n                imageUpload.value = \'\';\n                uploadPreview.classList.add(\'d-none\');\n                cardPreview.style.backgroundImage = \'none\';\n                hasBackgroundImage = false;\n                backgroundImageSource = null;\n                \n                const activeColorBox = document.querySelector(\'.color-box.active\');\n                if (activeColorBox) {\n                    cardPreview.style.backgroundColor = activeColorBox.getAttribute(\'data-color\');\n                } else {\n                    cardPreview.style.backgroundColor = customColor.value;\n                }\n                \n                hideBackgroundControls();\n                showAlert(\'Image removed!\', \'info\');\n            }\n            updateCursorStyle();\n        };\n\n\n        // Show controls when an image is selected\n        function showBackgroundControls() {\n            backgroundControls.style.display = \'block\';\n            \n            // Add a hint about dragging functionality\n            const dragHint = document.getElementById(\'dragHint\') || document.createElement(\'div\');\n            dragHint.id = \'dragHint\';\n            dragHint.className = \'mt-2 small text-muted\';\n            // Enhanced message depending on device\n            if (isMobile) {\n                dragHint.innerHTML = \'<i class="fas fa-hand-point-up"></i> You can drag on the card to position the image precisely\';\n            } else {\n                dragHint.innerHTML = \'<i class="fas fa-mouse-pointer"></i> You can drag on the card to position the image precisely\';\n            }\n            \n            \n            if (!document.getElementById(\'dragHint\')) {\n                backgroundControls.appendChild(dragHint);\n            }\n        }\n\n        // Hide controls when no image is selected\n        function hideBackgroundControls() {\n            backgroundControls.style.display = \'none\';\n        }\n\n        // Load saved preferences from localStorage\n        function loadSavedPreferences() {\n\n            // Fix the counter logic\n            const usageCount = parseInt(localStorage.getItem(\'myPointCardUsageCount\') || \'0\');\n            \n            // Increment by 1 for this session\n            const newUsageCount = usageCount + 1;\n            \n            // Store the incremented value back\n            localStorage.setItem(\'myPointCardUsageCount\', newUsageCount.toString());\n\n            // Check if poweredBy preference is saved\n            const savedPoweredBy = localStorage.getItem(\'myPointCardPoweredBy\');\n            if (savedPoweredBy !== null) {\n                const showPoweredBy = savedPoweredBy === \'true\';\n                poweredBy.checked = showPoweredBy;\n                poweredByText.style.display = showPoweredBy ? \'block\' : \'none\';\n            }\n            \n            // Check if font preferences are saved\n            const savedFontFamily = localStorage.getItem(\'myPointCardFontFamily\');\n            if (savedFontFamily) {\n                fontFamily.value = savedFontFamily;\n                previewText.style.fontFamily = savedFontFamily;\n            }\n            \n            const savedFontSize = localStorage.getItem(\'myPointCardFontSize\');\n            if (savedFontSize) {\n                fontSize.value = savedFontSize;\n                fontSizeValue.textContent = savedFontSize;\n                previewText.style.fontSize = `${savedFontSize}px`;\n            }\n            \n            const savedFontColor = localStorage.getItem(\'myPointCardFontColor\');\n            if (savedFontColor) {\n                fontColor.value = savedFontColor;\n                fontColorHex.textContent = savedFontColor;\n                previewText.style.color = savedFontColor;\n            }\n            \n            const savedTextShadow = localStorage.getItem(\'myPointCardTextShadow\');\n            if (savedTextShadow !== null) {\n                const useTextShadow = savedTextShadow === \'true\';\n                textShadow.checked = useTextShadow;\n                previewText.style.textShadow = useTextShadow ? \'0 2px 4px rgba(0, 0, 0, 0.5)\' : \'none\';\n            }\n\n            // Load text alignment preference\n           const savedTextAlign = localStorage.getItem(\'myPointCardTextAlign\');\n           if (savedTextAlign) {\n             switch(savedTextAlign) {\n              case \'left\':\n                alignLeft.checked = true;\n                previewText.style.textAlign = \'left\';\n                break;\n              case \'right\':\n                alignRight.checked = true;\n                previewText.style.textAlign = \'right\';\n                break;\n              default:\n                alignCenter.checked = true;\n                previewText.style.textAlign = \'center\';\n             }\n           } else {\n             // Default to center if no preference is saved\n             alignCenter.checked = true;\n             previewText.style.textAlign = \'center\';\n           }\n\n\n          // Update the display\n          updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);\n\n\n        }\n\n        // Save preferences to localStorage\n        function savePreferences() {\n            localStorage.setItem(\'myPointCardPoweredBy\', poweredBy.checked);\n            localStorage.setItem(\'myPointCardFontFamily\', fontFamily.value);\n            localStorage.setItem(\'myPointCardFontSize\', fontSize.value);\n            localStorage.setItem(\'myPointCardFontColor\', fontColor.value);\n            localStorage.setItem(\'myPointCardTextShadow\', textShadow.checked);\n            localStorage.setItem(\'myPointCardLineHeight\', lineHeight.value);\n            localStorage.setItem(\'myPointCardTextPosX\', textPosX);\n            localStorage.setItem(\'myPointCardTextPosY\', textPosY);\n        }\n\n        // Helper function to show alerts\n        function showAlert(message, type = \'info\') {\n            const alertDiv = document.createElement(\'div\');\n            alertDiv.className = `alert alert-${type} position-fixed bottom-0 end-0 m-3`;\n            alertDiv.innerHTML = message;\n            document.body.appendChild(alertDiv);\n            \n            setTimeout(() => {\n                if (document.body.contains(alertDiv)) {\n                    document.body.removeChild(alertDiv);\n                }\n            }, 3000);\n        }\n        \n        // Helper function to calculate Levenshtein distance for typo tolerance\n        function levenshteinDistance(a, b) {\n            if (a.length === 0) return b.length;\n            if (b.length === 0) return a.length;\n            \n            const matrix = [];\n            \n            // Initialize matrix\n            for (let i = 0; i <= b.length; i++) {\n                matrix[i] = [i];\n            }\n            \n            for (let j = 0; j <= a.length; j++) {\n                matrix[0][j] = j;\n            }\n            \n            // Fill matrix\n            for (let i = 1; i <= b.length; i++) {\n                for (let j = 1; j <= a.length; j++) {\n                    if (b.charAt(i-1) === a.charAt(j-1)) {\n                        matrix[i][j] = matrix[i-1][j-1];\n                    } else {\n                        matrix[i][j] = Math.min(\n                            matrix[i-1][j-1] + 1, // substitution\n                            matrix[i][j-1] + 1,   // insertion\n                            matrix[i-1][j] + 1    // deletion\n                        );\n                    }\n                }\n            }\n            \n            return matrix[b.length][a.length];\n        }\n\n\n        // Modified version of displayFeaturedImages for better iOS compatibility\n        function displayFeaturedImages(images, searchTerm = \'\', addPagination = true) {\n          featuredResults.innerHTML = \'\';\n          \n          if (!images || Object.keys(images).length === 0) {\n            featuredResults.innerHTML = \'<div class="alert alert-info">No featured images available.</div>\';\n            return;\n          }\n          \n          // Filter images if search term is provided\n          let filteredImages = Object.entries(images);\n          if (searchTerm) {\n            searchTerm = searchTerm.toLowerCase();\n            featuredCurrentQuery = searchTerm;\n            \n            filteredImages = filteredImages.filter(([id, image]) => {\n              // Check category\n              const category = (image.category || \'\').toLowerCase();\n              if (category.includes(searchTerm) || levenshteinDistance(category, searchTerm) <= 2) return true;\n              \n              // Check individual categories if it\'s a comma-separated list\n              const categories = category.split(\',\').map(cat => cat.trim());\n              if (categories.some(cat => cat.includes(searchTerm) || levenshteinDistance(cat, searchTerm) <= 2)) return true;\n              \n              // Check tags\n              const tags = (image.tags || \'\').toLowerCase();\n              if (tags.includes(searchTerm) || levenshteinDistance(tags, searchTerm) <= 2) return true;\n              \n              // Check individual tags if it\'s a comma-separated list\n              const tagList = tags.split(\',\').map(tag => tag.trim());\n              if (tagList.some(tag => tag.includes(searchTerm) || levenshteinDistance(tag, searchTerm) <= 2)) return true;\n              \n              return false;\n            });\n          }\n          \n          // Store the filtered results for pagination\n          featuredTotalResults = filteredImages;\n          featuredMaxPages = Math.ceil(featuredTotalResults.length / featuredResultsPerPage);\n          \n          // Calculate start and end indices for current page\n          const startIndex = featuredCurrentPage * featuredResultsPerPage;\n          const endIndex = startIndex + featuredResultsPerPage;\n          \n          // Get items for the current page\n          const imagesToDisplay = featuredTotalResults.slice(startIndex, endIndex);\n          \n          if (imagesToDisplay.length === 0) {\n            featuredResults.innerHTML = \'<div class="alert alert-info">No images match your search. Try a different keyword.</div>\';\n            return;\n          }\n          \n          // Create a grid container for better layout\n          const gridContainer = document.createElement(\'div\');\n          gridContainer.className = \'featured-grid\';\n          gridContainer.style.display = \'grid\';\n          gridContainer.style.gridTemplateColumns = \'repeat(3, 1fr)\';\n          gridContainer.style.gap = \'10px\';\n          gridContainer.style.marginBottom = \'15px\';\n          \n          imagesToDisplay.forEach(([id, image]) => {\n            try {\n              const imgContainer = document.createElement(\'div\');\n              imgContainer.className = \'featured-image-container\';\n              \n              const img = document.createElement(\'img\');\n              img.src = image[\'image-url\'];\n              img.alt = `Featured image ${id}`;\n              img.className = \'featured-image\';\n              img.loading = \'lazy\'; // Lazy load images\n              \n              // Store the URL as a data attribute for easier access\n              img.dataset.originalUrl = image[\'image-url\'];\n              \n              // Add error handling for images\n              img.onerror = function() {\n                this.src = \'https://featured.mypoint.cards/assets/water-lily-001.jpg\';\n                this.alt = \'Image not available\';\n              };\n              \n              // Add info tooltip\n              const infoDiv = document.createElement(\'div\');\n              infoDiv.className = \'image-info\';\n              infoDiv.innerHTML = `\n                <div><i class="fa-solid fa-tag"></i> ${image.category || \'N/A\'}</div>\n              `;\n              \n              // Set click event to use image as background\n              img.addEventListener(\'click\', async () => {\n                await applyBackgroundImage(image[\'image-url\'], \'featured\');\n                showAlert(\'Featured image applied as background!\', \'success\');\n              });\n              \n              imgContainer.appendChild(img);\n              imgContainer.appendChild(infoDiv);\n              gridContainer.appendChild(imgContainer);\n            } catch (err) {\n              console.warn(\'Error displaying featured image:\', err);\n            }\n          });\n          \n          // Fill empty spots in the grid to maintain 3x3 layout\n          const emptySpots = featuredResultsPerPage - imagesToDisplay.length;\n          for (let i = 0; i < emptySpots; i++) {\n            const emptyDiv = document.createElement(\'div\');\n            emptyDiv.style.width = \'120px\';\n            emptyDiv.style.height = \'120px\';\n            gridContainer.appendChild(emptyDiv);\n          }\n          \n          featuredResults.appendChild(gridContainer);\n          \n          // Add pagination controls if needed\n          if (addPagination && featuredTotalResults.length > featuredResultsPerPage) {\n            const paginationContainer = document.createElement(\'div\');\n            paginationContainer.className = \'d-flex justify-content-center mt-3\';\n            \n            const pagination = document.createElement(\'nav\');\n            pagination.setAttribute(\'aria-label\', \'Featured results pages\');\n            \n            const pageList = document.createElement(\'ul\');\n            pageList.className = \'pagination\';\n            \n            // Previous button\n            const prevItem = document.createElement(\'li\');\n            prevItem.className = `page-item ${featuredCurrentPage === 0 ? \'disabled\' : \'\'}`;\n            \n            const prevLink = document.createElement(\'a\');\n            prevLink.className = \'page-link\';\n            prevLink.href = \'#\';\n            prevLink.innerHTML = \'&laquo; Previous\';\n            prevLink.id = \'featuredPrevPage\';\n            \n            prevItem.appendChild(prevLink);\n            pageList.appendChild(prevItem);\n            \n            // Current page info\n            const pageInfoItem = document.createElement(\'li\');\n            pageInfoItem.className = \'page-item\';\n            \n            const pageInfoSpan = document.createElement(\'span\');\n            pageInfoSpan.className = \'page-link\';\n            const totalPages = Math.min(featuredMaxPages, Math.ceil(featuredTotalResults.length / featuredResultsPerPage) || 1);\n            pageInfoSpan.textContent = `Page ${featuredCurrentPage + 1} of ${totalPages}`;\n            \n            pageInfoItem.appendChild(pageInfoSpan);\n            pageList.appendChild(pageInfoItem);\n            \n            // Next button\n            const nextItem = document.createElement(\'li\');\n            nextItem.className = `page-item ${\n              featuredCurrentPage >= totalPages - 1 || imagesToDisplay.length < featuredResultsPerPage ? \'disabled\' : \'\'\n            }`;\n            \n            const nextLink = document.createElement(\'a\');\n            nextLink.className = \'page-link\';\n            nextLink.href = \'#\';\n            nextLink.innerHTML = \'Next &raquo;\';\n            nextLink.id = \'featuredNextPage\';\n            \n            nextItem.appendChild(nextLink);\n            pageList.appendChild(nextItem);\n            \n            pagination.appendChild(pageList);\n            paginationContainer.appendChild(pagination);\n            featuredResults.appendChild(paginationContainer);\n            \n            // Add event listeners for pagination buttons\n            const prevButton = document.getElementById(\'featuredPrevPage\');\n            const nextButton = document.getElementById(\'featuredNextPage\');\n            \n            if (prevButton) {\n              prevButton.addEventListener(\'click\', (e) => {\n                e.preventDefault();\n                if (featuredCurrentPage > 0) {\n                  featuredCurrentPage--;\n                  displayFeaturedPage(featuredCurrentPage);\n                }\n              });\n            }\n            \n            if (nextButton) {\n              nextButton.addEventListener(\'click\', (e) => {\n                e.preventDefault();\n                if (featuredCurrentPage < totalPages - 1 && imagesToDisplay.length === featuredResultsPerPage) {\n                  featuredCurrentPage++;\n                  displayFeaturedPage(featuredCurrentPage);\n                }\n              });\n            }\n          }\n        }\n\n        function displayFeaturedPage(page = 0) {\n            featuredCurrentPage = page;\n            displayFeaturedImages(featuredImages, featuredCurrentQuery);\n        }\n\n\n        // Function to search featured images\n        function searchFeaturedImages() {\n            const query = featuredSearch.value.trim();\n            featuredCurrentQuery = query;\n            featuredCurrentPage = 0; // Reset to first page when searching\n            \n            // Always use the available featuredImages or fallback if not available\n            if (!featuredImages) {\n                featuredImages = FALLBACK_FEATURED_DATA.featured;\n            }\n            \n            // Display all or filtered images\n            displayFeaturedImages(featuredImages, query);\n        }\n        \n\n        function loadFeaturedImages() {\n            // Display loading state first\n            featuredResults.innerHTML = \'<div class="text-center w-100"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Loading featured images...</p></div>\';\n            \n            // Reset page to 0 when loading featured images\n            featuredCurrentPage = 0;\n            \n            // If CORS is known to be blocked, use fallback data immediately\n            if (corsBlocked) {\n                setTimeout(() => {\n                    displayFeaturedImages(FALLBACK_FEATURED_DATA.featured);\n                    featuredResults.insertAdjacentHTML(\'beforeend\', \n                        \'<div class="alert alert-info mt-3">Using placeholder images. The featured image service requires server-side access.</div>\'\n                    );\n                }, 300); // Small delay for better user experience\n                return;\n            }\n            \n            // Otherwise, make a real attempt\n            fetch(FEATURED_API_ENDPOINT, {\n                headers: { \'Accept\': \'application/json\' },\n                signal: AbortSignal.timeout(3000),\n                cache: \'no-store\'\n            })\n            .then(response => {\n                if (!response.ok) {\n                    throw new Error(`Server responded with ${response.status}`);\n                }\n                return response.json();\n            })\n            .then(data => {\n                if (data && data.featured) {\n                    featuredImages = data.featured;\n                    displayFeaturedImages(featuredImages);\n                } else {\n                    throw new Error(\'Invalid data format\');\n                }\n            })\n            .catch(error => {\n                // Mark as CORS blocked for future attempts\n                corsBlocked = true;\n                \n                // Use fallback data\n                featuredImages = FALLBACK_FEATURED_DATA.featured;\n                displayFeaturedImages(featuredImages);\n                \n                // Show a message about using fallback\n                featuredResults.insertAdjacentHTML(\'beforeend\', \n                    \'<div class="alert alert-info mt-3">Using placeholder images. The featured image service is currently unavailable.</div>\'\n                );\n            });\n        }\n        \n        // Function to make a single API request test\n        function trySingleApiRequest() {\n            // Make a single, quiet attempt to check if the API is available\n            // We use a silent fetch that won\'t generate console errors\n            const controller = new AbortController();\n            const signal = controller.signal;\n            \n            // Set a timeout to avoid waiting too long\n            const timeoutId = setTimeout(() => controller.abort(), 2000);\n            \n            // Attempt a HEAD request to check if the endpoint exists without triggering CORS errors in console\n            fetch(FEATURED_API_ENDPOINT, {\n                method: \'HEAD\',\n                mode: \'no-cors\',\n                signal: signal,\n                credentials: \'omit\'\n            }).then(() => {\n                // We got a response, but because of no-cors we can\'t access it\n                // Let\'s try a single attempt with regular fetch to see if CORS is actually enabled\n                return fetch(FEATURED_API_ENDPOINT, {\n                    credentials: \'omit\',\n                    cache: \'no-store\',\n                    signal: AbortSignal.timeout(2000)\n                });\n            }).then(response => {\n                if (response.ok) {\n                    return response.json();\n                }\n                // If we get here with a response that\'s not OK, still use fallback\n                throw new Error(\'API returned non-OK status\');\n            }).then(data => {\n                // If we get here, CORS is actually working!\n                corsBlocked = false;\n                if (data && data.featured) {\n                    featuredImages = data.featured;\n                }\n            }).catch(() => {\n                // Silently fail and keep using fallback data\n                corsBlocked = true;\n            }).finally(() => {\n                clearTimeout(timeoutId);\n            });\n        }\n        \n        // Function to initialize featured images\n        function initFeaturedImages() {\n            // Immediately use fallback data - no need to try external API first\n            featuredImages = FALLBACK_FEATURED_DATA.featured;\n            \n            // Make a single attempt to load from API\n            setTimeout(function() {\n                trySingleApiRequest();\n            }, 500);\n            \n            // Always enable the Featured tab because we have fallback data\n            featuredTab.classList.remove(\'disabled\');\n        }\n        \n        // Initialize Featured Images\n        initFeaturedImages();\n\n        // Load saved preferences\n        loadSavedPreferences();\n        \n        // Event Listeners\n        // Gradient boxes\ngradientBoxes.forEach(box => {\n    box.addEventListener(\'click\', function() {\n        // Remove active class from all boxes\n        gradientBoxes.forEach(b => b.classList.remove(\'active\'));\n        colorBoxes.forEach(b => b.classList.remove(\'active\'));\n        \n        // Add active class to the clicked box\n        this.classList.add(\'active\');\n        \n        // Update background gradient\n        const gradient = this.getAttribute(\'data-gradient\');\n        cardPreview.style.background = gradient;\n        \n        // If there\'s a background image, remove it\n        if (hasBackgroundImage) {\n            cardPreview.style.backgroundImage = gradient;\n            hasBackgroundImage = false;\n        }\n    });\n});\n\n// Event listeners for text alignment\nalignLeft.addEventListener(\'change\', function() {\n  if(this.checked) {\n    previewText.style.textAlign = \'left\';\n    savePreferences();\n  }\n});\n\nalignCenter.addEventListener(\'change\', function() {\n  if(this.checked) {\n    previewText.style.textAlign = \'center\';\n    savePreferences();\n  }\n});\n\nalignRight.addEventListener(\'change\', function() {\n  if(this.checked) {\n    previewText.style.textAlign = \'right\';\n    savePreferences();\n  }\n});\n\nlineHeight.addEventListener(\'input\', function() {\n    const height = this.value;\n    lineHeightValue.textContent = height;\n    previewText.style.lineHeight = height;\n    savePreferences();\n});\n\n\n// Text Customization Event Listeners\nfontFamily.addEventListener(\'change\', function() {\n    previewText.style.fontFamily = this.value;\n    savePreferences();\n});\n\nfontSize.addEventListener(\'input\', function() {\n    const size = this.value;\n    fontSizeValue.textContent = size;\n    previewText.style.fontSize = `${size}px`;\n    savePreferences();\n});\n\nfontColor.addEventListener(\'input\', function() {\n    const color = this.value;\n    fontColorHex.textContent = color;\n    previewText.style.color = color;\n    savePreferences();\n});\n\ntextShadow.addEventListener(\'change\', function() {\n    previewText.style.textShadow = this.checked ? \'0 2px 4px rgba(0, 0, 0, 0.5)\' : \'none\';\n    savePreferences();\n});\n\npoweredBy.addEventListener(\'change\', function() {\n    poweredByText.style.display = this.checked ? \'block\' : \'none\';\n    savePreferences();\n});\n\n\n// Add mouse events for positioning background image\ncardPreview.addEventListener(\'mousedown\', function(e) {\n    if (hasBackgroundImage) {\n        isDragging = true;\n        dragStartX = e.clientX;\n        dragStartY = e.clientY;\n        \n        // Get current background position\n        const bgPosition = cardPreview.style.backgroundPosition;\n        if (bgPosition) {\n            const positions = bgPosition.split(\' \');\n            if (positions.length === 2) {\n                initialBgPosX = parseInt(positions[0]);\n                initialBgPosY = parseInt(positions[1]);\n            }\n        }\n        \n        // Change cursor to indicate draggable\n        cardPreview.style.cursor = \'move\';\n        \n        // Prevent default behavior to avoid text selection\n        e.preventDefault();\n    }\n});\n\n// Touch support for mobile devices\ncardPreview.addEventListener(\'touchstart\', function(e) {\n    if (hasBackgroundImage && e.touches.length === 1) {\n        isDragging = true;\n        dragStartX = e.touches[0].clientX;\n        dragStartY = e.touches[0].clientY;\n        \n        // Get current background position\n        const bgPosition = cardPreview.style.backgroundPosition;\n        if (bgPosition) {\n            const positions = bgPosition.split(\' \');\n            if (positions.length === 2) {\n                initialBgPosX = parseInt(positions[0]);\n                initialBgPosY = parseInt(positions[1]);\n            }\n        }\n        \n        // Prevent default to avoid scrolling\n        e.preventDefault();\n    }\n});\n\ncardPreview.addEventListener(\'touchmove\', function(e) {\n    if (isDragging && hasBackgroundImage && e.touches.length === 1) {\n        // Calculate how far the touch has moved\n        const deltaX = e.touches[0].clientX - dragStartX;\n        const deltaY = e.touches[0].clientY - dragStartY;\n        \n        // Convert pixel difference to percentage (relative to card size)\n        const moveX = deltaX / cardPreview.offsetWidth * 100;\n        const moveY = deltaY / cardPreview.offsetHeight * 100;\n        \n        // Move in the opposite direction of the drag\n        currentBgPosX = initialBgPosX - moveX;\n        currentBgPosY = initialBgPosY - moveY;\n        \n        // Apply the position\n        cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;\n        \n        // Prevent default to avoid scrolling\n        e.preventDefault();\n    }\n});\n\ncardPreview.addEventListener(\'touchend\', function() {\n    if (isDragging) {\n        isDragging = false;\n        \n        // Save the final position\n        initialBgPosX = currentBgPosX;\n        initialBgPosY = currentBgPosY;\n    }\n});\n\ncardPreview.addEventListener(\'touchcancel\', function() {\n    if (isDragging) {\n        isDragging = false;\n    }\n});\n\n// Add a visual indicator when dragging is active\n// This helps users understand they\'re positioning the image\ndocument.addEventListener(\'mousemove\', function(e) {\n    if (isDragging && hasBackgroundImage) {\n        // Add a class to the card preview to show it\'s being positioned\n        cardPreview.classList.add(\'dragging\');\n        \n        // Calculate how far the mouse has moved\n        const deltaX = e.clientX - dragStartX;\n        const deltaY = e.clientY - dragStartY;\n        \n        // Convert pixel difference to percentage (relative to card size)\n        const moveX = deltaX / cardPreview.offsetWidth * 100;\n        const moveY = deltaY / cardPreview.offsetHeight * 100;\n        \n        // Move in the opposite direction of the drag (to make content follow mouse)\n        currentBgPosX = initialBgPosX - moveX;\n        currentBgPosY = initialBgPosY - moveY;\n        \n        // Apply the position\n        cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;\n    }\n});\n\ndocument.addEventListener(\'mouseup\', function() {\n    if (isDragging) {\n        isDragging = false;\n        cardPreview.classList.remove(\'dragging\');\n        \n        // Save the final position\n        initialBgPosX = currentBgPosX;\n        initialBgPosY = currentBgPosY;\n    }\n});\n\n// Help button\nhelpBtn.addEventListener(\'click\', function() {\n\n    window.open(\'https://mypoint.cards/help\', \'_blank\');\n\n});\n\n// Reset button\nresetBtn.addEventListener(\'click\', function() {\n    // Reset text\n    cardText.value = \'\';\n    previewText.innerText = "What\'s on your mind?";\n    \n    // Reset background to default color\n    cardPreview.style.backgroundImage = \'none\';\n    cardPreview.style.background = \'\';\n    cardPreview.style.backgroundColor = \'#ED213A\'; // Default color\n    \n    // Reset color selection\n    colorBoxes.forEach(box => box.classList.remove(\'active\'));\n    gradientBoxes.forEach(box => box.classList.remove(\'active\'));\n    colorBoxes[0].classList.add(\'active\'); // Select the first color box (default red)\n    \n    // Reset custom color picker\n    customColor.value = \'#ED213A\';\n    \n    // Reset gradient colors\n    gradientColor1.value = \'#ff0000\';\n    gradientColor2.value = \'#ffcc00\';\n    gradientDirection.value = \'to right\';\n    \n    // Reset uploaded image if any\n    imageUpload.value = \'\';\n    uploadPreview.classList.add(\'d-none\');\n    \n    // Reset giphy search\n    giphySearch.value = \'\';\n    giphyResults.innerHTML = \'<div class="text-center w-100 text-muted"><p>Enter a search term and click Search to find GIFs</p></div>\';\n    \n    // Reset featured search\n    featuredSearch.value = \'\';\n    \n    // Reset background state variables\n    hasBackgroundImage = false;\n    backgroundImageSource = null;\n\n    fontFamily.value = \'Roboto, sans-serif\';\n    previewText.style.fontFamily = \'Roboto, sans-serif\';\n\n    fontSize.value = \'32\';\n    fontSizeValue.textContent = \'32\';\n    previewText.style.fontSize = \'32px\';\n\n    fontColor.value = \'#ffffff\';\n    fontColorHex.textContent = \'#ffffff\';\n    previewText.style.color = \'#ffffff\';\n\n    textShadow.checked = true;\n    previewText.style.textShadow = \'0 2px 4px rgba(0, 0, 0, 0.5)\';\n\n    // In the resetBtn event listener, add:\n    initialBgPosX = 50;\n    initialBgPosY = 50;\n    currentBgPosX = 50;\n    currentBgPosY = 50;\n    cardPreview.style.backgroundPosition = \'50% 50%\';\n\n\n    lineHeight.value = \'1.2\';\n    lineHeightValue.textContent = \'1.2\';\n    previewText.style.lineHeight = \'1.2\';\n\n    let textIsDragging = false;\n    let textDragStartX = 0;\n    let textDragStartY = 0;\n\n    textPosX = 50;\n    textPosY = 50;\n    previewText.style.left = \'50%\';\n    previewText.style.top = \'50%\';\n    \n    // Save the preferences (except for the reset text-specific items)\n    savePreferences();\n\n    hideBackgroundControls();\n\n    cardPreview.style.backgroundImage = \'none\';\n\n    // Provide visual feedback\n    showAlert(\'Card reset to default state!\', \'info\');\n});\n\n// Enhanced function to apply background image from Featured, Giphy, or Uploads\n// This version creates a data URL for iOS devices when possible\nfunction applyBackgroundImage(imageUrl, source) {\n  return new Promise((resolve, reject) => {\n    // Create a unique ID for this loading overlay\n    const overlayId = \'bgLoadingOverlay-\' + Date.now();\n    \n    // Set loading state\n    const loadingOverlay = document.createElement(\'div\');\n    loadingOverlay.id = overlayId;\n    loadingOverlay.style.position = \'absolute\';\n    loadingOverlay.style.top = \'0\';\n    loadingOverlay.style.left = \'0\';\n    loadingOverlay.style.width = \'100%\';\n    loadingOverlay.style.height = \'100%\';\n    loadingOverlay.style.background = \'rgba(0,0,0,0.5)\';\n    loadingOverlay.style.display = \'flex\';\n    loadingOverlay.style.justifyContent = \'center\';\n    loadingOverlay.style.alignItems = \'center\';\n    loadingOverlay.style.zIndex = \'10\';\n    loadingOverlay.style.borderRadius = \'12px\';\n    loadingOverlay.innerHTML = \'<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading...</span></div>\';\n    \n    cardPreview.style.position = \'relative\';\n    cardPreview.appendChild(loadingOverlay);\n    \n    // Set a timeout to prevent infinite loading\n    const timeoutId = setTimeout(() => {\n      // If this overlay still exists, remove it\n      if (document.getElementById(overlayId)) {\n        cardPreview.removeChild(loadingOverlay);\n      }\n      \n      // Show error message\n      showAlert(\'Image loading timed out. Please try a different image.\', \'warning\');\n      reject(new Error(\'Image loading timed out\'));\n    }, 8000); // 8-second timeout\n    \n    // Pre-load the image to check if it\'s valid\n    const img = new Image();\n    img.crossOrigin = \'anonymous\';\n    \n    img.onload = function() {\n      // Clear the timeout since image loaded successfully\n      clearTimeout(timeoutId);\n      \n      // Apply the image as background\n      cardPreview.style.backgroundImage = `url(${imageUrl})`;\n      cardPreview.style.backgroundSize = \'cover\';\n      cardPreview.style.backgroundPosition = \'center\';\n      \n      // Update state\n      hasBackgroundImage = true;\n      backgroundImageSource = source;\n      \n      // Reset any color box selections\n      colorBoxes.forEach(box => box.classList.remove(\'active\'));\n      gradientBoxes.forEach(box => box.classList.remove(\'active\'));\n      \n      // Initialize position variables for dragging\n      cardPreview.style.backgroundPosition = \'50% 50%\';\n      initialBgPosX = 50;\n      initialBgPosY = 50;\n      currentBgPosX = 50;\n      currentBgPosY = 50;\n      \n      // Apply the darkness overlay\n      applyBackgroundDarkness();\n      \n      // Show background controls\n      showBackgroundControls();\n      \n      // Update cursor style\n      updateCursorStyle();\n      \n      // Remove loading overlay\n      if (document.getElementById(overlayId)) {\n        cardPreview.removeChild(loadingOverlay);\n      }\n      \n      resolve(true);\n    };\n    \n    img.onerror = function() {\n      // Clear the timeout\n      clearTimeout(timeoutId);\n      \n      // Remove loading overlay\n      if (document.getElementById(overlayId)) {\n        cardPreview.removeChild(loadingOverlay);\n      }\n      \n      // Show error message\n      showAlert(\'Failed to load image. Please try a different one.\', \'warning\');\n      reject(new Error(\'Image failed to load\'));\n    };\n    \n    // Start loading the image\n    img.src = imageUrl;\n  });\n}\n\nfunction setupFeaturedImageHandlers() {\n  // Find all featured images\n  const featuredImages = document.querySelectorAll(\'.featured-image\');\n  \n  featuredImages.forEach(img => {\n    // Remove any existing click handlers\n    const newImg = img.cloneNode(true);\n    img.parentNode.replaceChild(newImg, img);\n    \n    // Add the new click handler\n    newImg.addEventListener(\'click\', () => {\n      const imageUrl = newImg.dataset.originalUrl || newImg.src;\n      \n      // Use the Promise-based applyBackgroundImage\n      applyBackgroundImage(imageUrl, \'featured\')\n        .then(() => {\n          showAlert(\'Featured image applied as background!\', \'success\');\n        })\n        .catch(error => {\n          console.error(\'Error applying featured image:\', error);\n          // The error alert is already shown in the applyBackgroundImage function\n        });\n    });\n  });\n}\n\n// Enhanced Giphy image click handler\nfunction setupGiphyImageHandlers() {\n  // Find all giphy images\n  const giphyImages = document.querySelectorAll(\'.giphy-image\');\n  \n  giphyImages.forEach(img => {\n    // Remove any existing click handlers\n    const newImg = img.cloneNode(true);\n    img.parentNode.replaceChild(newImg, img);\n    \n    // Add the new click handler\n    newImg.addEventListener(\'click\', async () => {\n      // Get the original URL (should be stored in a data attribute)\n      const originalUrl = newImg.dataset.originalUrl || newImg.src;\n      await applyBackgroundImage(originalUrl, \'giphy\');\n      showAlert(\'GIF applied as background!\', \'success\');\n    });\n  });\n}\n\nfunction cleanupStuckOverlays() {\n  // Find all loading overlays\n  const overlays = cardPreview.querySelectorAll(\'div[id^="bgLoadingOverlay-"]\');\n  \n  // Remove them\n  overlays.forEach(overlay => {\n    cardPreview.removeChild(overlay);\n  });\n  \n  // Also check for any generic overlays without ID\n  const genericOverlays = cardPreview.querySelectorAll(\'div[style*="background: rgba(0,0,0,0.5)"]\');\n  genericOverlays.forEach(overlay => {\n    cardPreview.removeChild(overlay);\n  });\n  \n  return \'Cleaned up \' + (overlays.length + genericOverlays.length) + \' stuck overlays\';\n}\n\n\n// Listen for scale changes\nbgContain.addEventListener(\'change\', function() {\n    if(this.checked && hasBackgroundImage) {\n        cardPreview.style.backgroundSize = \'contain\';\n        cardPreview.style.backgroundRepeat = \'no-repeat\'; // Ensure no-repeat is set\n    }\n});\n\nbgCover.addEventListener(\'change\', function() {\n    if(this.checked && hasBackgroundImage) {\n        cardPreview.style.backgroundSize = \'cover\';\n        cardPreview.style.backgroundRepeat = \'no-repeat\'; // Ensure no-repeat is set\n    }\n});\n\nbgActual.addEventListener(\'change\', function() {\n    if(this.checked && hasBackgroundImage) {\n        cardPreview.style.backgroundSize = \'auto\';\n        cardPreview.style.backgroundRepeat = \'no-repeat\'; // Ensure no-repeat is set\n    }\n});\n\n// Background opacity control\nbgOpacity.addEventListener(\'input\', function() {\n    const opacity = parseInt(this.value);\n    bgOpacityValue.textContent = opacity;\n    \n    // Apply the darkness using our consistent function\n    applyBackgroundDarkness();\n});\n\n\n// Custom gradient button\napplyCustomGradient.addEventListener(\'click\', function() {\n    const color1 = gradientColor1.value;\n    const color2 = gradientColor2.value;\n    const direction = gradientDirection.value;\n    \n    // Create gradient\n    const gradient = `linear-gradient(${direction}, ${color1}, ${color2})`;\n    \n    // Apply gradient\n    cardPreview.style.background = gradient;\n    \n    // Remove active class from all boxes\n    gradientBoxes.forEach(b => b.classList.remove(\'active\'));\n    colorBoxes.forEach(b => b.classList.remove(\'active\'));\n    \n    // If there\'s a background image, remove it\n    if (hasBackgroundImage) {\n        hasBackgroundImage = false;\n    }\n    \n    // Visual feedback\n    showAlert(\'Custom gradient applied!\', \'success\');\n});\n\n        \n        // Text input\n        cardText.addEventListener(\'input\', function() {\n            // Using textContent would lose the line breaks\n            // Using innerHTML would be a security risk\n            // Using innerText properly preserves the line breaks\n            previewText.innerText = this.value || "What\'s on your mind?";\n        });\n        \n        // Color boxes\n        colorBoxes.forEach(box => {\n            box.addEventListener(\'click\', function() {\n                // Remove active class from all boxes\n                colorBoxes.forEach(b => b.classList.remove(\'active\'));\n                if (gradientBoxes) {\n                    gradientBoxes.forEach(b => b.classList.remove(\'active\'));\n                }\n                \n                // Add active class to the clicked box\n                this.classList.add(\'active\');\n                \n                // Clear any gradient backgrounds first\n                cardPreview.style.background = \'\';\n                \n                // Update background color\n                const color = this.getAttribute(\'data-color\');\n                cardPreview.style.backgroundColor = color;\n                customColor.value = color;\n                \n                // If there\'s a background image, remove it\n                if (hasBackgroundImage) {\n                    cardPreview.style.backgroundImage = \'none\';\n                    hasBackgroundImage = false;\n                }\n            });\n        });\n        \n        // Custom color picker\n        customColor.addEventListener(\'input\', function() {\n            // Clear any gradient backgrounds first\n            cardPreview.style.background = \'\';\n            \n            // Set the solid background color\n            cardPreview.style.backgroundColor = this.value;\n            \n            // Remove active class from all color boxes and gradient boxes\n            colorBoxes.forEach(box => box.classList.remove(\'active\'));\n            if (gradientBoxes) {\n                gradientBoxes.forEach(box => box.classList.remove(\'active\'));\n            }\n            \n            // If there\'s a background image, remove it\n            if (hasBackgroundImage) {\n                cardPreview.style.backgroundImage = \'none\';\n                hasBackgroundImage = false;\n                backgroundImageSource = null;\n            }\n        });\n        \n        // Emoji clicks\n        emojis.forEach(emoji => {\n            emoji.addEventListener(\'click\', function() {\n                // Add emoji at cursor position or at the end\n                const cursorPos = cardText.selectionStart;\n                const textBefore = cardText.value.substring(0, cursorPos);\n                const textAfter = cardText.value.substring(cursorPos);\n                cardText.value = textBefore + this.textContent + textAfter;\n                \n                // Update preview\n                previewText.innerText = cardText.value;\n                \n                // Return focus to textarea and place cursor after inserted emoji\n                cardText.focus();\n                cardText.selectionStart = cursorPos + this.textContent.length;\n                cardText.selectionEnd = cursorPos + this.textContent.length;\n            });\n        });\n        \n        // Enhanced version of the image upload handler with improved iOS support\n        imageUpload.addEventListener(\'change\', async function(e) {\n          const file = e.target.files[0];\n          if (file) {\n            // Show a loading indicator\n            const loadingOverlay = document.createElement(\'div\');\n            loadingOverlay.id = \'uploadLoadingOverlay\';\n            loadingOverlay.style.position = \'absolute\';\n            loadingOverlay.style.top = \'0\';\n            loadingOverlay.style.left = \'0\';\n            loadingOverlay.style.width = \'100%\';\n            loadingOverlay.style.height = \'100%\';\n            loadingOverlay.style.background = \'rgba(0,0,0,0.5)\';\n            loadingOverlay.style.display = \'flex\';\n            loadingOverlay.style.justifyContent = \'center\';\n            loadingOverlay.style.alignItems = \'center\';\n            loadingOverlay.style.zIndex = \'10\';\n            loadingOverlay.style.borderRadius = \'12px\';\n            loadingOverlay.innerHTML = \'<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading image...</span></div>\';\n            \n            cardPreview.style.position = \'relative\';\n            cardPreview.appendChild(loadingOverlay);\n            \n            try {\n              // Check if this is iOS Safari\n              const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n              const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n              const isIOSSafari = isIOS && isSafari;\n              \n              // Create a data URL from the file\n              const reader = new FileReader();\n              \n              // Use a promise to wait for the file to be read\n              const dataUrl = await new Promise((resolve, reject) => {\n                reader.onload = function(event) {\n                  resolve(event.target.result);\n                };\n                reader.onerror = function(error) {\n                  reject(error);\n                };\n                reader.readAsDataURL(file);\n              });\n              \n              // Show the thumbnail preview\n              uploadedImage.src = dataUrl;\n              uploadPreview.classList.remove(\'d-none\');\n              \n              // Set as background image\n              cardPreview.style.backgroundImage = `url(${dataUrl})`;\n              cardPreview.style.backgroundSize = \'contain\';\n              cardPreview.style.backgroundPosition = \'center\';\n              cardPreview.style.backgroundRepeat = \'no-repeat\';\n              \n              // Update the state variables\n              hasBackgroundImage = true;\n              backgroundImageSource = \'upload\';\n              \n              // Reset position to center\n              cardPreview.style.backgroundPosition = \'50% 50%\';\n              initialBgPosX = 50;\n              initialBgPosY = 50;\n              currentBgPosX = 50;\n              currentBgPosY = 50;\n              \n              // Apply the darkness overlay\n              applyBackgroundDarkness();\n              \n              // Update cursor style\n              updateCursorStyle();\n              \n              // Show background controls\n              showBackgroundControls();\n              \n              // Select appropriate scaling option\n              if (isIOSSafari) {\n                // For iOS Safari, \'contain\' mode tends to work better\n                bgContain.checked = true;\n              }\n              \n              showAlert(\'Image uploaded successfully!\', \'success\');\n            } catch (error) {\n              console.error(\'Error handling image upload:\', error);\n              showAlert(\'Error uploading image. Please try again.\', \'warning\');\n            } finally {\n              // Remove loading overlay\n              if (document.getElementById(\'uploadLoadingOverlay\')) {\n                cardPreview.removeChild(loadingOverlay);\n              }\n            }\n          }\n        });\n\n        // Remove uploaded image\n        removeImage.addEventListener(\'click\', function() {\n            // Clear the file input\n            imageUpload.value = \'\';\n            \n            // Hide the preview\n            uploadPreview.classList.add(\'d-none\');\n            \n            // Remove background image\n            cardPreview.style.backgroundImage = \'none\';\n            hasBackgroundImage = false;\n            backgroundImageSource = null;\n            \n            // Reset to the active color\n            const activeColorBox = document.querySelector(\'.color-box.active\');\n            if (activeColorBox) {\n                cardPreview.style.backgroundColor = activeColorBox.getAttribute(\'data-color\');\n            } else {\n                cardPreview.style.backgroundColor = customColor.value;\n            }\n            \n            hideBackgroundControls();\n\n            // Visual feedback\n            showAlert(\'Image removed!\', \'info\');\n        });\n        \n\n        // This function will handle temporary style changes during image generation\n        // to ensure proper transparency\n        function prepareCardForExport() {\n        // Save original styles\n        const originalBorderRadius = cardPreview.style.borderRadius;\n        const originalBoxShadow = cardPreview.style.boxShadow;\n        const originalBorder = cardPreview.style.border;\n\n        // Temporarily remove any rounded corners, border or shadow that might affect transparency\n        cardPreview.style.borderRadius = \'0\';\n        cardPreview.style.boxShadow = \'none\';\n        cardPreview.style.border = \'none\';\n\n        return function restoreStyles() {\n            // Restore original styles\n            cardPreview.style.borderRadius = originalBorderRadius;\n            cardPreview.style.boxShadow = originalBoxShadow;\n            cardPreview.style.border = originalBorder;\n        };\n        }\n\n\n\n        // Giphy Search\n        searchGiphyBtn.addEventListener(\'click\', () => searchGiphy(0)); // Start fresh search\n        giphySearch.addEventListener(\'keypress\', function(e) {\n            if (e.key === \'Enter\') {\n                searchGiphy(0); // Start fresh search\n            }\n        });\n        \n        // Enhanced function to display Giphy results\n        function displayGiphyResults(gifs, addPagination = false) {\n          giphyResults.innerHTML = \'\';\n          \n          if (!gifs || gifs.length === 0) {\n            giphyResults.innerHTML = \'<div class="alert alert-info">No GIFs found. Try another search term.</div>\';\n            return;\n          }\n          \n          // Create a container for the grid\n          const gridContainer = document.createElement(\'div\');\n          gridContainer.className = \'giphy-grid\';\n          gridContainer.style.display = \'grid\';\n          gridContainer.style.gridTemplateColumns = \'repeat(3, 1fr)\'; // Exactly 3 columns\n          gridContainer.style.gap = \'10px\';\n          gridContainer.style.marginBottom = \'15px\';\n          \n          // Display up to 9 GIFs (3x3 grid)\n          const gifsToShow = gifs.slice(0, 9);\n          \n          gifsToShow.forEach(gif => {\n            try {\n              const imgContainer = document.createElement(\'div\');\n              imgContainer.style.display = \'flex\';\n              imgContainer.style.justifyContent = \'center\';\n              imgContainer.style.alignItems = \'center\';\n              \n              const img = document.createElement(\'img\');\n              img.src = gif.images.fixed_height_small.url;\n              img.alt = gif.title || \'Giphy image\';\n              img.className = \'giphy-image\';\n              \n              // Store the original image URL as a data attribute\n              img.dataset.originalUrl = gif.images.original.url;\n              \n              img.style.width = \'120px\';\n              img.style.height = \'120px\';\n              img.style.objectFit = \'cover\';\n              img.style.cursor = \'pointer\';\n              img.style.borderRadius = \'8px\';\n              img.style.transition = \'transform 0.2s, box-shadow 0.2s\';\n              img.style.boxShadow = \'0 2px 4px rgba(0,0,0,0.1)\';\n              \n              img.addEventListener(\'mouseover\', () => {\n                img.style.transform = \'scale(1.05)\';\n                img.style.boxShadow = \'0 4px 8px rgba(0,0,0,0.3)\';\n                img.style.zIndex = \'1\';\n              });\n              \n              img.addEventListener(\'mouseout\', () => {\n                img.style.transform = \'scale(1)\';\n                img.style.boxShadow = \'0 2px 4px rgba(0,0,0,0.1)\';\n                img.style.zIndex = \'auto\';\n              });\n              \n              img.addEventListener(\'click\', async () => {\n                await applyBackgroundImage(gif.images.original.url, \'giphy\');\n                showAlert(\'GIF applied as background!\', \'success\');\n              });\n              \n              imgContainer.appendChild(img);\n              gridContainer.appendChild(imgContainer);\n            } catch (err) {\n              console.warn(\'Error displaying GIF:\', err);\n            }\n          });\n          \n          // Fill any empty spots in the grid with placeholder divs to maintain 3x3 layout\n          const emptySpots = 9 - gifsToShow.length;\n          for (let i = 0; i < emptySpots; i++) {\n            const emptyDiv = document.createElement(\'div\');\n            emptyDiv.style.width = \'120px\';\n            emptyDiv.style.height = \'120px\';\n            gridContainer.appendChild(emptyDiv);\n          }\n          \n          giphyResults.appendChild(gridContainer);\n          \n          // Add pagination controls if needed\n          if (addPagination) {\n            const paginationContainer = document.createElement(\'div\');\n            paginationContainer.className = \'d-flex justify-content-center mt-3\';\n            \n            const pagination = document.createElement(\'nav\');\n            pagination.setAttribute(\'aria-label\', \'Giphy results pages\');\n            \n            const pageList = document.createElement(\'ul\');\n            pageList.className = \'pagination\';\n            \n            // Previous button\n            const prevItem = document.createElement(\'li\');\n            prevItem.className = `page-item ${giphyCurrentPage === 0 ? \'disabled\' : \'\'}`;\n            \n            const prevLink = document.createElement(\'a\');\n            prevLink.className = \'page-link\';\n            prevLink.href = \'#\';\n            prevLink.innerHTML = \'&laquo; Previous\';\n            prevLink.id = \'giphyPrevPage\';\n            \n            prevItem.appendChild(prevLink);\n            pageList.appendChild(prevItem);\n            \n            // Current page info\n            const pageInfoItem = document.createElement(\'li\');\n            pageInfoItem.className = \'page-item\';\n            \n            const pageInfoSpan = document.createElement(\'span\');\n            pageInfoSpan.className = \'page-link\';\n            pageInfoSpan.textContent = `Page ${giphyCurrentPage + 1} of ${Math.min(giphyMaxPages, Math.ceil(giphyTotalResults.length / 9) || 1)}`;\n            \n            pageInfoItem.appendChild(pageInfoSpan);\n            pageList.appendChild(pageInfoItem);\n            \n            // Next button\n            const nextItem = document.createElement(\'li\');\n            nextItem.className = `page-item ${giphyCurrentPage >= giphyMaxPages - 1 || gifsToShow.length < 9 ? \'disabled\' : \'\'}`;\n            \n            const nextLink = document.createElement(\'a\');\n            nextLink.className = \'page-link\';\n            nextLink.href = \'#\';\n            nextLink.innerHTML = \'Next &raquo;\';\n            nextLink.id = \'giphyNextPage\';\n            \n            nextItem.appendChild(nextLink);\n            pageList.appendChild(nextItem);\n            \n            pagination.appendChild(pageList);\n            paginationContainer.appendChild(pagination);\n            giphyResults.appendChild(paginationContainer);\n            \n            // Add event listeners for pagination buttons\n            const prevButton = document.getElementById(\'giphyPrevPage\');\n            const nextButton = document.getElementById(\'giphyNextPage\');\n            \n            if (prevButton) {\n              prevButton.addEventListener(\'click\', (e) => {\n                e.preventDefault();\n                if (giphyCurrentPage > 0) {\n                  giphyCurrentPage--;\n                  searchGiphy(giphyCurrentPage);\n                }\n              });\n            }\n            \n            if (nextButton) {\n              nextButton.addEventListener(\'click\', (e) => {\n                e.preventDefault();\n                if (giphyCurrentPage < giphyMaxPages - 1 && gifsToShow.length === 9) {\n                  giphyCurrentPage++;\n                  searchGiphy(giphyCurrentPage);\n                }\n              });\n            }\n          }\n        }\n\n        function searchGiphy(page = 0) {\n            const query = giphySearch.value.trim();\n            \n            // If it\'s a new search (page 0) or a different query\n            if (page === 0 || query !== giphyCurrentQuery) {\n                giphyCurrentQuery = query;\n                giphyCurrentPage = 0;\n                giphyTotalResults = [];\n            }\n            \n            if (!query) {\n                // Replace alert with inline error message\n                giphyResults.innerHTML = \'<div class="alert alert-warning">Please enter a search term</div>\';\n                return;\n            }\n            \n            // Show loading indicator\n            giphyResults.innerHTML = \'<div class="text-center w-100"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Searching for GIFs...</p></div>\';\n            \n            // Calculate offset for pagination (which results to start from)\n            const offset = page * 9; // Now we want 9 results per page for 3x3 grid\n            \n            // If we already have these results cached, use them\n            if (giphyTotalResults.length > offset) {\n                displayGiphyResults(giphyTotalResults.slice(offset, offset + 9), true);\n                return;\n            }\n            \n            // Fetch more GIFs from Giphy API\n            const limit = 9 * (giphyMaxPages - page);\n            \n            fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}&rating=g`)\n                .then(response => {\n                    if (!response.ok) {\n                        throw new Error(`Network response was not ok: ${response.status}`);\n                    }\n                    return response.json();\n                })\n                .then(data => {\n                    // Cache all results\n                    giphyTotalResults = giphyTotalResults.concat(data.data);\n                    \n                    // But only display the current page (9 results)\n                    displayGiphyResults(data.data.slice(0, 9), true);\n                })\n                .catch(error => {\n                    console.error(\'Error fetching from Giphy:\', error);\n                    giphyResults.innerHTML = \'<div class="alert alert-danger">Error fetching GIFs. Please try again or check your internet connection.</div>\';\n                });\n        }\n                \n        // Featured tab click handler - optimized to avoid CORS errors\n        featuredTab.addEventListener(\'click\', function() {\n            // If we already have featured images, just display them\n            if (featuredImages) {\n                displayFeaturedImages(featuredImages);\n            } else {\n                // Otherwise, try to load them (but only once since we know there are CORS issues)\n                loadFeaturedImages();\n            }\n\n            setTimeout(updateFeaturedImageHandlers, 500);\n            setTimeout(setupFeaturedImageHandlers, 500);\n        });\n        \n        searchFeaturedBtn.addEventListener(\'click\', searchFeaturedImages);\n        featuredSearch.addEventListener(\'keypress\', function(e) {\n            if (e.key === \'Enter\') {\n                searchFeaturedImages();\n            }\n\n\n        });\n        \n        function initFeaturedImages() {\n            // Immediately use fallback data - no need to try external API first\n            featuredImages = FALLBACK_FEATURED_DATA.featured;\n            \n            // Make a single attempt to load from API\n            setTimeout(function() {\n                trySingleApiRequest();\n            }, 500);\n            \n            // Always enable the Featured tab because we have fallback data\n            featuredTab.classList.remove(\'disabled\');\n        }\n        \n        function trySingleApiRequest() {\n            // Make a single, quiet attempt to check if the API is available\n            // We use a silent fetch that won\'t generate console errors\n            const controller = new AbortController();\n            const signal = controller.signal;\n            \n            // Set a timeout to avoid waiting too long\n            const timeoutId = setTimeout(() => controller.abort(), 2000);\n            \n            // Attempt a HEAD request to check if the endpoint exists without triggering CORS errors in console\n            fetch(FEATURED_API_ENDPOINT, {\n                method: \'HEAD\',\n                mode: \'no-cors\',\n                signal: signal,\n                credentials: \'omit\'\n            }).then(() => {\n                // We got a response, but because of no-cors we can\'t access it\n                // Let\'s try a single attempt with regular fetch to see if CORS is actually enabled\n                return fetch(FEATURED_API_ENDPOINT, {\n                    credentials: \'omit\',\n                    cache: \'no-store\',\n                    signal: AbortSignal.timeout(2000)\n                });\n            }).then(response => {\n                if (response.ok) {\n                    return response.json();\n                }\n                // If we get here with a response that\'s not OK, still use fallback\n                throw new Error(\'API returned non-OK status\');\n            }).then(data => {\n                // If we get here, CORS is actually working!\n                corsBlocked = false;\n                if (data && data.featured) {\n                    featuredImages = data.featured;\n                }\n            }).catch(() => {\n                // Silently fail and keep using fallback data\n                corsBlocked = true;\n            }).finally(() => {\n                clearTimeout(timeoutId);\n            });\n        }\n\n\n\n    \n    // Check for saved theme preference or use system preference\n    function initTheme() {\n        const savedTheme = localStorage.getItem(\'mypointcardsTheme\');\n        \n        if (savedTheme) {\n            // Apply saved preference\n            htmlElement.setAttribute(\'data-bs-theme\', savedTheme);\n            themeSwitch.checked = savedTheme === \'dark\';\n        } else {\n            // Check system preference\n            const prefersDarkMode = window.matchMedia(\'(prefers-color-scheme: dark)\').matches;\n            if (prefersDarkMode) {\n                htmlElement.setAttribute(\'data-bs-theme\', \'dark\');\n                themeSwitch.checked = true;\n            }\n        }\n    }\n    \n    // Toggle theme when switch is clicked\n    themeSwitch.addEventListener(\'change\', function() {\n        const theme = this.checked ? \'dark\' : \'light\';\n        htmlElement.setAttribute(\'data-bs-theme\', theme);\n        localStorage.setItem(\'mypointcardsTheme\', theme);\n    });\n    \n    \n    // Add the cleanup function to the window to make it accessible from the console\n    window.cleanupStuckOverlays = cleanupStuckOverlays;\n \n    </script>\n\n    <style>\n    #exit-button {\n        position: fixed;\n        bottom: 20px;\n        right: 20px;\n        background-color: #f44336;\n        color: white;\n        padding: 10px 20px;\n        border-radius: 5px;\n        border: none;\n        cursor: pointer;\n        font-size: 16px;\n        z-index: 9999;\n    }\n    #exit-button:hover {\n        background-color: #d32f2f;\n    }\n    .error-overlay {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.8);\n        color: white;\n        display: flex;\n        flex-direction: column;\n        justify-content: center;\n        align-items: center;\n        font-family: Arial, sans-serif;\n        z-index: 10000;\n        padding: 20px;\n        text-align: center;\n    }\n    .error-content {\n        background-color: #d32f2f;\n        padding: 20px;\n        border-radius: 8px;\n        max-width: 80%;\n        max-height: 80%;\n        overflow-y: auto;\n    }\n    .error-title {\n        font-size: 24px;\n        margin-bottom: 20px;\n    }\n    .error-message {\n        font-size: 16px;\n        margin-bottom: 20px;\n        white-space: pre-wrap;\n        text-align: left;\n    }\n    .error-close {\n        background-color: white;\n        color: black;\n        border: none;\n        padding: 10px 20px;\n        border-radius: 5px;\n        cursor: pointer;\n        font-size: 16px;\n        margin-top: 20px;\n    }\n    </style>\n    \n    <button id="exit-button" onclick="exitServer()">Exit Server</button>\n    \n    <script>\n    // Error handling function\n    function showError(title, message) {\n        const overlay = document.createElement(\'div\');\n        overlay.className = \'error-overlay\';\n        \n        overlay.innerHTML = `\n            <div class="error-content">\n                <div class="error-title">${title}</div>\n                <div class="error-message">${message}</div>\n                <button class="error-close" onclick="this.parentNode.parentNode.remove()">Close</button>\n            </div>\n        `;\n        \n        document.body.appendChild(overlay);\n    }\n    \n    function exitServer() {\n        if (confirm(\'Are you sure you want to exit the server?\')) {\n            fetch(\'/exit\', { method: \'POST\' })\n                .then(() => {\n                    document.body.innerHTML = `\n                        <div style="\n                            position: fixed;\n                            top: 0;\n                            left: 0;\n                            width: 100%;\n                            height: 100%;\n                            display: flex;\n                            justify-content: center;\n                            align-items: center;\n                            font-family: Arial, sans-serif;\n                            text-align: center;\n                        ">\n                            <h1>Server shutdown. You can close this window.</h1>\n                        </div>\n                    `;\n                })\n                .catch(err => {\n                    console.error(\'Error shutting down server:\', err);\n                    alert(\'Error shutting down server. Please try again.\');\n                });\n        }\n    }\n    \n    // Check for startup errors\n    window.addEventListener(\'load\', function() {\n        fetch(\'/check-status\')\n            .then(response => response.json())\n            .then(data => {\n                if (data.error) {\n                    showError(\'Application Error\', data.error);\n                }\n            })\n            .catch(err => {\n                console.error(\'Error checking application status:\', err);\n            });\n    });\n    </script>\n    '
server = None
startup_error = None

# Get application path
def get_app_path():
    if getattr(sys, 'frozen', False):
        # Running as compiled bundle
        return os.path.dirname(os.path.dirname(os.path.abspath(sys.executable)))
    else:
        # Running as script
        return os.path.dirname(os.path.abspath(__file__))

# Check if port is already in use
def check_port_in_use(port):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        return s.connect_ex(('localhost', port)) == 0

# Display error message
def show_error_dialog(title, message):
    global startup_error
    startup_error = message
    logger.error("ERROR: %s - %s", title, message)
    
    # Try to show a native dialog for critical errors
    try:
        script = 'display dialog "' + message.replace('"', '\"') + '" with title "' + title.replace('"', '\"') + '" buttons {"OK"} default button "OK" with icon stop'
        subprocess.run(['osascript', '-e', script])
    except Exception as e:
        logger.error("Failed to show native error dialog: %s", e)

# Open browser
def open_browser():
    url = "http://localhost:%d/" % PORT
    logger.info("Opening browser to %s", url)
    
    try:
        subprocess.run(['open', url], check=True)
    except:
        try:
            webbrowser.open(url)
        except Exception as e:
            logger.error("Could not open browser: %s", e)
            show_error_dialog("Browser Error", "Could not open browser: " + str(e))

# Handle signals
def signal_handler(sig, frame):
    logger.info("Shutting down...")
    global server
    if server:
        server.shutdown()
    # Always remove the PID file when exiting
    try:
        if os.path.exists(PID_FILE):
            os.unlink(PID_FILE)
            logger.info("Removed PID file on exit")
    except Exception as e:
        logger.error("Error removing PID file: %s", e)
    sys.exit(0)

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# Custom HTTP request handler
class CustomHTTPRequestHandler(http.server.SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        super().end_headers()
    
    def log_message(self, format, *args):
        logger.debug(format % args)

    def do_GET(self):
        if self.path == '/':
            self.send_response(200)
            self.send_header('Content-type', 'text/html')
            self.end_headers()
            self.wfile.write(HTML_CONTENT.encode('utf-8'))
            return
        elif self.path == '/check-status':
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            status = {"error": startup_error} if startup_error else {"status": "ok"}
            self.wfile.write(json.dumps(status).encode('utf-8'))
            return
        elif self.path == '/logs':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            try:
                with open(LOG_FILE, 'r') as f:
                    self.wfile.write(f.read().encode('utf-8'))
            except Exception as e:
                self.wfile.write(("Error reading log file: " + str(e)).encode('utf-8'))
            return
        elif self.path == '/exit':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'Shutting down server...')
            threading.Thread(target=lambda: (time.sleep(0.5), signal_handler(None, None))).start()
            return
        return super().do_GET()
    
    def do_POST(self):
        if self.path == '/exit':
            self.send_response(200)
            self.send_header('Content-type', 'text/plain')
            self.end_headers()
            self.wfile.write(b'Server shutting down...')
            threading.Thread(target=lambda: (time.sleep(0.5), signal_handler(None, None))).start()
            return
        
        self.send_response(405)  # Method Not Allowed
        self.end_headers()

def main():
    global startup_error
    global server
    
    try:
        # Log system information
        logger.info("Starting " + APP_NAME)
        
        # Check if port is in use
        if check_port_in_use(PORT):
            # If port is in use, assume the app is already running
            # Just open the browser and exit
            logger.info("Port %d is already in use. Opening browser to existing instance.", PORT)
            open_browser()
            sys.exit(0)
        
        # Start the server
        try:
            socketserver.TCPServer.allow_reuse_address = True
            server = socketserver.TCPServer(("localhost", PORT), CustomHTTPRequestHandler)
            
            logger.info("%s server started on port %d", APP_NAME, PORT)
            
            # Write PID to file
            try:
                with open(PID_FILE, 'w') as f:
                    f.write(str(os.getpid()))
                logger.info("Created PID file with PID %d", os.getpid())
                
                # Register cleanup to remove PID file on exit
                atexit.register(lambda: os.path.exists(PID_FILE) and os.unlink(PID_FILE))
            except Exception as e:
                logger.error("Error creating PID file: %s", e)
            
            # Open browser in a separate thread
            threading.Thread(target=lambda: (time.sleep(0.5), open_browser())).start()
            
            # Start serving
            server.serve_forever()
            
        except KeyboardInterrupt:
            logger.info("Server stopped by user")
            if server:
                server.shutdown()
        except Exception as e:
            error_msg = "Server error: " + str(e)
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            show_error_dialog("Server Error", error_msg)
            startup_error = error_msg
            sys.exit(1)
    except Exception as e:
        error_msg = "Critical error: " + str(e)
        logger.error(error_msg)
        logger.error(traceback.format_exc())
        show_error_dialog("Critical Error", error_msg)
        startup_error = error_msg
        sys.exit(1)

if __name__ == "__main__":
    main()
