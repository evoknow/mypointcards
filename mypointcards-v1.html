<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MyPointCards</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <!-- Google Fonts -->

    <!-- Google Fonts -->
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Open+Sans:wght@400;700&family=Lato:wght@400;700&family=Montserrat:wght@400;700&family=Poppins:wght@400;700&family=Nunito:wght@400;700&family=Noto+Sans:wght@400;700&family=Noto+Sans+Bengali:wght@400;700&family=Noto+Sans+SC:wght@400;700&family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+KR:wght@400;700&family=Noto+Sans+Arabic:wght@400;700&family=Bungee+Tint&family=Roboto+Condensed:wght@400;700&family=Oswald:wght@400;700&family=Bebas+Neue&family=Pacifico&display=swap" rel="stylesheet">


    <!-- Basic icon for most devices -->
    <link rel="icon" href="https://v1.mypoint.cards/icons/favicon.ico" type="image/x-icon">

    <!-- Apple Touch Icons for iOS home screen -->
    <link rel="apple-touch-icon" href="https://v1.mypoint.cards/icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="57x57" href="https://v1.mypoint.cards/icons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://v1.mypoint.cards/icons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://v1.mypoint.cards/icons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://v1.mypoint.cards/icons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://v1.mypoint.cards/icons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://v1.mypoint.cards/icons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://v1.mypoint.cards/icons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://v1.mypoint.cards/icons/apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="https://v1.mypoint.cards/icons/apple-touch-icon-180x180.png">

    <!-- iOS status bar -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="MyPointCards">



    <style>
        body {
            background-color: #f0f2f5;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 0px;
        }
        

          /* Add these CSS variables */
    :root {
        --body-bg: #f0f2f5;
        --card-bg: #ffffff;
        --text-color: #333333;
        --border-color: rgba(0, 0, 0, 0.1);
        --input-bg: #ffffff;
        --toolbar-bg: #ffffff;
        --toolbar-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        --nav-color: #444;
        --nav-active-color: #1877f2;
        --alert-bg: rgba(255, 255, 255, 0.9);
    }
    
   /* Refined dark mode styling to make elements blend better */

/* Improve dark mode variables with softer colors */
[data-bs-theme="dark"] {
    /* Softer background colors */
    --body-bg: #121212;
    --card-bg: #1e1e1e;
    --toolbar-bg: #1a1a1a;
    --input-bg: #242424;
    --dropdown-bg: #242424;
    --tab-active-bg: #2a2a2a;
    
    /* Softer text colors */
    --text-color: #d8d8d8;
    --input-text-color: #d8d8d8;
    --dropdown-text: #d8d8d8;
    
    /* Improved border colors */
    --border-color: rgba(255, 255, 255, 0.08);
    --form-control-border: rgba(255, 255, 255, 0.1);
    
    /* Better accent colors */
    --nav-active-color: #4f9eff;
    
    /* Better shadows */
    --toolbar-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}

/* Soften textarea/input styling in dark mode */
[data-bs-theme="dark"] .form-control {
    background-color: var(--input-bg);
    color: var(--input-text-color);
    border-color: var(--form-control-border);
}

/* Make textarea blend better with background */
[data-bs-theme="dark"] textarea.form-control {
    background-color: #242424;
    color: #d8d8d8;
    border-color: rgba(255, 255, 255, 0.08);
}

/* Improve tab styling for better integration */
[data-bs-theme="dark"] .nav-tabs {
    border-bottom-color: #333;
}

[data-bs-theme="dark"] .nav-tabs .nav-link {
    color: #999;
    background-color: transparent;
}

[data-bs-theme="dark"] .nav-tabs .nav-link.active {
    color: var(--nav-active-color);
    background-color: var(--tab-active-bg);
    border-color: #333 #333 var(--tab-active-bg);
}

[data-bs-theme="dark"] .nav-tabs .nav-link:hover:not(.active) {
    border-color: rgba(255, 255, 255, 0.05);
    background-color: rgba(255, 255, 255, 0.03);
}

/* Better integration of dropdown styling */
[data-bs-theme="dark"] .form-select {
    background-color: var(--dropdown-bg);
    color: var(--dropdown-text);
    border-color: var(--form-control-border);
}

/* Soften labels and text */
[data-bs-theme="dark"] .form-label,
[data-bs-theme="dark"] .form-text,
[data-bs-theme="dark"] .form-check-label {
    color: #aaa;
}

/* Reduce contrast on secondary elements */
[data-bs-theme="dark"] .text-muted {
    color: #888 !important;
}

/* Make toolbar blend better */
[data-bs-theme="dark"] .toolbar {
    background-color: var(--toolbar-bg);
    border-color: rgba(255, 255, 255, 0.05);
}

/* Make the theme toggle blend better */
[data-bs-theme="dark"] .theme-toggle {
    background-color: #242424;
    border-color: rgba(255, 255, 255, 0.08);
}

/* Customize font preview for better integration */
[data-bs-theme="dark"] .font-preview {
    background-color: #242424;
    border-color: rgba(255, 255, 255, 0.08);
}

[data-bs-theme="dark"] .font-preview:hover {
    background-color: #2a2a2a;
}

[data-bs-theme="dark"] .font-preview.active {
    border-color: var(--nav-active-color);
    background-color: rgba(79, 158, 255, 0.08);
}

/* Improve form range track */
[data-bs-theme="dark"] .form-range::-webkit-slider-runnable-track {
    background-color: #333;
}

/* Fix active tab indicator */
[data-bs-theme="dark"] .nav-tabs .nav-item.show .nav-link, 
[data-bs-theme="dark"] .nav-tabs .nav-link.active {
    background-color: var(--tab-active-bg);
    border-color: #333 #333 var(--tab-active-bg);
}

/* Reduce the intensity of alert backgrounds */
[data-bs-theme="dark"] .alert-info,
[data-bs-theme="dark"] .alert-warning,
[data-bs-theme="dark"] .alert-success,
[data-bs-theme="dark"] .alert-danger {
    background-color: rgba(30, 30, 30, 0.8);
    border-color: rgba(255, 255, 255, 0.1);
}

/* Better button styling for dark mode */
[data-bs-theme="dark"] .btn-outline-primary {
    border-color: rgba(79, 158, 255, 0.5);
    color: var(--nav-active-color);
}

/* Remove black border from active color boxes */
[data-bs-theme="dark"] .color-box.active,
[data-bs-theme="dark"] .gradient-box.active {
    border-color: var(--nav-active-color);
}
    /* Update these existing styles */
    body {
        background-color: var(--body-bg);
        color: var(--text-color);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        padding: 0px;
        transition: background-color 0.3s ease, color 0.3s ease;
    }
    
    .toolbar {
        background-color: var(--toolbar-bg);
        border-radius: 10px;
        padding: 15px;
        margin: 20px 0;
        box-shadow: var(--toolbar-shadow);
        border: 1px solid var(--border-color);
    }
    
    .nav-tabs .nav-link {
        color: var(--nav-color);
    }
    
    .nav-tabs .nav-link.active {
        font-weight: bold;
        color: var(--nav-active-color);
        background-color: var(--toolbar-bg);
    }
    
    .form-control, .form-select {
        background-color: var(--input-bg);
        color: var(--text-color);
        border-color: var(--border-color);
    }
    
    .form-control:focus, .form-select:focus {
        background-color: var(--input-bg);
        color: var(--text-color);
    }
    
    .font-preview {
        background-color: var(--input-bg);
        border-color: var(--border-color);
    }
    
    .font-preview:hover {
        background-color: var(--input-bg);
    }
    
    .font-preview.active {
        background-color: rgba(24, 119, 242, 0.1);
    }
    
    /* Dark mode toggle styles */
    .theme-toggle {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 1000;
        background-color: var(--toolbar-bg);
        border-radius: 50px;
        padding: 5px 12px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        border: 1px solid var(--border-color);
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.3s ease;
    }
    
    .theme-toggle:hover {
        transform: scale(1.05);
    }
    
    .theme-toggle i {
        font-size: 16px;
    }

    .app_title {

        font-size: 1.2em;
        color: #999;
    }

        .card-preview {
                width: 100%;
                max-width: 500px;
                height: 300px;
                position: relative;
                overflow: hidden;
                border-radius: 12px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                margin: 0 auto;
                background-color: #ED213A;
                background-size: contain;
                background-position: center;
                background-repeat: no-repeat !important;
        }

        .card-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            width: 90%;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            word-wrap: break-word;
            white-space: pre-wrap; /* This preserves line breaks */
        }
        
        .toolbar {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .nav-tabs .nav-link {
            color: #444;
        }
        
        .nav-tabs .nav-link.active {
            font-weight: bold;
            color: #1877f2;
        }
        
        .color-box {
            width: 30px;
            height: 30px;
            display: inline-block;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            border: 2px solid transparent;
        }
        
        .color-box.active {
            border-color: black;
        }
        
        .emoji {
            font-size: 24px;
            margin: 5px;
            cursor: pointer;
            display: inline-block;
        }
        
        .giphy-image {
            width: 120px;
            height: 120px;
            object-fit: cover;
            cursor: pointer;
            border-radius: 8px;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .giphy-image:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .featured-image {
            width: 120px;
            height: 120px;
            object-fit: cover;
            cursor: pointer;
            border-radius: 8px;
            margin: 5px;
            transition: transform 0.2s;
        }
        
        .featured-image:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .featured-image-container {
            position: relative;
            display: inline-block;
            margin: 5px;
        }
        
        .featured-image-container .image-info {
            display: none;
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            font-size: 12px;
            border-radius: 0 0 8px 8px;
        }
        
        .featured-image-container:hover .image-info {
            display: block;
        }
        
        /* Toast/alert animations */
        @keyframes slideInFadeOut {
            0% { transform: translateY(100px); opacity: 0; }
            10% { transform: translateY(0); opacity: 1; }
            90% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-20px); opacity: 0; }
        }
        
        .alert.position-fixed {
            animation: slideInFadeOut 3s forwards;
            z-index: 9999;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .gradient-box {
            width: 30px;
            height: 30px;
            display: inline-block;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
            border: 2px solid transparent;
        }

        .gradient-box.active {
            border-color: black;
        }

        .powered-by {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .font-preview {
            border: 1px solid #ddd;
            padding: 8px;
            margin-bottom: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .font-preview:hover {
            background-color: #f8f9fa;
        }

        .font-preview.active {
            border-color: #1877f2;
            background-color: #e9f0ff;
        }

        /* Add this CSS to center the preview text and align it with the card */
        .preview-container {
          text-align: center;
          margin-top: 1rem;
        }

        .preview-container p {
          display: inline-block;
          margin: 0 auto;
          font-weight: 500;
        }

        .preview-container strong {
          font-weight: 700;
        }



    
    /* Mobile styles */
    @media (max-width: 768px) {
        .card-preview {
            height: 250px;
        }
        
        .toolbar {
            padding: 10px;
        }
        
        .nav-tabs .nav-link {
            padding: 0.5rem 0.5rem;
            font-size: 0.9rem;
        }
        
        .font-preview {
            padding: 4px;
        }
        
        .giphy-image, .featured-image {
            width: 90px;
            height: 90px;
        }
        
        /* Better spacing for mobile forms */
        .form-label {
            margin-bottom: 0.25rem;
        }
        
        .mb-3 {
            margin-bottom: 0.75rem !important;
        }
        
        /* Adjust card text size for mobile */
        .card-text {
            font-size: 24px;
        }
    }
    
    /* Small mobile devices */
    @media (max-width: 576px) {
        .card-preview {
            height: 200px;
        }
        
        .card-text {
            font-size: 20px;
        }
        
        /* Stack the color boxes for better mobile experience */
        .color-box, .gradient-box {
            margin: 3px;
        }
        
        /* Make the buttons more tappable */
        .btn {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
        }
    }


    .emoji-container {
        display: flex;
        flex-wrap: wrap;
        max-height: 200px;
        overflow-y: auto;
    }
    
    .emoji {
        font-size: 24px;
        margin: 5px;
        cursor: pointer;
        display: inline-block;
    }
    
    @media (max-width: 768px) {
        .emoji-container {
            max-height: 150px;
        }
        
        .emoji {
            font-size: 20px;
            margin: 3px;
        }
    }


    @media (max-width: 576px) {
        .nav-tabs {
            display: flex;
            flex-wrap: nowrap;
            overflow-x: auto;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
        }
        
        .nav-tabs .nav-item {
            float: none;
            flex-shrink: 0;
        }
    }

    @media (max-width: 768px) {
        /* Stack the font controls on mobile */
        #text .row .col-md-5,
        #text .row .col-md-3,
        #text .row .col-md-4,
        #text .row .col-md-6 {
            width: 100%;
            margin-bottom: 10px;
        }
    }

   /* Inline Buttons Styling */
    .button-container {
        margin-top: 15px;
    }
    
    .button-container .btn {
        min-width: 120px;
        white-space: nowrap;
    }
    
    /* Responsive adjustments */
    @media (max-width: 767px) {
        .button-container {
            flex-direction: row;
        }
        
        .button-container .btn {
            font-size: 0.9rem;
            padding: 0.4rem 0.5rem;
        }
    }
    
    /* Very small screens */
    @media (max-width: 480px) {
        .button-container .btn i {
            margin-right: 4px;
        }
    }


   h1 {
      font-size: 1.4em;
      padding-bottom: 10px;
   }

   @media (max-width: 768px) {
    .featured-image-container .image-info {
        display: none !important; /* Force hide the overlay on mobile */
    }
    
    .featured-image-container:hover .image-info {
        display: none !important; /* Ensure it stays hidden on hover for mobile */
    }
    
    /* Make the clickable area larger and more obvious */
    .featured-image {
        border: 2px solid transparent;
        transition: border-color 0.2s;
    }
    
    .featured-image:active {
        border-color: #1877f2; /* Add a blue border when tapped */
    }
}

/* Optional: Add a tooltip that shows up on tap for mobile users */
@media (max-width: 768px) {
    #featuredResults {
        position: relative;
    }
    
    #mobileInfoTip {
        display: none;
        position: fixed;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 10px 15px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 1000;
        text-align: center;
        width: 90%;
        max-width: 300px;
    }

}


@media (max-width: 768px) {
  .text-options-container {
    overflow: hidden;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    max-height: 0;
    opacity: 0;
  }
  
  .text-options-container.visible {
    max-height: 1000px; /* Large enough to contain all options */
    opacity: 1;
  }
  
  .text-options-toggle {
    display: flex;
    align-items: center;
    justify-content: center;
    margin: 10px 0;
    padding: 10px;
    background-color: var(--toolbar-bg);
    border-radius: 5px;
    cursor: pointer;
    border: 1px solid var(--border-color);
    font-weight: 500;
  }
  
  .text-options-toggle i {
    margin-right: 8px;
    font-size: 16px;
  }
  
  .text-options-toggle:active {
    background-color: rgba(0, 123, 255, 0.2);
  }
  
  .text-options-toggle:hover {
    background-color: rgba(0, 123, 255, 0.1);
  }
}

    </style>
</head>
<body>
    <div class="theme-toggle">
        <i class="fas fa-sun"></i>
        <div class="form-check form-switch d-inline-block m-0">
            <input class="form-check-input" type="checkbox" id="themeSwitch">
        </div>
        <i class="fas fa-moon"></i>
   </div>

    <div class="container">
        <h1 class="app_title pt-4">MyPointCards v1.1.2</h1>
        
        <div class="row">
            <div class="col-md-6">
                <div class="toolbar">
                    <ul class="nav nav-tabs" id="myTab" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="text-tab" data-bs-toggle="tab" data-bs-target="#text" type="button">
                                  <span class="d-inline d-sm-none">Text</span>
                                  <span class="d-none d-sm-inline">ğŸ…°ï¸ Text</span>
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="background-tab" data-bs-toggle="tab" data-bs-target="#background" type="button">
                                  <span class="d-inline d-sm-none">Colors</span>
                                  <span class="d-none d-sm-inline">ğŸ¨ Colors</span>
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="emoji-tab" data-bs-toggle="tab" data-bs-target="#emoji" type="button">
                                <span class="d-inline d-sm-none">Emoji</span>
                                <span class="d-none d-sm-inline">ğŸ˜„ Emoji</span>
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="giphy-tab" data-bs-toggle="tab" data-bs-target="#giphy" type="button">
                                <span class="d-inline d-sm-none">Giphy</span>
                                <span class="d-none d-sm-inline">ğŸ–¼ï¸ Giphy</span>
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="upload-tab" data-bs-toggle="tab" data-bs-target="#upload" type="button">
                                <span class="d-inline d-sm-none">Upload</span>
                                <span class="d-none d-sm-inline">â¬†ï¸ Upload</span>

                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="featured-tab" data-bs-toggle="tab" data-bs-target="#featured" type="button">
                                <span class="d-inline d-sm-none">â­</span>
                                <span class="d-none d-sm-inline">â­ Featured</span>

                            </button>
                        </li>
                    </ul>
                    
                    <div class="tab-content p-3" id="myTabContent">
                        <div class="tab-pane fade show active" id="text" role="tabpanel">
                            <div class="mb-3">
                                <label for="cardText" class="form-label">What's on your mind?</label>
                                <textarea class="form-control" id="cardText" rows="3" placeholder="Type your message here..."></textarea>
                            </div>
                            <!-- Font Controls (all in one line) -->
                            <div class="mb-3">
                              <div class="row">

                                <!-- Font Family -->
                                <div class="col-md-5">
                      
                                  <select class="form-select" id="fontFamily">
                                    <option value="">Select Font</option>
                                    <option value="Roboto, sans-serif">Roboto (English)</option>
                                    <option value="'Roboto Condensed', sans-serif">Roboto Condensed</option>
                                    <option value="'Bebas Neue', sans-serif">Bebas Neue</option>
                                    <option value="Oswald, sans-serif">Oswald</option>
                                    <option value="Pacifico, cursive">Pacifico</option>
                                    <option value="'Bungee Tint', cursive">Bungee Tint</option>
                                    <option value="Open Sans, sans-serif">Open Sans</option>
                                    <option value="Lato, sans-serif">Lato</option>
                                    <option value="Montserrat, sans-serif">Montserrat</option>
                                    <option value="Poppins, sans-serif">Poppins</option>
                                    <option value="Nunito, sans-serif">Nunito</option>
                                    <option value="'Noto Sans Bengali', sans-serif">Noto Sans Bengali (à¦¬à¦¾à¦‚à¦²à¦¾)</option>
                                    <option value="'Noto Sans SC', sans-serif">Noto Sans SC (ç®€ä½“ä¸­æ–‡)</option>
                                    <option value="'Noto Sans JP', sans-serif">Noto Sans JP (æ—¥æœ¬èª)</option>
                                    <option value="'Noto Sans KR', sans-serif">Noto Sans KR (í•œêµ­ì–´)</option>
                                    <option value="'Noto Sans Arabic', sans-serif">Noto Sans Arabic (Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©)</option>
                                  </select>
                                </div>
                                
                                <!-- Font Size -->
                                <div class="col-md-3">
                                   Size: <span id="fontSizeValue">32</span>px
                                  <input type="range" class="form-range" id="fontSize" min="20" max="120" step="1" value="32">
                                </div>
                                
                                <!-- Font Color -->
                                <div class="col-md-4">
                            
                                  <div class="d-flex align-items-center">
                                    <input type="color" class="form-control form-control-color me-2" id="fontColor" value="#ffffff" title="Choose font color">
                                    <span id="fontColorHex">#ffffff</span>
                                  </div>
                                </div>
                              </div>
                            </div>

                            <div class="mb-3 d-flex align-items-center">
                              <div class="me-3">
                               
                                <div class="btn-group" role="group" aria-label="Text alignment">
                                  <input type="radio" class="btn-check" name="textAlign" id="alignLeft" autocomplete="off">
                                  <label class="btn btn-outline-primary" for="alignLeft"><i class="fas fa-align-left"></i></label>
                                  
                                  <input type="radio" class="btn-check" name="textAlign" id="alignCenter" autocomplete="off" checked>
                                  <label class="btn btn-outline-primary" for="alignCenter"><i class="fas fa-align-center"></i></label>
                                  
                                  <input type="radio" class="btn-check" name="textAlign" id="alignRight" autocomplete="off">
                                  <label class="btn btn-outline-primary" for="alignRight"><i class="fas fa-align-right"></i></label>
                                </div>
                              </div>
                              
                              <div class="flex-grow-1">
                                Line Height: <span id="lineHeightValue">1.2</span>
                                <input type="range" class="form-range" id="lineHeight" min="0.8" max="2.0" step="0.1" value="1.2">
                              </div>
                            </div>


                            <!-- Checkboxes in one line -->
                            <div class="mb-3">
                              <div class="row">
                                <div class="col-md-6">
                                  <div class="form-check">
                                    <input type="checkbox" class="form-check-input" id="textShadow" checked>
                                    <label class="form-check-label" for="textShadow">Text Shadow</label>
                                  </div>
                                </div>
                                <div class="col-md-6">
                                  <div class="form-check">
                                    <input type="checkbox" class="form-check-input" id="poweredBy" checked>
                                    <label class="form-check-label" for="poweredBy">Show "Powered by MyPoint.Cards"</label>
                                  </div>
                                </div>
                              </div>
                            </div>
                        </div>
                        
                        <div class="tab-pane fade" id="background" role="tabpanel">
                            <div class="mb-3">
                                <label class="form-label">Choose a background color:</label>
                                <div>
                                    <div class="color-box active" style="background-color: #ED213A;" data-color="#ED213A"></div>
                                    <div class="color-box" style="background-color: #3498db;" data-color="#3498db"></div>
                                    <div class="color-box" style="background-color: #2ecc71;" data-color="#2ecc71"></div>
                                    <div class="color-box" style="background-color: #f39c12;" data-color="#f39c12"></div>
                                    <div class="color-box" style="background-color: #9b59b6;" data-color="#9b59b6"></div>
                                    <div class="color-box" style="background-color: #34495e;" data-color="#34495e"></div>
                                    <div class="color-box" style="background-color: #1abc9c;" data-color="#1abc9c"></div>
                                    <div class="color-box" style="background-color: #000000;" data-color="#000000"></div>
                                    <div class="color-box" style="background-color: #e74c3c;" data-color="#e74c3c"></div>
                                    <div class="color-box" style="background-color: #f1c40f;" data-color="#f1c40f"></div>
                                    <div class="color-box" style="background-color: #95a5a6;" data-color="#95a5a6"></div>
                                    <div class="color-box" style="background-color: #ffffff;" data-color="#ffffff"></div>
                                    <div class="color-box" style="background-color: #e84393;" data-color="#e84393"></div>
                                    <div class="color-box" style="background-color: #8B4513;" data-color="#8B4513"></div>

                                </div>
                                <div class="mt-4">
                                    <label class="form-label">Gradient backgrounds:</label>
                                    <div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #f12711, #f5af19);" data-gradient="linear-gradient(to right, #f12711, #f5af19)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #8e2de2, #4a00e0);" data-gradient="linear-gradient(to right, #8e2de2, #4a00e0)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #00b09b, #96c93d);" data-gradient="linear-gradient(to right, #00b09b, #96c93d)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(45deg, #ff9a9e, #fad0c4);" data-gradient="linear-gradient(45deg, #ff9a9e, #fad0c4)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #4facfe, #00f2fe);" data-gradient="linear-gradient(to right, #4facfe, #00f2fe)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(135deg, #667eea, #764ba2);" data-gradient="linear-gradient(135deg, #667eea, #764ba2)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #2c3e50, #4ca1af);" data-gradient="linear-gradient(to right, #2c3e50, #4ca1af)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #f953c6, #b91d73);" data-gradient="linear-gradient(to right, #f953c6, #b91d73)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #11998e, #38ef7d);" data-gradient="linear-gradient(to right, #11998e, #38ef7d)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(45deg, #fc4a1a, #f7b733);" data-gradient="linear-gradient(45deg, #fc4a1a, #f7b733)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #43cea2, #185a9d);" data-gradient="linear-gradient(to right, #43cea2, #185a9d)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(135deg, #ff0844, #ffb199);" data-gradient="linear-gradient(135deg, #ff0844, #ffb199)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #2b5876, #4e4376);" data-gradient="linear-gradient(to right, #2b5876, #4e4376)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #6a3093, #a044ff);" data-gradient="linear-gradient(to right, #6a3093, #a044ff)"></div>

                                        <div class="gradient-box" style="background: linear-gradient(to right, #BF953F, #FCF6BA, #B38728, #FBF5B7, #AA771C);" data-gradient="linear-gradient(to right, #BF953F, #FCF6BA, #B38728, #FBF5B7, #AA771C)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #8e9eab, #eef2f3, #8e9eab);" data-gradient="linear-gradient(to right, #8e9eab, #eef2f3, #8e9eab)"></div>
                                        <div class="gradient-box" style="background: linear-gradient(to right, #536976, #292E49, #536976);" data-gradient="linear-gradient(to right, #536976, #292E49, #536976)"></div>

                                    </div>
                                    
                                    <div class="mt-3">
                                        <label class="form-label">Create custom gradient:</label>
                                        <div class="row">
                                            <div class="col-md-5">
                                                <input type="color" class="form-control form-control-color mb-2" id="gradientColor1" value="#ff0000">
                                                <label for="gradientColor1" class="form-text">First color</label>
                                            </div>
                                            <div class="col-md-5">
                                                <input type="color" class="form-control form-control-color mb-2" id="gradientColor2" value="#ffcc00">
                                                <label for="gradientColor2" class="form-text">Second color</label>
                                            </div>
                                            <div class="col-md-2">
                                                <button class="btn btn-sm btn-primary mt-1" id="applyCustomGradient">Apply</button>
                                            </div>
                                        </div>
                                        <div class="form-text">
                                            <select class="form-select form-select-sm mt-2" id="gradientDirection">
                                                <option value="to right">Horizontal â†’</option>
                                                <option value="to left">Horizontal â†</option>
                                                <option value="to bottom">Vertical â†“</option>
                                                <option value="to top">Vertical â†‘</option>
                                                <option value="45deg">Diagonal â†˜</option>
                                                <option value="135deg">Diagonal â†—</option>
                                                <option value="225deg">Diagonal â†™</option>
                                                <option value="315deg">Diagonal â†–</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                
                                <div class="mt-3">
                                    <label for="customColor" class="form-label">Custom color:</label>
                                    <input type="color" class="form-control form-control-color" id="customColor" value="#ED213A">
                                </div>
                            </div>
                        </div>
                        
<div class="tab-pane fade" id="emoji" role="tabpanel">
    <div class="mb-3">
        <label class="form-label">Click an emoji to add to your text:</label>
        
        <h6 class="mt-3 mb-1">Smileys & Emotions</h6>
        <div class="emoji-container">
            <span class="emoji" title="Grinning Face">ğŸ˜€</span> <!-- Grinning Face -->
            <span class="emoji" title="Face with Tears of Joy">ğŸ˜‚</span> <!-- Face with Tears of Joy -->
            <span class="emoji" title="Smiling Face with Heart-Eyes">ğŸ˜</span> <!-- Smiling Face with Heart-Eyes -->
            <span class="emoji" title="Smiling Face with Hearts">ğŸ¥°</span> <!-- Smiling Face with Hearts -->
            <span class="emoji" title="Smiling Face with Sunglasses">ğŸ˜</span> <!-- Smiling Face with Sunglasses -->
            <span class="emoji" title="Thinking Face">ğŸ¤”</span> <!-- Thinking Face -->
            <span class="emoji" title="Grinning Face with Sweat">ğŸ˜…</span> <!-- Grinning Face with Sweat -->
            <span class="emoji" title="Crying Face">ğŸ˜¢</span> <!-- Crying Face -->
            <span class="emoji" title="Pouting Face">ğŸ˜¡</span> <!-- Pouting Face -->
            <span class="emoji" title="Exploding Head">ğŸ¤¯</span> <!-- Exploding Head -->
            <span class="emoji" title="Star-Struck">ğŸ¤©</span> <!-- Star-Struck -->
            <span class="emoji" title="Sleeping Face">ğŸ˜´</span> <!-- Sleeping Face -->
            <span class="emoji" title="Smiling Face with Halo">ğŸ˜‡</span> <!-- Smiling Face with Halo -->
            <span class="emoji" title="Grimacing Face">ğŸ˜¬</span> <!-- Grimacing Face -->
            <span class="emoji" title="Hugging Face">ğŸ¤—</span> <!-- Hugging Face -->
            <span class="emoji" title="Partying Face">ğŸ¥³</span> <!-- Partying Face -->
            <span class="emoji" title="Clown Face">ğŸ¤¡</span> <!-- Clown Face -->
            <span class="emoji" title="Grinning Face with Smiling Eyes">ğŸ˜„</span> <!-- Grinning Face with Smiling Eyes -->
            <span class="emoji" title="Slightly Smiling Face">ğŸ™‚</span> <!-- Slightly Smiling Face -->
            <span class="emoji" title="Winking Face">ğŸ˜‰</span> <!-- Winking Face -->
            <span class="emoji" title="Grinning Squinting Face">ğŸ˜†</span> <!-- Grinning Squinting Face -->
            <span class="emoji" title="Partying Face">ğŸ¥³</span> <!-- Partying Face -->
            <span class="emoji" title="Thinking Face">ğŸ¤”</span> <!-- Thinking Face -->
            <span class="emoji" title="Smiling Face With Sunglasses">ğŸ˜</span> <!-- Smiling Face With Sunglasses -->
            <span class="emoji" title="Smiling Face With Halo">ğŸ˜‡</span> <!-- Smiling Face With Halo -->
            <span class="emoji" title="Loudly Crying Face">ğŸ˜­</span> <!-- Loudly Crying Face -->
            <span class="emoji" title="Star-Struck">ğŸ¤©</span> <!-- Star-Struck -->
            <span class="emoji" title="Exploding Head">ğŸ¤¯</span> <!-- Exploding Head -->
            <span class="emoji" title="Pleading Face">ğŸ¥º</span> <!-- Pleading Face -->
            <span class="emoji" title="Face with Steam From Nose">ğŸ˜¤</span> <!-- Face with Steam From Nose -->

        </div>
        
        <h6 class="mt-3 mb-1">Gestures & People</h6>
        <div class="emoji-container">
            <span class="emoji" title="Thumbs Up">ğŸ‘</span> <!-- Thumbs Up -->
            <span class="emoji" title="Folded Hands">ğŸ™</span> <!-- Folded Hands -->
            <span class="emoji" title="Flexed Biceps">ğŸ’ª</span> <!-- Flexed Biceps -->
            <span class="emoji" title="Raising Hands">ğŸ™Œ</span> <!-- Raising Hands -->
            <span class="emoji" title="Eyes">ğŸ‘€</span> <!-- Eyes -->
            <span class="emoji" title="Man Shrugging">ğŸ¤·â€â™‚ï¸</span> <!-- Man Shrugging -->
            <span class="emoji" title="Woman Facepalming">ğŸ¤¦â€â™€ï¸</span> <!-- Woman Facepalming -->
            <span class="emoji" title="Brain">ğŸ§ </span> <!-- Brain -->
            <span class="emoji" title="Crown">ğŸ‘‘</span> <!-- Crown -->
            <span class="emoji" title="Heart Hands">ğŸ«¶</span> <!-- Heart Hands -->
            <span class="emoji" title="Thumbs Down">ğŸ‘</span> <!-- Thumbs Down -->
            <span class="emoji" title="Victory Hand">âœŒï¸</span> <!-- Victory Hand -->
            <span class="emoji" title="Handshake">ğŸ¤</span> <!-- Handshake -->
            <span class="emoji" title="Clapping Hands">ğŸ‘</span> <!-- Clapping Hands -->
            <span class="emoji" title="Handshake">ğŸ¤</span> <!-- Handshake -->
            <span class="emoji" title="Woman Shrugging">ğŸ¤·â€â™€ï¸</span> <!-- Woman Shrugging -->
            <span class="emoji" title="Man Facepalming">ğŸ¤¦â€â™‚ï¸</span> <!-- Man Facepalming -->
            <span class="emoji" title="Woman Facepalming">ğŸ¤¦â€â™€ï¸</span> <!-- Woman Facepalming -->
            <span class="emoji" title="Raising Hands">ğŸ™Œ</span> <!-- Raising Hands -->
            <span class="emoji" title="Fist Bump">ğŸ¤œğŸ¤›</span> <!-- Fist Bump -->
            <span class="emoji" title="Technologist">ğŸ§‘â€ğŸ’»</span> <!-- Technologist -->
            <span class="emoji" title="Astronaut">ğŸ§‘â€ğŸš€</span> <!-- Astronaut -->
            <span class="emoji" title="Artist">ğŸ§‘â€ğŸ¨</span> <!-- Artist -->

        </div>
        
        <h6 class="mt-3 mb-1">Hearts & Symbols</h6>
        <div class="emoji-container">
            <span class="emoji" title="Red Heart">â¤ï¸</span> <!-- Red Heart -->
            <span class="emoji" title="Party Popper">ğŸ‰</span> <!-- Party Popper -->
            <span class="emoji" title="Sparkles">âœ¨</span> <!-- Sparkles -->
            <span class="emoji" title="Fire">ğŸ”¥</span> <!-- Fire -->
            <span class="emoji" title="Hundred Points">ğŸ’¯</span> <!-- Hundred Points -->
            <span class="emoji" title="Prohibited">ğŸš«</span> <!-- Prohibited/No -->
            <span class="emoji" title="Cross Mark">âŒ</span> <!-- Cross Mark/No -->
                        <span class="emoji" title="Star">â­ï¸</span> <!-- Star -->
            <span class="emoji" title="Sparkle">âœ¨</span> <!-- Sparkle -->
            <span class="emoji" title="Glowing Star">ğŸŒŸ</span> <!-- Glowing Star -->
            <span class="emoji" title="Blue Heart">ğŸ’™</span> <!-- Blue Heart -->
            <span class="emoji" title="Green Heart">ğŸ’š</span> <!-- Green Heart -->
            <span class="emoji" title="Purple Heart">ğŸ’œ</span> <!-- Purple Heart -->
            <span class="emoji" title="Black Heart">ğŸ–¤</span> <!-- Black Heart -->
            <span class="emoji" title="White Heart">ğŸ¤</span> <!-- White Heart -->
            <span class="emoji" title="Sparkling Heart">ğŸ’–</span> <!-- Sparkling Heart -->

            <span class="emoji" title="Light Bulb">ğŸ’¡</span> <!-- Light Bulb -->
            <span class="emoji" title="Collision">ğŸ’¥</span> <!-- Collision -->
            <span class="emoji" title="Sun">â˜€ï¸</span> <!-- Sun -->
            <span class="emoji" title="Crescent Moon">ğŸŒ™</span> <!-- Crescent Moon -->
            <span class="emoji" title="Check Mark Button">âœ…</span> <!-- Check Mark Button -->
            <span class="emoji" title="Cross Mark">âŒ</span> <!-- Cross Mark -->
            <span class="emoji" title="High Voltage">âš¡ï¸</span> <!-- High Voltage -->

        </div>
        
        <h6 class="mt-3 mb-1">Objects & Activities</h6>
        <div class="emoji-container">
            <span class="emoji" title="Rocket">ğŸš€</span> <!-- Rocket -->
            <span class="emoji" title="Black Small Square">â–ªï¸</span> <!-- Black Small Square -->
            <span class="emoji" title="White Small Square">â–«ï¸</span> <!-- White Small Square -->
            <span class="emoji" title="Black Circle">âš«ï¸</span> <!-- Black Circle -->
            <span class="emoji" title="White Circle">âšªï¸</span> <!-- White Circle -->
            <span class="emoji" title="Red Circle">ğŸ”´</span> <!-- Red Circle -->
            <span class="emoji" title="Large Blue Circle">ğŸ”µ</span> <!-- Large Blue Circle -->
            <span class="emoji" title="Small Orange Diamond">ğŸ”¸</span> <!-- Small Orange Diamond -->
            <span class="emoji" title="Small Blue Diamond">ğŸ”¹</span> <!-- Small Blue Diamond -->
            <span class="emoji" title="Triangle Pointing Right">â–¶ï¸</span> <!-- Triangle Pointing Right -->
            <span class="emoji" title="Triangle Pointing Down">ğŸ”½</span> <!-- Triangle Pointing Down -->

            <span class="emoji" title="Diamond Shape With A Dot Inside">ğŸ’ </span> <!-- Diamond Shape With A Dot Inside -->

            <span class="emoji" title="Chart Increasing">ğŸ“ˆ</span> <!-- Chart Increasing -->
            <span class="emoji" title="Mobile Phone">ğŸ“±</span> <!-- Mobile Phone -->
            <span class="emoji" title="Laptop">ğŸ’»</span> <!-- Laptop -->
            <span class="emoji" title="Soccer Ball">âš½</span> <!-- Soccer Ball -->
            <span class="emoji" title="Basketball">ğŸ€</span> <!-- Basketball -->
            <span class="emoji" title="Video Game">ğŸ®</span> <!-- Video Game -->
            <span class="emoji" title="Musical Note">ğŸµ</span> <!-- Musical Note -->
            <span class="emoji" title="Clapper Board">ğŸ¬</span> <!-- Clapper Board -->
            <span class="emoji" title="Books">ğŸ“š</span> <!-- Books -->
            <span class="emoji" title="Direct Hit">ğŸ¯</span> <!-- Direct Hit -->
            <span class="emoji" title="Memo">ğŸ“</span> <!-- Memo -->
            <span class="emoji" title="Loudspeaker">ğŸ“¢</span> <!-- Loudspeaker -->
            <span class="emoji" title="Laptop">ğŸ’»</span> <!-- Laptop -->
            <span class="emoji" title="Chart Increasing">ğŸ“ˆ</span> <!-- Chart Increasing -->
            <span class="emoji" title="Video Game">ğŸ®</span> <!-- Video Game -->
            <span class="emoji" title="Studio Microphone">ğŸ™ï¸</span> <!-- Studio Microphone -->

        </div>
        
        <h6 class="mt-3 mb-1">Flags</h6>
        <div class="emoji-container">
            <span class="emoji" title="Australia">ğŸ‡¦ğŸ‡º</span> <!-- Australia -->
            <span class="emoji" title="Bangladesh">ğŸ‡§ğŸ‡©</span> <!-- Bangladesh -->
            <span class="emoji" title="Brazil">ğŸ‡§ğŸ‡·</span> <!-- Brazil -->
            <span class="emoji" title="Canada">ğŸ‡¨ğŸ‡¦</span> <!-- Canada -->
            <span class="emoji" title="China">ğŸ‡¨ğŸ‡³</span> <!-- China -->
            <span class="emoji" title="Egypt">ğŸ‡ªğŸ‡¬</span> <!-- Egypt -->
            <span class="emoji" title="Egypt">ğŸ‡ªğŸ‡¬</span> <!-- Flag: Egypt -->
            <span class="emoji" title="Germany">ğŸ‡©ğŸ‡ª</span> <!-- Flag: Germany -->
            <span class="emoji" title="Indonesia">ğŸ‡®ğŸ‡©</span> <!-- Flag: Indonesia -->
            <span class="emoji" title="Israel">ğŸ‡®ğŸ‡±</span> <!-- Flag: Israel -->
            <span class="emoji" title="Palestine">ğŸ‡µğŸ‡¸</span> <!-- Flag: Palestine -->
            <span class="emoji" title="Russia">ğŸ‡·ğŸ‡º</span> <!-- Flag: Russia -->
            <span class="emoji" title="Saudi Arabia">ğŸ‡¸ğŸ‡¦</span> <!-- Flag: Saudi Arabia -->
            <span class="emoji" title="South Africa">ğŸ‡¿ğŸ‡¦</span> <!-- Flag: South Africa -->
            <span class="emoji" title="Spain">ğŸ‡ªğŸ‡¸</span> <!-- Flag: Spain -->
            <span class="emoji" title="United Arab Emirates">ğŸ‡¦ğŸ‡ª</span> <!-- Flag: United Arab Emirates -->
            <span class="emoji" title="France">ğŸ‡«ğŸ‡·</span> <!-- France -->
            <span class="emoji" title="Germany">ğŸ‡©ğŸ‡ª</span> <!-- Germany -->
            <span class="emoji" title="India">ğŸ‡®ğŸ‡³</span> <!-- India -->
            <span class="emoji" title="Indonesia">ğŸ‡®ğŸ‡©</span> <!-- Indonesia -->
            <span class="emoji" title="Israel">ğŸ‡®ğŸ‡±</span> <!-- Israel -->
            <span class="emoji" title="Italy">ğŸ‡®ğŸ‡¹</span> <!-- Italy -->
            <span class="emoji" title="Japan">ğŸ‡¯ğŸ‡µ</span> <!-- Japan -->
            <span class="emoji" title="Malaysia">ğŸ‡²ğŸ‡¾</span> <!-- Malaysia -->
            <span class="emoji" title="Mexico">ğŸ‡²ğŸ‡½</span> <!-- Mexico -->
            <span class="emoji" title="Nigeria">ğŸ‡³ğŸ‡¬</span> <!-- Nigeria -->
            <span class="emoji" title="Palestine">ğŸ‡µğŸ‡¸</span> <!-- Palestine -->
            <span class="emoji" title="Philippines">ğŸ‡µğŸ‡­</span> <!-- Philippines -->
            <span class="emoji" title="Russia">ğŸ‡·ğŸ‡º</span> <!-- Russia -->
            <span class="emoji" title="Saudi Arabia">ğŸ‡¸ğŸ‡¦</span> <!-- Saudi Arabia -->
            <span class="emoji" title="Singapore">ğŸ‡¸ğŸ‡¬</span> <!-- Singapore -->
            <span class="emoji" title="South Africa">ğŸ‡¿ğŸ‡¦</span> <!-- South Africa -->
            <span class="emoji" title="South Korea">ğŸ‡°ğŸ‡·</span> <!-- South Korea -->
            <span class="emoji" title="Turkey">ğŸ‡¹ğŸ‡·</span> <!-- Turkey -->
            <span class="emoji" title="United Arab Emirates">ğŸ‡¦ğŸ‡ª</span> <!-- United Arab Emirates -->
            <span class="emoji" title="United Kingdom">ğŸ‡¬ğŸ‡§</span> <!-- United Kingdom -->
            <span class="emoji" title="United States">ğŸ‡ºğŸ‡¸</span> <!-- United States -->
            <span class="emoji" title="Vietnam">ğŸ‡»ğŸ‡³</span> <!-- Vietnam -->

        </div>
    </div>
</div>
                        
                        <div class="tab-pane fade" id="giphy" role="tabpanel">
                            <div class="mb-3">
                                <label for="giphySearch" class="form-label">Search for GIFs:</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="giphySearch" placeholder="Enter a search term...">
                                    <button class="btn btn-primary" id="searchGiphyBtn">Search</button>
                                </div>
                            </div>
                            <div id="giphyResults" class="mt-3 d-flex flex-wrap gap-2">
                                <div class="text-center w-100 text-muted">
                                   
                                </div>
                            </div>
                        </div>
                        
                        <div class="tab-pane fade" id="upload" role="tabpanel">
                            <div class="mb-3">
                                <label for="imageUpload" class="form-label">Upload an image:</label>
                                <input class="form-control" type="file" id="imageUpload" accept="image/*">
                                <div class="form-text">For best results, use an image larger than 500x300px.</div>
                            </div>
                            <div id="uploadPreview" class="d-none mt-3">
                                <p>Image preview:</p>
                                <img id="uploadedImage" class="img-thumbnail" style="max-height: 100px;">
                                <button class="btn btn-sm btn-danger mt-2" id="removeImage">Remove Image</button>
                            </div>

                            <div class="mt-3 mb-3" id="backgroundControls" style="display: none;">
                                <label class="form-label">Scaling:</label>
                                <div class="btn-group" role="group">
                                    <input type="radio" class="btn-check" name="bgScale" id="bgContain" autocomplete="off" checked>
                                    <label class="btn btn-outline-primary" for="bgContain">Contain</label>
                                    
                                    <input type="radio" class="btn-check" name="bgScale" id="bgCover" autocomplete="off">
                                    <label class="btn btn-outline-primary" for="bgCover">Cover</label>
                                    
                                    <input type="radio" class="btn-check" name="bgScale" id="bgActual" autocomplete="off">
                                    <label class="btn btn-outline-primary" for="bgActual">Actual Size</label>
                                </div>
                                
                                <div class="mt-2">
                                    <label for="bgOpacity" class="form-label">Darkness: <span id="bgOpacityValue">20</span>%</label>
                                    <input type="range" class="form-range" id="bgOpacity" min="0" max="80" step="5" value="20">
                                    
                                </div>
                            </div>

                        </div>
                        
                        <div class="tab-pane fade" id="featured" role="tabpanel">
                            <div class="mb-3">
                                <label for="featuredSearch" class="form-label">Search for featured images:</label>
                                <div class="input-group">
                                    <input type="text" class="form-control" id="featuredSearch" placeholder="Search by a keyword">
                                    <button class="btn btn-primary" id="searchFeaturedBtn">Search</button>
                                </div>
                            </div>
                            <div id="featuredResults" class="mt-3 d-flex flex-wrap">
                                <div class="text-center w-100 text-muted">
                                    <div class="spinner-border text-primary" role="status">
                                        <span class="visually-hidden">Loading...</span>
                                    </div>
                                    <p class="mt-2">Loading featured images...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
          

            </div>
            
            <div class="col-md-6">
                <div class="card-preview" id="cardPreview">
                    <div class="card-text" id="previewText">What's on your mind?</div>
                    <div class="powered-by" id="poweredByText">Powered by MyPoint.Cards</div>
                </div>
                <div class="mt-3 preview-container">

    
                    <div class="button-container justify-content-between gap-2">
                        <button class="btn btn-primary flex-grow-1" id="downloadBtn">
                            <i class="fas fa-download"></i> Download
                        </button>
                        <button class="btn btn-info text-white flex-grow-1" id="twitterBtn">
                            Share on X
                        </button>
                        <button class="btn btn-secondary flex-grow-1" id="resetBtn">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                        <button class="btn btn-secondary flex-grow-1" id="helpBtn">
                            <i class="fas fa-circle-info"></i> Help
                        </button>
                    </div>

                </div>


            </div>
        </div>
        
        <div class="text-center footer-container text-muted mt-5">
            <p class="m-0"><a href="https://mypoint.cards">MyPoint.Cards</a><br><span style="font-style: italic;">make your point stand out in any feed</span></p>
        </div>
    </div>
    
    <!-- Bootstrap JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.0/js/bootstrap.bundle.min.js"></script>
    <!-- html2canvas for image capture -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <script>
        // DOM Elements
        const isMobile = window.matchMedia("(max-width: 768px)").matches;
        const cardPreview = document.getElementById('cardPreview');
        const previewText = document.getElementById('previewText');
        const cardText = document.getElementById('cardText');
        const colorBoxes = document.querySelectorAll('.color-box');
        const customColor = document.getElementById('customColor');
        const imageUpload = document.getElementById('imageUpload');
        const uploadPreview = document.getElementById('uploadPreview');
        const uploadedImage = document.getElementById('uploadedImage');
        const removeImage = document.getElementById('removeImage');
        const downloadBtn = document.getElementById('downloadBtn');
        const twitterBtn = document.getElementById('twitterBtn');
        const resetBtn = document.getElementById('resetBtn');
        const helpBtn = document.getElementById('helpBtn');
        const emojis = document.querySelectorAll('.emoji');
        const giphySearch = document.getElementById('giphySearch');
        const searchGiphyBtn = document.getElementById('searchGiphyBtn');
        const giphyResults = document.getElementById('giphyResults');
        const featuredTab = document.getElementById('featured-tab');
        const featuredSearch = document.getElementById('featuredSearch');
        const searchFeaturedBtn = document.getElementById('searchFeaturedBtn');
        const featuredResults = document.getElementById('featuredResults');
        
        const gradientBoxes = document.querySelectorAll('.gradient-box');
        const gradientColor1 = document.getElementById('gradientColor1');
        const gradientColor2 = document.getElementById('gradientColor2');
        const gradientDirection = document.getElementById('gradientDirection');
        const applyCustomGradient = document.getElementById('applyCustomGradient');


        // Giphy API Key (limited for demo purposes)
        const GIPHY_API_KEY = 'GlVGYHkr3WSBnllca54iNt0yFbjz7L65';

        // Featured images API endpoint
        const FEATURED_API_ENDPOINT = 'https://featured.mypoint.cards';
        
        // Local fallback data for featured images since the external API has CORS restrictions
        const FALLBACK_FEATURED_DATA = {
            featured: {
                "1": {"image-url": "https://featured.mypoint.cards/assets/default.webp", "category": "technology, startup", "tags": "ai, image generation, llm"}
            }
        };
        
        // Variables
        let hasBackgroundImage = false;
        let backgroundImageSource = null; // 'upload', 'giphy', 'featured', or null
        let featuredImages = null;

        let corsBlocked = true; // Assume CORS is blocked to avoid repeated attempts

        let giphyCurrentPage = 0;
        const giphyResultsPerPage = 9;
        const giphyMaxPages = 10;
        let giphyTotalResults = [];
        let giphyCurrentQuery = '';

        const fontFamily = document.getElementById('fontFamily');
        const fontSize = document.getElementById('fontSize');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const fontColor = document.getElementById('fontColor');
        const fontColorHex = document.getElementById('fontColorHex');
        const textShadow = document.getElementById('textShadow');
        const poweredBy = document.getElementById('poweredBy');
        const poweredByText = document.getElementById('poweredByText');

        const backgroundControls = document.getElementById('backgroundControls');
        const bgContain = document.getElementById('bgContain');
        const bgCover = document.getElementById('bgCover');
        const bgActual = document.getElementById('bgActual');
        const bgOpacity = document.getElementById('bgOpacity');
        const bgOpacityValue = document.getElementById('bgOpacityValue');


        // Variables for image positioning
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let initialBgPosX = 50; // Default position (center)
        let initialBgPosY = 50; // Default position (center)
        let currentBgPosX = 50;
        let currentBgPosY = 50;

        const alignLeft = document.getElementById('alignLeft');
        const alignCenter = document.getElementById('alignCenter');
        const alignRight = document.getElementById('alignRight');

        // Add these variables at the top with other DOM elements
        const themeSwitch = document.getElementById('themeSwitch');
        const htmlElement = document.documentElement;

        let featuredCurrentPage = 0;
        const featuredResultsPerPage = 9; // 3x3 grid, similar to Giphy

        let featuredMaxPages = 5
        let featuredTotalResults = [];
        let featuredCurrentQuery = '';

        let appStartTime = null;
        let totalTimeSpent = 0;
        let userActivityTimeout = null;
        let isUserActive = true;
        let cardDownloadCount = 0;
        const INACTIVITY_TIMEOUT = 10000; // 10 sec of inactivity before pausing the timer
        const ENABLE_USAGE_TRACKING = 'yes'; // Set to 'yes' to enable or 'no' to disable local usage tracking

        const lineHeight = document.getElementById('lineHeight');
        const lineHeightValue = document.getElementById('lineHeightValue');

        let textIsDragging = false;
        let textDragStartX = 0;
        let textDragStartY = 0;
        let textPosX = 50; // Default to center
        let textPosY = 50; // Default to center

        let shareImageBlob = null;
        let shareImageFormat = null;
        let shareImageDataURL = null;

        function setupClipboardPaste() {
          // Listen for paste events on the document level to capture pastes anywhere
          document.addEventListener('paste', function(e) {
            // Check if the event has clipboard data with images
            if (e.clipboardData && e.clipboardData.items) {
              // Loop through clipboard items
              for (let i = 0; i < e.clipboardData.items.length; i++) {
                const item = e.clipboardData.items[i];
                
                // Check if item is an image
                if (item.type.indexOf('image') !== -1) {
                  // Get the image as a file
                  const file = item.getAsFile();
                  
                  // Process the file as if it was uploaded
                  processClipboardImage(file);
                  
                  // Prevent the default paste behavior
                  e.preventDefault();
                  return;
                }
              }
            }
          });
        }

        function processClipboardImage(file) {
          if (file) {
            // Show a loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'clipboardLoadingOverlay';
            loadingOverlay.style.position = 'absolute';
            loadingOverlay.style.top = '0';
            loadingOverlay.style.left = '0';
            loadingOverlay.style.width = '100%';
            loadingOverlay.style.height = '100%';
            loadingOverlay.style.background = 'rgba(0,0,0,0.5)';
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.justifyContent = 'center';
            loadingOverlay.style.alignItems = 'center';
            loadingOverlay.style.zIndex = '10';
            loadingOverlay.style.borderRadius = '12px';
            loadingOverlay.innerHTML = '<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading image...</span></div>';
            
            cardPreview.style.position = 'relative';
            cardPreview.appendChild(loadingOverlay);
            
            // Create a data URL from the file
            const reader = new FileReader();
            
            reader.onload = function(event) {
              // Show the thumbnail preview (simulate an upload)
              uploadedImage.src = event.target.result;
              uploadPreview.classList.remove('d-none');
              
              // Set as background image
              cardPreview.style.backgroundImage = `url(${event.target.result})`;
              cardPreview.style.backgroundSize = 'contain';
              cardPreview.style.backgroundPosition = 'center';
              cardPreview.style.backgroundRepeat = 'no-repeat';
              
              // Update the state variables
              hasBackgroundImage = true;
              backgroundImageSource = 'upload';
              
              // Reset position to center
              cardPreview.style.backgroundPosition = '50% 50%';
              initialBgPosX = 50;
              initialBgPosY = 50;
              currentBgPosX = 50;
              currentBgPosY = 50;
              
              // Apply the darkness overlay
              applyBackgroundDarkness();
              
              // Update cursor style
              updateCursorStyle();
              
              // Show background controls
              showBackgroundControls();
              
              // Select appropriate scaling option
              const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
              const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
              const isIOSSafari = isIOS && isSafari;
              
              if (isIOSSafari) {
                // For iOS Safari, 'contain' mode tends to work better
                bgContain.checked = true;
              }
              
              // Remove the loading overlay
              if (document.getElementById('clipboardLoadingOverlay')) {
                cardPreview.removeChild(loadingOverlay);
              }
              
              // Show a success message
              showAlert('Pasted image applied as background!', 'success');
            };
            
            reader.onerror = function() {
              // Remove loading overlay
              if (document.getElementById('clipboardLoadingOverlay')) {
                cardPreview.removeChild(loadingOverlay);
              }
              
              // Show error message
              showAlert('Failed to process clipboard image. Please try again.', 'warning');
            };
            
            // Start reading the file
            reader.readAsDataURL(file);
          }
        }

        function preloadFonts() {
          return new Promise((resolve) => {
            // Get the currently selected font
            const currentFont = fontFamily.value;
            
            // If no font is selected, resolve immediately
            if (!currentFont) {
              resolve();
              return;
            }
            
            // Create a temporary span to trigger font loading
            const tempSpan = document.createElement('span');
            tempSpan.style.fontFamily = currentFont;
            tempSpan.style.fontSize = '0px';
            tempSpan.innerHTML = 'Font Preloader';
            
            // Append to body temporarily
            document.body.appendChild(tempSpan);
            
            // Check if the document fonts are loaded
            if (document.fonts && document.fonts.ready) {
              // Modern browsers support the font loading API
              document.fonts.ready.then(() => {
                // Cleanup
                document.body.removeChild(tempSpan);
                resolve();
              }).catch(() => {
                // On error, still resolve but after cleanup
                document.body.removeChild(tempSpan);
                resolve();
              });
            } else {
              // Fallback for browsers without font loading API
              // Give it a timeout to allow font to load
              setTimeout(() => {
                document.body.removeChild(tempSpan);
                resolve();
              }, 500);
            }
          });
        }

        function cleanupExistingToggles() {
          // Find existing toggles and containers
          const existingToggle = document.querySelector('.text-options-toggle');
          const existingContainer = document.querySelector('.text-options-container');
          
          // If toggle exists, remove it
          if (existingToggle && existingToggle.parentNode) {
            existingToggle.parentNode.removeChild(existingToggle);
          }
          
          // If container exists, move its children back to the text tab and remove it
          if (existingContainer && existingContainer.parentNode) {
            const textTab = document.getElementById('text');
            if (textTab) {
              // Move all children back to the text tab
              while (existingContainer.firstChild) {
                textTab.appendChild(existingContainer.firstChild);
              }
              // Remove the empty container
              existingContainer.parentNode.removeChild(existingContainer);
            }
          }
        }

        // Function to set up the text options toggle for mobile
        function setupTextOptionsToggle() {
        if (window.innerWidth > 768) return;

        const textTab = document.getElementById('text');
        if (!textTab) return;

        const cardTextContainer = textTab.querySelector('#cardText')?.closest('.mb-3');
        if (!cardTextContainer) return;

        // Check if already exists to avoid duplicate
        if (textTab.querySelector('.text-options-container')) return;

        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'text-options-container';

        // Select specific elements to move
        const selectors = [
        '#fontFamily',
        '#fontSize',
        '#fontColor',
        '#lineHeight',
        '#textShadow',
        '#poweredBy',
        '#alignLeft',
        '#alignCenter',
        '#alignRight',
        'input[name="imageFormat"]'
        ];

        const elementsToMove = new Set();

        selectors.forEach(selector => {
        const el = textTab.querySelector(selector);
        if (el) {
          const parent = el.closest('.mb-3') || el.closest('.d-flex') || el;
          elementsToMove.add(parent);
        }
        });

        elementsToMove.forEach(el => optionsContainer.appendChild(el));

        const toggleBtn = document.createElement('div');
        toggleBtn.className = 'text-options-toggle';
        toggleBtn.innerHTML = '<i class="fas fa-cog"></i> Text Options';

        cardTextContainer.after(toggleBtn);
        toggleBtn.after(optionsContainer);

        toggleBtn.addEventListener('click', function() {
        optionsContainer.classList.toggle('visible');
        toggleBtn.innerHTML = optionsContainer.classList.contains('visible')
          ? '<i class="fas fa-chevron-up"></i> Hide Options'
          : '<i class="fas fa-cog"></i> Text Options';
        });
        }


        function initializeApp() {

          addDraggingStyleIfNeeded();
          initUsageCounter();
          startTimeTracking();
          
          // Add CSS for the usage stats if not already added
          if (!document.getElementById('usageStatsStyle')) {
            const style = document.createElement('style');
            style.id = 'usageStatsStyle';
            style.textContent = `
              #usageStats {
                color: #6c757d;
                font-size: 0.8em;
                margin-top: 0.25rem;
              }
              
              [data-bs-theme="dark"] #usageStats {
                color: #adb5bd;
              }
              
              /* iOS optimizations */
              .ios-loading {
                display: flex;
                align-items: center;
                justify-content: center;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0,0,0,0.7);
                z-index: 9999;
                color: white;
                flex-direction: column;
                gap: 15px;
              }
              
              .ios-loading .spinner {
                width: 50px;
                height: 50px;
                border: 5px solid rgba(255,255,255,0.3);
                border-radius: 50%;
                border-top-color: white;
                animation: ios-spin 1s infinite linear;
              }
              
              @keyframes ios-spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
              }
            `;
            document.head.appendChild(style);
          }
          
          // Only set up the interval if tracking is enabled
          if (ENABLE_USAGE_TRACKING === 'yes') {
            setInterval(function() {
              if (appStartTime) {
                const sessionTime = Math.floor((new Date() - appStartTime) / 1000);
                const displayTime = totalTimeSpent + sessionTime;
                const count = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
                const downloads = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
                updateUsageStats(parseInt(count), displayTime, downloads);
              }
            }, 1000);
          }
          
          makeTextDraggable();
          setupTextDragging();
          setupInlineTextEditing();
          addFormatSelection();
          initializeSharing();
          
          // Initialize featured images
          initFeaturedImages();
          
          // Load saved preferences
          loadSavedPreferences();
          
          // Check for and apply system theme preference
          initTheme();
          
          // Add a listener for the featured tab to ensure handlers are set up
          featuredTab.addEventListener('click', function() {
            // If we already have featured images, just display them
            if (featuredImages) {
              displayFeaturedImages(featuredImages);
              // After displaying, set up the handlers
              setTimeout(setupFeaturedImageHandlers, 100);
            } else {
              // Otherwise, try to load them
              loadFeaturedImages();
              // Set up handlers after a delay to ensure images are rendered
              setTimeout(setupFeaturedImageHandlers, 500);
            }
          });
          
          // Override the Giphy search to ensure our enhanced handlers are used
          const originalSearchGiphyBtn = searchGiphyBtn.onclick;
          searchGiphyBtn.onclick = function() {
            searchGiphy(0);
            // Set up handlers after images load
            setTimeout(setupGiphyImageHandlers, 500);
          };
          
          // Enhanced keyboard handling for Giphy search
          giphySearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
              searchGiphy(0);
              // Set up handlers after images load
              setTimeout(setupGiphyImageHandlers, 500);
            }
          });
          
          // Detect when iOS Safari is about to navigate away
          window.addEventListener('pagehide', function() {
            // Save any unsaved state
            savePreferences();
            stopTimeTracking();
          });
          
          // Fix for iOS Safari orientation change
          window.addEventListener('orientationchange', function() {
            // Short delay to allow the browser to adjust
            setTimeout(function() {
              // Refresh image positioning
              if (hasBackgroundImage) {
                cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;
              }
            }, 300);
          });
          
          // Update button labels for the device
          updateButtonLabels();
          
          // If on iOS, check for iOS 17.4+ which has better support
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;




          if (isIOS) {
            // Attempt to detect iOS version
            const match = navigator.userAgent.match(/OS (\d+)_(\d+)_?(\d+)?/);
            if (match) {
              const version = [
                parseInt(match[1], 10),
                parseInt(match[2], 10),
                parseInt(match[3] || 0, 10)
              ];
              
              // iOS 17.4+ has better canvas support
              const hasImprovedCanvasSupport = (version[0] > 17 || (version[0] === 17 && version[1] >= 4));
              
              if (!hasImprovedCanvasSupport) {
                // Add warning for older iOS versions
                // const warningEl = document.createElement('div');
                // warningEl.className = 'alert alert-warning text-center';
                // warningEl.innerHTML = 'Texting cards require saving to Photos first.';
                
                // // Insert after the toolbar
                // const toolbar = document.querySelector('.toolbar');
                // if (toolbar && toolbar.parentNode) {
                //   toolbar.parentNode.insertBefore(warningEl, toolbar.nextSibling);
                  
                //   // Auto-dismiss after 10 seconds
                //   setTimeout(() => {
                //     if (warningEl.parentNode) {
                //       warningEl.parentNode.removeChild(warningEl);
                //     }
                //   }, 10000);
                // }
              }
            }
          }
        }


        // Create a special version of html2canvas for iOS
        async function createIOSFriendlyCanvas(element, options = {}) {
          // Check if this is iOS Safari
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          const isIOSSafari = isIOS && isSafari;
          
          if (!isIOSSafari) {
            // Use regular html2canvas for non-iOS Safari
            return html2canvas(element, options);
          }
          
          // Show loading indicator
          const hideLoading = showIOSLoadingOverlay('Creating image...');
          
          try {
            // Create a canvas with WebKit-specific optimizations
            const canvas = document.createElement('canvas');
            const rect = element.getBoundingClientRect();
            
            // Set canvas dimensions
            canvas.width = rect.width * 1.5;
            canvas.height = rect.height * 1.5;
            
            // Create context with optimization flags to help WebKit
            const ctx = canvas.getContext('2d', {
              alpha: true,
              willReadFrequently: true,
              desynchronized: false
            });
            
            // Make the canvas visible in the DOM temporarily
            // This forces WebKit to use hardware acceleration
            canvas.style.position = 'fixed';
            canvas.style.top = '0';
            canvas.style.left = '0';
            canvas.style.zIndex = '-1';
            canvas.style.opacity = '0.01'; // Nearly invisible but still rendered
            document.body.appendChild(canvas);
            
            // Force a reflow to ensure the canvas is fully initialized
            canvas.getBoundingClientRect();
            
            // Get background information
            const computedStyle = getComputedStyle(element);
            const backgroundColor = computedStyle.backgroundColor;
            const backgroundImage = computedStyle.backgroundImage;
            
            // Draw a solid color first - use a bright visible color to ensure rendering
            ctx.fillStyle = '#FFFFFF'; // White background first
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Then draw the actual background color
            ctx.fillStyle = backgroundColor || '#ED213A'; // App's default red if not set
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // For gradients or solid colors from UI selections
            if (!hasBackgroundImage) {
              const activeGradientBox = document.querySelector('.gradient-box.active');
              const activeColorBox = document.querySelector('.color-box.active');
              
              if (activeGradientBox) {
                // Handle gradient backgrounds
                const gradientValue = activeGradientBox.getAttribute('data-gradient');
                if (gradientValue && gradientValue.includes('linear-gradient')) {
                  const gradientMatch = gradientValue.match(/linear-gradient\(([^)]+)\)/);
                  if (gradientMatch && gradientMatch[1]) {
                    const parts = gradientMatch[1].split(',').map(part => part.trim());
                    const direction = parts[0];
                    const colorStops = parts.slice(1);
                    
                    // Create gradient based on direction
                    let gradient;
                    if (direction.includes('to right')) {
                      gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    } else if (direction.includes('to left')) {
                      gradient = ctx.createLinearGradient(canvas.width, 0, 0, 0);
                    } else if (direction.includes('to bottom')) {
                      gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                    } else if (direction.includes('to top')) {
                      gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
                    } else if (direction.includes('45deg')) {
                      gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    } else if (direction.includes('135deg')) {
                      gradient = ctx.createLinearGradient(0, canvas.height, canvas.width, 0);
                    } else if (direction.includes('225deg')) {
                      gradient = ctx.createLinearGradient(canvas.width, canvas.height, 0, 0);
                    } else if (direction.includes('315deg')) {
                      gradient = ctx.createLinearGradient(canvas.width, 0, 0, canvas.height);
                    } else {
                      gradient = ctx.createLinearGradient(0, 0, canvas.width, 0);
                    }
                    
                    // Add color stops
                    if (colorStops.length >= 2) {
                      colorStops.forEach((color, index) => {
                        gradient.addColorStop(index / (colorStops.length - 1), color);
                      });
                      
                      // Draw the gradient with a small delay to ensure rendering
                      ctx.fillStyle = gradient;
                      ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                  }
                }
              } else if (activeColorBox) {
                // Handle solid color backgrounds
                const colorValue = activeColorBox.getAttribute('data-color');
                if (colorValue) {
                  ctx.fillStyle = colorValue;
                  ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
              } else if (customColor && customColor.value) {
                // Handle custom color
                ctx.fillStyle = customColor.value;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              }
              
              // Add a subtle pattern to force proper rendering
              // This tricks WebKit into preserving the background
              ctx.fillStyle = 'rgba(255,255,255,0.01)';
              for (let i = 0; i < canvas.width; i += 20) {
                for (let j = 0; j < canvas.height; j += 20) {
                  ctx.fillRect(i, j, 1, 1);
                }
              }
              
              // Force a composite operation to ensure proper rendering
              ctx.globalCompositeOperation = 'source-over';
            } else {
              // Handle background image
              const img = new Image();
              img.crossOrigin = 'anonymous';
              
              // Get the background image URL
              let bgImage = computedStyle.backgroundImage;
              let imageUrl = '';
              
              if (bgImage.includes('url(')) {
                imageUrl = bgImage.match(/url\(['"]?(.*?)['"]?\)/)[1];
              }
              
              if (imageUrl) {
                // Use a timeout to prevent hanging
                const imageLoadPromise = new Promise((resolve) => {
                  img.onload = () => resolve(true);
                  img.onerror = () => resolve(false);
                  
                  // Set a timeout in case the image loading hangs
                  setTimeout(() => resolve(false), 3000);
                  
                  // Start loading the image
                  img.src = imageUrl;
                });
                
                // Wait for image to load or timeout
                const imageLoaded = await imageLoadPromise;
                
                if (imageLoaded) {
                  // Draw the image according to the background-size property
                  if (computedStyle.backgroundSize === 'cover') {
                    drawImageCover(ctx, img, 0, 0, canvas.width, canvas.height);
                  } else if (computedStyle.backgroundSize === 'contain') {
                    drawImageContain(ctx, img, 0, 0, canvas.width, canvas.height);
                  } else {
                    // Default - just draw the image
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                  }
                  
                  // Apply darkness overlay
                  const opacity = parseInt(bgOpacity.value) / 100;
                  if (opacity > 0) {
                    ctx.fillStyle = `rgba(0,0,0,${opacity})`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                  }
                }
              }
            }
            
            // Draw the text
            const textElement = element.querySelector('.card-text');
            if (textElement) {
              const text = textElement.innerText;
              const textStyle = getComputedStyle(textElement);
              const fontSize = parseInt(textStyle.fontSize) * 1.5;
              const fontFamily = textStyle.fontFamily;
              const textColor = textStyle.color;
              const textAlign = textStyle.textAlign;
              
              // Important: Get the actual position from the element's styles
              // This is what preserves custom text positioning
              const elementRect = textElement.getBoundingClientRect();
              const containerRect = element.getBoundingClientRect();
              
              // If using absolute positioning (left/top), preserve the position
              // (Note: this assumes text is positioned with "transform: translate(-50%, -50%)")
              let textPosX = 50; // Default center
              let textPosY = 50; // Default center
              
              // If custom position was set via left/top CSS properties
              if (textElement.style.left) {
                textPosX = parseFloat(textElement.style.left);
              }
              if (textElement.style.top) {
                textPosY = parseFloat(textElement.style.top);
              }
              
              // Convert percentage position to canvas pixels
              const xPos = (textPosX / 100) * canvas.width;
              const yPos = (textPosY / 100) * canvas.height;
              
              let fontFamilyWithFallbacks = fontFamily;
              
              if (!fontFamilyWithFallbacks.includes(',')) {
                  // If there's no fallback specified, add some standard ones
                  fontFamilyWithFallbacks = `${fontFamily}, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif`;
              }
              
              ctx.font = `${fontSize}px ${fontFamilyWithFallbacks}`;

              if (isIOSSafari) {
                  // Try to extract weight from fontFamily if it contains a weight specification
                  let fontWeight = 'normal';
                  if (textStyle.fontWeight) {
                    fontWeight = textStyle.fontWeight;
                  }
                  
                  // Apply the font twice - this trick helps Safari render the font correctly
                  ctx.font = `${fontWeight} ${fontSize}px ${fontFamilyWithFallbacks}`;
                  
                  // Force text rendering to better quality
                  ctx.textRendering = 'optimizeLegibility';
                  ctx.imageSmoothingEnabled = true;
                  ctx.imageSmoothingQuality = 'high';
               }

              ctx.fillStyle = textColor;
              ctx.textAlign = textAlign || 'center';
              
              // Draw text at the proper position
              if (textAlign === 'left') {
                // For left-aligned text, offset from the position
                const xOffset = -((elementRect.width / 2) - 20);
                drawWrappedText(ctx, text, xPos + xOffset, yPos, canvas.width - 40, fontSize * 1.2);
              } else if (textAlign === 'right') {
                // For right-aligned text, offset from the position
                const xOffset = (elementRect.width / 2) - 20;
                drawWrappedText(ctx, text, xPos + xOffset, yPos, canvas.width - 40, fontSize * 1.2);
              } else {
                // For center-aligned text, use the position directly
                drawWrappedText(ctx, text, xPos, yPos, canvas.width - 40, fontSize * 1.2);
              }
              
              // Apply text shadow if enabled
              if (textElement.style.textShadow && textElement.style.textShadow !== 'none') {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 2;
              }
            }
            
            // Draw "Powered by" text if enabled
            const poweredByElement = element.querySelector('.powered-by');
            if (poweredByElement && poweredBy.checked) {
              ctx.font = '10px Arial';
              ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
              ctx.textAlign = 'right';
              ctx.fillText('Powered by MyPoint.Cards', canvas.width - 10, canvas.height - 10);
            }
            
            // Force another composite operation to ensure rendering
            ctx.globalCompositeOperation = 'destination-over';
            ctx.globalCompositeOperation = 'source-over';
            
            // Allow a moment for WebKit to process the rendering
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Create a temporary image element to finalize the canvas
            // This extra step helps ensure the canvas content is fully rendered
            const tempImage = new Image();
            tempImage.width = canvas.width;
            tempImage.height = canvas.height;
            
            // Convert canvas to an image and back to canvas
            // This forces WebKit to finalize all rendering operations
            tempImage.src = canvas.toDataURL('image/png');
            
            // Wait for the image to load
            await new Promise(resolve => {
              tempImage.onload = resolve;
              tempImage.onerror = resolve; // Continue even if there's an error
            });
            
            // Create a final canvas
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            
            const finalCtx = finalCanvas.getContext('2d');
            finalCtx.drawImage(tempImage, 0, 0);
            
            // Ensure the whole compositing pipeline has flushed with a double requestAnimationFrame
            await new Promise(resolve => requestAnimationFrame(() => requestAnimationFrame(resolve)));
            
            // Remove the original canvas from DOM
            document.body.removeChild(canvas);
            
            return finalCanvas;
          } catch (error) {
            console.error('iOS friendly canvas creation failed:', error);
            
            // Fallback to simplified html2canvas with minimal options
            try {
              return await html2canvas(element, {
                scale: 1, // Lower scale
                useCORS: true,
                allowTaint: true,
                logging: false,
                backgroundColor: null,
                removeContainer: true,
                imageTimeout: 0 // No timeout
              });
            } catch (fallbackError) {
              console.error('Fallback canvas creation failed:', fallbackError);
              throw fallbackError;
            }
          } finally {
            // Hide loading overlay
            if (hideLoading) hideLoading();
          }
        }

        // Helper function to draw text with wrapping
        function XXX_drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {
          const words = text.split(' ');
          let line = '';
          let lines = [];
          
          // Split text into lines
          for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxWidth && n > 0) {
              lines.push(line);
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line);
          
          // Calculate starting Y position to center text vertically
          const totalHeight = lines.length * lineHeight;
          let textY = y - (totalHeight / 2) + (lineHeight / 2);
          
          // Draw each line
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], x, textY);
            textY += lineHeight;
          }
        }

        function drawWrappedText(ctx, text, x, y, maxWidth, lineHeight) {
          const words = text.split(' ');
          let line = '';
          let lines = [];
          
          // Split text into lines
          for (let n = 0; n < words.length; n++) {
            const testLine = line + words[n] + ' ';
            const metrics = ctx.measureText(testLine);
            const testWidth = metrics.width;
            
            if (testWidth > maxWidth && n > 0) {
              lines.push(line);
              line = words[n] + ' ';
            } else {
              line = testLine;
            }
          }
          lines.push(line);
          
          // Calculate starting Y position to center text vertically around the specified y
          const totalHeight = lines.length * lineHeight;
          let textY = y - (totalHeight / 2) + (lineHeight / 2);
          
          // Draw each line
          for (let i = 0; i < lines.length; i++) {
            ctx.fillText(lines[i], x, textY);
            textY += lineHeight;
          }
        }

        // Helper functions for drawing images with cover/contain
        function drawImageCover(ctx, img, x, y, width, height) {
          const imgRatio = img.width / img.height;
          const containerRatio = width / height;
          
          let drawWidth, drawHeight, offsetX, offsetY;
          
          if (imgRatio > containerRatio) {
            // Image is wider than container relative to height
            drawHeight = height;
            drawWidth = height * imgRatio;
            offsetX = (width - drawWidth) / 2;
            offsetY = 0;
          } else {
            // Image is taller than container relative to width
            drawWidth = width;
            drawHeight = width / imgRatio;
            offsetX = 0;
            offsetY = (height - drawHeight) / 2;
          }
          
          ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
        }

        function drawImageContain(ctx, img, x, y, width, height) {
          const imgRatio = img.width / img.height;
          const containerRatio = width / height;
          
          let drawWidth, drawHeight, offsetX, offsetY;
          
          if (imgRatio > containerRatio) {
            // Image is wider than container relative to height
            drawWidth = width;
            drawHeight = width / imgRatio;
            offsetX = 0;
            offsetY = (height - drawHeight) / 2;
          } else {
            // Image is taller than container relative to width
            drawHeight = height;
            drawWidth = height * imgRatio;
            offsetX = (width - drawWidth) / 2;
            offsetY = 0;
          }
          
          ctx.drawImage(img, x + offsetX, y + offsetY, drawWidth, drawHeight);
        }

        async function handleImageExport(buttonType) {
          // Disable button and show loading state
          const button = buttonType === 'download' ? downloadBtn : twitterBtn;
          const originalButtonText = button.innerHTML;
          button.disabled = true;
          button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';

          // Save preferences before download/sharing
          savePreferences();

          // Get the selected format
          const selectedFormat = document.querySelector('input[name="imageFormat"]:checked').value;
          const mimeType = 'image/' + (selectedFormat === 'jpg' ? 'jpeg' : selectedFormat);
          const fileExtension = selectedFormat;
          
          // Different quality settings based on format
          const quality = selectedFormat === 'webp' ? 0.92 : 
                         selectedFormat === 'jpg' ? 0.9 : 1.0;

          // Check if this is an iOS device
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          const isIOSSafari = isIOS && isSafari;
          
          await preloadFonts();

          // Check if we're dealing with an external background image
          const hasExternalImage = hasBackgroundImage && 
            (backgroundImageSource === 'giphy' || backgroundImageSource === 'featured' || backgroundImageSource === 'upload');

          // Prepare the card for export and get the restore function
          const restoreStyles = prepareCardForExport();

          try {
            // For iOS Safari, use our custom canvas renderer
            if (isIOSSafari) {
              const canvas = await createIOSFriendlyCanvas(cardPreview, {
                useCORS: true,
                allowTaint: true,
                backgroundColor: selectedFormat === 'jpg' ? '#ffffff' : null,
                scale: 1.5, // Lower scale for better performance
                logging: false
              });
              
              // Process canvas result using a more iOS-friendly approach
              try {
                // Modern browsers support toBlob directly
                canvas.toBlob(async function(blob) {
                  try {
                    // Create a proper File object with name and type
                    const file = new File([blob], `mypointcard.${fileExtension}`, {
                      type: mimeType,
                      lastModified: new Date().getTime()
                    });
                    
                    if (buttonType === 'download') {
                      // Try the direct sharing first
                      if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                          await navigator.share({
                            files: [file],
                            title: 'My Point Card'
                          });
                          
                          // Increment download count
                          cardDownloadCount++;
                          localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                          showAlert(`Card shared successfully!`, 'success');
                        } catch (shareError) {
                          // Only show error if not an abort
                          if (shareError.name !== 'AbortError') {
                            console.error('Share error:', shareError);
                            
                            // Fallback to traditional download
                            const blobUrl = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = blobUrl;
                            link.download = `mypointcard.${fileExtension}`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(blobUrl);
                            
                            cardDownloadCount++;
                            localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                            showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, 'success');
                          }
                        }
                      } else {
                        // Fallback for browsers without share API
                        const blobUrl = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = blobUrl;
                        link.download = `mypointcard.${fileExtension}`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(blobUrl);
                        
                        cardDownloadCount++;
                        localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                        showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, 'success');
                      }
                    } else if (buttonType === 'twitter') {
                      // For Twitter, try to share directly if sharing API is available
                      if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                          await navigator.share({
                            files: [file],
                            title: 'My Point Card',
                            text: 'Check out my card created with MyPointCards!'
                          });
                          cardDownloadCount++;
                          localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                          showAlert(`Card shared successfully!`, 'success');
                        } catch (shareError) {
                          // Only show error if not an abort
                          if (shareError.name !== 'AbortError') {
                            // Fallback: Download file and open Twitter
                            const blobUrl = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = blobUrl;
                            link.download = `mypointcard.${fileExtension}`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            URL.revokeObjectURL(blobUrl);
                            
                            window.open('https://x.com/compose/tweet', '_blank');
                            cardDownloadCount++;
                            localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                            showAlert(`Card saved as ${fileExtension.toUpperCase()}! Please upload it to your X post.`, 'success');
                          }
                        }
                      } else {
                        // Fallback for browsers without share API
                        const blobUrl = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = blobUrl;
                        link.download = `mypointcard.${fileExtension}`;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(blobUrl);
                        
                        window.open('https://x.com/compose/tweet', '_blank');
                        cardDownloadCount++;
                        localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                        showAlert(`Card saved as ${fileExtension.toUpperCase()}! Please upload it to your X post.`, 'success');
                      }
                    }
                  } finally {
                    // Re-enable the button after processing completes
                    restoreStyles();
                    button.disabled = false;
                    button.innerHTML = originalButtonText;
                  }
                }, mimeType, quality);
              } catch (err) {
                console.error('Error processing canvas on iOS:', err);
                showAlert('Unable to process image. Try using a solid color background.', 'warning');
                restoreStyles();
                button.disabled = false;
                button.innerHTML = originalButtonText;
              }
            } else {
              // For other browsers, use standard html2canvas with some optimizations
              const canvas = await html2canvas(cardPreview, {
                allowTaint: false,
                useCORS: true,
                scale: 2,
                backgroundColor: selectedFormat === 'jpg' ? '#ffffff' : null,
                logging: false
              });
              
              // Use toBlob for non-iOS browsers
              canvas.toBlob(function(blob) {
                try {
                  // Create download link
                  const link = document.createElement('a');
                  link.href = URL.createObjectURL(blob);
                  link.download = `mypointcard.${fileExtension}`;
                  document.body.appendChild(link);
                  link.click();
                  document.body.removeChild(link);
                  URL.revokeObjectURL(link.href);
                  
                  // Increment download count
                  cardDownloadCount++;
                  localStorage.setItem('myPointCardDownloadCount', cardDownloadCount.toString());
                  
                  // If it's Twitter, also open Twitter
                  if (buttonType === 'twitter') {
                    window.open('https://x.com/compose/tweet', '_blank');
                    showAlert(`Card saved as ${selectedFormat.toUpperCase()}! Please upload it to your X post.`, 'success');
                  } else {
                    showAlert(`Card downloaded as ${fileExtension.toUpperCase()}`, 'success');
                  }
                } catch (err) {
                  console.error('Error generating download:', err);
                  showAlert('Unable to save image. Please try again.', 'warning');
                } finally {
                  restoreStyles();
                  button.disabled = false;
                  button.innerHTML = originalButtonText;
                }
              }, mimeType, quality);
            }
          } catch (err) {
            console.error('Error generating image:', err);
            restoreStyles();
            
            // Show a more helpful error message
            showAlert('Could not generate image. Try using a solid color background instead of an image.', 'warning');
            
            button.disabled = false;
            button.innerHTML = originalButtonText;
          }
        }


        // Add this function for showing a loading overlay on iOS
        function showIOSLoadingOverlay(message = 'Processing...') {
          // Create overlay element
          const overlay = document.createElement('div');
          overlay.style.position = 'fixed';
          overlay.style.top = '0';
          overlay.style.left = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          overlay.style.backgroundColor = 'rgba(0,0,0,0.8)';
          overlay.style.display = 'flex';
          overlay.style.justifyContent = 'center';
          overlay.style.alignItems = 'center';
          overlay.style.flexDirection = 'column';
          overlay.style.zIndex = '9999';
          
          // Create spinner
          const spinner = document.createElement('div');
          spinner.style.width = '40px';
          spinner.style.height = '40px';
          spinner.style.border = '4px solid rgba(255,255,255,0.3)';
          spinner.style.borderTop = '4px solid white';
          spinner.style.borderRadius = '50%';
          spinner.style.animation = 'spin 1s linear infinite';
          
          // Add animation style
          const style = document.createElement('style');
          style.textContent = '@keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }';
          document.head.appendChild(style);
          
          // Create message
          const messageDiv = document.createElement('div');
          messageDiv.style.color = 'white';
          messageDiv.style.marginTop = '15px';
          messageDiv.textContent = message;
          
          // Add elements to overlay
          overlay.appendChild(spinner);
          overlay.appendChild(messageDiv);
          document.body.appendChild(overlay);
          
          // Return function to hide overlay
          return function() {
            document.body.removeChild(overlay);
          };
        }

        // Add a new function for Featured Images that works better on iOS
        async function applyFeaturedImageIOSFriendly(imageUrl) {
          try {
            // Show loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.style.position = 'absolute';
            loadingOverlay.style.top = '0';
            loadingOverlay.style.left = '0';
            loadingOverlay.style.width = '100%';
            loadingOverlay.style.height = '100%';
            loadingOverlay.style.background = 'rgba(0,0,0,0.5)';
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.justifyContent = 'center';
            loadingOverlay.style.alignItems = 'center';
            loadingOverlay.style.zIndex = '10';
            loadingOverlay.style.borderRadius = '12px';
            loadingOverlay.innerHTML = '<div class="spinner-border text-light" role="status"></div>';
            
            cardPreview.style.position = 'relative';
            cardPreview.appendChild(loadingOverlay);
            
            // For iOS Safari, first try to convert to a Data URL
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
            const isIOSSafari = isIOS && isSafari;
            
            if (isIOSSafari) {
              try {
                // Create a new Image object
                const img = new Image();
                img.crossOrigin = 'anonymous';
                
                // Create a Promise to handle the image loading
                const dataUrl = await new Promise((resolve, reject) => {
                  img.onload = function() {
                    // Create a canvas to convert the image
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    // Draw the image to the canvas
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    
                    // Get the data URL
                    try {
                      const dataUrl = canvas.toDataURL('image/png');
                      resolve(dataUrl);
                    } catch (err) {
                      reject(err);
                    }
                  };
                  
                  img.onerror = function() {
                    reject(new Error('Failed to load image'));
                  };
                  
                  // Set a timeout to avoid hanging
                  setTimeout(() => {
                    reject(new Error('Image loading timed out'));
                  }, 5000);
                  
                  // Start loading the image
                  img.src = imageUrl;
                });
                
                // Apply the data URL as a background
                cardPreview.style.backgroundImage = `url(${dataUrl})`;
              } catch (err) {
                console.warn('Failed to create data URL, falling back to direct URL:', err);
                cardPreview.style.backgroundImage = `url(${imageUrl})`;
              }
            } else {
              // For other browsers, just use the URL directly
              cardPreview.style.backgroundImage = `url(${imageUrl})`;
            }
            
            // Setup the background
            cardPreview.style.backgroundSize = 'contain';
            cardPreview.style.backgroundPosition = 'center';
            cardPreview.style.backgroundRepeat = 'no-repeat';
            
            // Update state
            hasBackgroundImage = true;
            backgroundImageSource = 'featured';
            
            // Reset position
            cardPreview.style.backgroundPosition = '50% 50%';
            initialBgPosX = 50;
            initialBgPosY = 50;
            currentBgPosX = 50;
            currentBgPosY = 50;
            
            // Show background controls
            showBackgroundControls();
            
            // Update cursor
            updateCursorStyle();
            
            // Apply background darkness
            applyBackgroundDarkness();
            
            return true;
          } catch (error) {
            console.error('Error applying featured image:', error);
            return false;
          } finally {
            // Remove any loading overlays
            const loadingOverlay = cardPreview.querySelector('div[style*="background: rgba(0,0,0,0.5)"]');
            if (loadingOverlay) {
              cardPreview.removeChild(loadingOverlay);
            }
          }
        }

        // Create a function to update the Featured Images to use the iOS-friendly function
        function updateFeaturedImageHandlers() {
          const featuredImgs = document.querySelectorAll('.featured-image');
          featuredImgs.forEach(img => {
            // Clone and replace to remove old event listeners
            const newImg = img.cloneNode(true);
            img.parentNode.replaceChild(newImg, img);
            
            // Add new event listener that uses the iOS-friendly function
            newImg.addEventListener('click', async () => {
              const imageUrl = newImg.dataset.originalUrl || newImg.src;
              const success = await applyFeaturedImageIOSFriendly(imageUrl);
              
              if (success) {
                showAlert('Featured image applied as background!', 'success');
              } else {
                showAlert('Could not apply image. Try another one.', 'warning');
              }
            });
          });
        }

        // Helper function for detecting iOS device
        function isIOSDevice() {
          return /iPhone|iPad|iPod/i.test(navigator.userAgent) && 
                 !window.MSStream; // Exclude iPad with Windows
        }


        // Update download button to show "Share" on mobile and "Download" on desktop
        function updateButtonLabels() {
          const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          
          if (isMobileDevice) {
            // Change download button to "Share"
            downloadBtn.innerHTML = '<i class="fas fa-share-alt"></i> Share';
            
            // Hide Twitter button on mobile
            if (twitterBtn) {
              twitterBtn.style.display = 'none';
            }
            
          } else {
            // Desktop button labels
            downloadBtn.innerHTML = '<i class="fas fa-download"></i> Download';
            
            // Ensure Twitter button is visible on desktop
            // if (twitterBtn) {
            //   twitterBtn.style.display = 'block';
            // }
          }
        }

        // Initialize all sharing functionality - simplest version
        function initializeSharing() {
          // Make sure share modal exists in the DOM
          // ensureShareModalExists();
          
          // Update button labels based on device
          updateButtonLabels();
          
          // Replace the onclick handlers directly
          downloadBtn.onclick = function(e) {
            e.preventDefault();
            handleImageExport('download');
          };
          
          twitterBtn.onclick = function(e) {
            e.preventDefault();
            handleImageExport('twitter');
          };
        }

        function setupInlineTextEditing() {
          // Add double-click handler to the previewText
          previewText.addEventListener('dblclick', function(e) {
            e.stopPropagation();
            
            // Get current styles before making the element editable
            const currentStyles = {
              fontFamily: previewText.style.fontFamily,
              fontSize: previewText.style.fontSize,
              color: previewText.style.color,
              textAlign: previewText.style.textAlign,
              textShadow: previewText.style.textShadow,
              lineHeight: previewText.style.lineHeight,
              fontWeight: previewText.style.fontWeight
            };
            
            // Store original position and styling
            const originalPosition = {
              left: previewText.style.left,
              top: previewText.style.top,
              transform: previewText.style.transform
            };
            
            // Store original text
            const originalText = previewText.innerText;
            
            // Make the element editable
            previewText.setAttribute('contenteditable', 'true');
            previewText.focus();
            
            // Select all text
            const selection = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(previewText);
            selection.removeAllRanges();
            selection.addRange(range);
            
            // Add a visual indicator that the text is being edited
            previewText.style.outline = '2px dashed rgba(255, 255, 255, 0.7)';
            previewText.style.outlineOffset = '4px';
            previewText.style.cursor = 'text';
            
            // Show a small helper message
            const editingMessage = document.createElement('div');
            editingMessage.innerHTML = 'Editing text... <br>Press Enter to save or Escape to cancel';
            editingMessage.style.position = 'absolute';
            editingMessage.style.bottom = '10px';
            editingMessage.style.left = '50%';
            editingMessage.style.transform = 'translateX(-50%)';
            editingMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            editingMessage.style.color = 'white';
            editingMessage.style.padding = '8px 12px';
            editingMessage.style.borderRadius = '4px';
            editingMessage.style.fontSize = '12px';
            editingMessage.style.textAlign = 'center';
            editingMessage.style.zIndex = '1000';
            editingMessage.id = 'editing-message';
            
            cardPreview.appendChild(editingMessage);
            // Set a timeout to auto-dismiss the editing message after 5 seconds
            setTimeout(() => {
                const message = document.getElementById('editing-message');
                if (message) {
                    message.remove();
                }
            }, 5000);

            
            // Function to apply changes and sync with textarea
            function applyChanges() {
              const newText = previewText.innerText.trim();
              
              // Update textarea with the new text from preview
              cardText.value = newText;
              
              // Remove contenteditable attribute
              previewText.removeAttribute('contenteditable');
              
              // Restore cursor style
              previewText.style.cursor = 'move';
              
              // Remove outline
              previewText.style.outline = 'none';
              
              // Remove helper message
              const message = document.getElementById('editing-message');
              if (message) {
                message.remove();
              }
              
              // Reset original styling
              for (const [property, value] of Object.entries(currentStyles)) {
                previewText.style[property] = value;
              }
              
              // Re-apply original position
              previewText.style.left = originalPosition.left;
              previewText.style.top = originalPosition.top;
              previewText.style.transform = originalPosition.transform;
              
              // Save the changes to preferences
              savePreferences();
            }
            
            // Function to cancel changes
            function cancelChanges() {
              // Restore the original text
              previewText.innerText = originalText;
              
              // Remove contenteditable
              previewText.removeAttribute('contenteditable');
              
              // Restore cursor style
              previewText.style.cursor = 'move';
              
              // Remove outline
              previewText.style.outline = 'none';
              
              // Remove helper message
              const message = document.getElementById('editing-message');
              if (message) {
                message.remove();
              }
              
              // Reset original styling
              for (const [property, value] of Object.entries(currentStyles)) {
                previewText.style[property] = value;
              }
              
              // Re-apply original position
              previewText.style.left = originalPosition.left;
              previewText.style.top = originalPosition.top;
              previewText.style.transform = originalPosition.transform;
            }
            
            // Handle Enter key to save changes
            previewText.addEventListener('keydown', function(evt) {
              if (evt.key === 'Enter' && !evt.shiftKey) {
                evt.preventDefault();
                applyChanges();
              } else if (evt.key === 'Escape') {
                evt.preventDefault();
                cancelChanges();
              }
            }, { once: true });
            
            // Handle clicking outside to save changes
            function handleClickOutside(evt) {
              if (!previewText.contains(evt.target) && previewText.getAttribute('contenteditable') === 'true') {
                applyChanges();
                document.removeEventListener('mousedown', handleClickOutside);
              }
            }
            
            // Add the click outside listener after a short delay to avoid immediate trigger
            setTimeout(() => {
              document.addEventListener('mousedown', handleClickOutside);
            }, 100);
          });
        }

        function addFormatSelection() {
          // Find the text tab content
          const textTab = document.getElementById('text');
          
          // Create the format selection section
          const formatSection = document.createElement('div');
          formatSection.className = 'mb-3 mt-4';
          formatSection.innerHTML = `
            <label class="form-label">Download As:</label>
            <div class="d-flex flex-wrap">
              <div class="form-check me-3">
                <input class="form-check-input" type="radio" name="imageFormat" id="formatWebP" value="webp" checked>
                <label class="form-check-label" for="formatWebP">
                  WebP
                </label>
              </div>
              <div class="form-check me-3">
                <input class="form-check-input" type="radio" name="imageFormat" id="formatPNG" value="png">
                <label class="form-check-label" for="formatPNG">
                  PNG 
                </label>
              </div>
              <div class="form-check">
                <input class="form-check-input" type="radio" name="imageFormat" id="formatJPG" value="jpg">
                <label class="form-check-label" for="formatJPG">
                  JPG
                </label>
              </div>
            </div>
          `;
          
          // Find where to insert this section (before the closing tag of the text tab)
          const existingDivs = textTab.querySelectorAll('.mb-3');
          if (existingDivs.length > 0) {
            const lastDiv = existingDivs[existingDivs.length - 1];
            lastDiv.parentNode.insertBefore(formatSection, lastDiv.nextSibling);
          } else {
            textTab.appendChild(formatSection);
          }
          
          // Add to savePreferences function
          const originalSavePreferences = savePreferences;
          savePreferences = function() {
            originalSavePreferences();
            
            // Save selected format
            const selectedFormat = document.querySelector('input[name="imageFormat"]:checked').value;
            localStorage.setItem('myPointCardImageFormat', selectedFormat);
          }
          
          // Add to loadSavedPreferences function
          const originalLoadSavedPreferences = loadSavedPreferences;
          loadSavedPreferences = function() {
            originalLoadSavedPreferences();
            
            // Load saved format preference
            const savedFormat = localStorage.getItem('myPointCardImageFormat');
            if (savedFormat) {
              const formatRadio = document.getElementById('format' + savedFormat.toUpperCase().charAt(0) + savedFormat.slice(1));
              if (formatRadio) {
                formatRadio.checked = true;
              }
            }
          }
        }


        function makeTextDraggable() {
          previewText.style.position = 'absolute';
          previewText.style.transform = 'translate(-50%, -50%)';
          previewText.style.left = '50%';
          previewText.style.top = '50%';
          previewText.style.cursor = 'move';
          
          // Update the tooltip to include double-click information
          previewText.title = "Drag to reposition or double-click to edit text";
          
          // Add visual indicator when hovering
          previewText.addEventListener('mouseover', function() {
            if (previewText.style.boxShadow !== '0 0 8px rgba(0, 123, 255, 0.5)') {
              previewText.dataset.originalBoxShadow = previewText.style.boxShadow;
              previewText.style.boxShadow = '0 0 8px rgba(0, 123, 255, 0.5)';
            }
          });
          
          previewText.addEventListener('mouseout', function() {
            if (!textIsDragging && previewText.dataset.originalBoxShadow !== undefined) {
              previewText.style.boxShadow = previewText.dataset.originalBoxShadow;
            }
          });
        }

        function setupTextDragging() {
          // Mouse events
          previewText.addEventListener('mousedown', function(e) {
            textIsDragging = true;
            textDragStartX = e.clientX;
            textDragStartY = e.clientY;
            
            // Get current position
            const rect = cardPreview.getBoundingClientRect();
            const textRect = previewText.getBoundingClientRect();
            
            // Calculate current position in percentage
            textPosX = ((textRect.left + textRect.width/2) - rect.left) / rect.width * 100;
            textPosY = ((textRect.top + textRect.height/2) - rect.top) / rect.height * 100;
            
            // Change cursor to indicate dragging
            previewText.style.cursor = 'grabbing';
            
            // Stop event propagation to prevent the card preview's drag handler from triggering
            e.stopPropagation();
            e.preventDefault();
          });
          
          document.addEventListener('mousemove', function(e) {
            if (textIsDragging) {
              const deltaX = e.clientX - textDragStartX;
              const deltaY = e.clientY - textDragStartY;
              
              const rect = cardPreview.getBoundingClientRect();
              
              // Update position in percentages
              const newPosX = textPosX + (deltaX / rect.width * 100);
              const newPosY = textPosY + (deltaY / rect.height * 100);
              
              // Apply constraints to keep text within bounds
              const boundedX = Math.min(Math.max(newPosX, 10), 90);
              const boundedY = Math.min(Math.max(newPosY, 10), 90);
              
              // Update position
              previewText.style.left = boundedX + '%';
              previewText.style.top = boundedY + '%';
              
              // Save new positions for when dragging ends
              textPosX = boundedX;
              textPosY = boundedY;
              
              textDragStartX = e.clientX;
              textDragStartY = e.clientY;
              
              // Stop event propagation
              e.stopPropagation();
            }
          });
          
          document.addEventListener('mouseup', function(e) {
            if (textIsDragging) {
              textIsDragging = false;
              previewText.style.cursor = 'move';
              
              // Save the position to preferences
              savePreferences();
              
              // Restore normal box shadow
              if (previewText.dataset.originalBoxShadow !== undefined) {
                previewText.style.boxShadow = previewText.dataset.originalBoxShadow;
              }
              
              // Stop event propagation only if we were dragging text
              e.stopPropagation();
            }
          });
          
          // Touch events for mobile
          previewText.addEventListener('touchstart', function(e) {
            if (e.touches.length === 1) {
              textIsDragging = true;
              textDragStartX = e.touches[0].clientX;
              textDragStartY = e.touches[0].clientY;
              
              // Calculate current position (same as in mousedown)
              const rect = cardPreview.getBoundingClientRect();
              const textRect = previewText.getBoundingClientRect();
              textPosX = ((textRect.left + textRect.width/2) - rect.left) / rect.width * 100;
              textPosY = ((textRect.top + textRect.height/2) - rect.top) / rect.height * 100;
              
              // Stop event propagation
              e.stopPropagation();
            }
          });
          
          previewText.addEventListener('touchmove', function(e) {
            if (textIsDragging && e.touches.length === 1) {
              const touch = e.touches[0];
              const deltaX = touch.clientX - textDragStartX;
              const deltaY = touch.clientY - textDragStartY;
              
              const rect = cardPreview.getBoundingClientRect();
              
              // Same logic as mousemove
              const newPosX = textPosX + (deltaX / rect.width * 100);
              const newPosY = textPosY + (deltaY / rect.height * 100);
              
              const boundedX = Math.min(Math.max(newPosX, 10), 90);
              const boundedY = Math.min(Math.max(newPosY, 10), 90);
              
              previewText.style.left = boundedX + '%';
              previewText.style.top = boundedY + '%';
              
              textPosX = boundedX;
              textPosY = boundedY;
              
              textDragStartX = touch.clientX;
              textDragStartY = touch.clientY;
              
              // Stop event propagation and prevent scrolling
              e.stopPropagation();
              e.preventDefault();
            }
          });
          
          previewText.addEventListener('touchend', function(e) {
            if (textIsDragging) {
              textIsDragging = false;
              savePreferences();
              
              // Stop event propagation
              e.stopPropagation();
            }
          });
          
          previewText.addEventListener('touchcancel', function(e) {
            textIsDragging = false;
            e.stopPropagation();
          });
        }

        function setupUserActivityTracking() {
            // Reset activity timer whenever user interacts with the page
            document.addEventListener('mousemove', resetUserActivityTimer);
            document.addEventListener('mousedown', resetUserActivityTimer);
            document.addEventListener('keypress', resetUserActivityTimer);
            document.addEventListener('scroll', resetUserActivityTimer);
            document.addEventListener('touchstart', resetUserActivityTimer);
            
            // Initialize the activity timer
            resetUserActivityTimer();
        }

        function resetUserActivityTimer() {
            // User is active now
            if (!isUserActive) {
                // If user was inactive and now active, restart the timer
                isUserActive = true;
                appStartTime = new Date();
            }
            
            // Clear any existing timeout
            if (userActivityTimeout) {
                clearTimeout(userActivityTimeout);
            }
            
            // Set a new timeout
            userActivityTimeout = setTimeout(function() {
                // User has been inactive for the timeout period
                if (isUserActive && appStartTime) {
                    // Save the time elapsed since they were last active
                    const now = new Date();
                    const sessionTime = Math.floor((now - appStartTime) / 1000);
                    totalTimeSpent += sessionTime;
                    localStorage.setItem('myPointCardTimeSpent', totalTimeSpent.toString());
                    appStartTime = null;
                    isUserActive = false;
                    
                    // Update the display
                    const count = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
                    const downloads = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
                    updateUsageStats(count, totalTimeSpent, downloads);
                }
            }, INACTIVITY_TIMEOUT);
        }


        function initUsageCounter() {

            // Skip if tracking is disabled
            if (ENABLE_USAGE_TRACKING !== 'yes') return;


            // Get current count from localStorage
            const usageCount = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
            
            // Increment by 1 for this session
            const newUsageCount = usageCount + 1;
            
            // Store the incremented value back
            localStorage.setItem('myPointCardUsageCount', newUsageCount.toString());
            
            // Load time spent
            totalTimeSpent = parseInt(localStorage.getItem('myPointCardTimeSpent') || '0');
            
            // Load download count - NEW
            cardDownloadCount = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
            
            // Update the display
            updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);
        }


        // Add this function to handle time formatting
        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Update the loadSavedPreferences function to load usage data
        function loadSavedPreferences() {


            const savedLineHeight = localStorage.getItem('myPointCardLineHeight');
            if (savedLineHeight) {
                lineHeight.value = savedLineHeight;
                lineHeightValue.textContent = savedLineHeight;
                previewText.style.lineHeight = savedLineHeight;
            }

            const savedPoweredBy = localStorage.getItem('myPointCardPoweredBy');
            if (savedPoweredBy !== null) {
                const showPoweredBy = savedPoweredBy === 'true';
                poweredBy.checked = showPoweredBy;
                poweredByText.style.display = showPoweredBy ? 'block' : 'none';
            }
            
            // Other existing preferences loading...
            const savedFontFamily = localStorage.getItem('myPointCardFontFamily');
            if (savedFontFamily) {
                fontFamily.value = savedFontFamily;
                previewText.style.fontFamily = savedFontFamily;
            }
            
            const savedFontSize = localStorage.getItem('myPointCardFontSize');
            if (savedFontSize) {
                fontSize.value = savedFontSize;
                fontSizeValue.textContent = savedFontSize;
                previewText.style.fontSize = `${savedFontSize}px`;
            }
            
            const savedFontColor = localStorage.getItem('myPointCardFontColor');
            if (savedFontColor) {
                fontColor.value = savedFontColor;
                fontColorHex.textContent = savedFontColor;
                previewText.style.color = savedFontColor;
            }
            
            const savedTextShadow = localStorage.getItem('myPointCardTextShadow');
            if (savedTextShadow !== null) {
                const useTextShadow = savedTextShadow === 'true';
                textShadow.checked = useTextShadow;
                previewText.style.textShadow = useTextShadow ? '0 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
            }

            // Load text alignment preference
            const savedTextAlign = localStorage.getItem('myPointCardTextAlign');
            if (savedTextAlign) {
                switch(savedTextAlign) {
                    case 'left':
                        alignLeft.checked = true;
                        previewText.style.textAlign = 'left';
                        break;
                    case 'right':
                        alignRight.checked = true;
                        previewText.style.textAlign = 'right';
                        break;
                    default:
                        alignCenter.checked = true;
                        previewText.style.textAlign = 'center';
                }
            } else {
                // Default to center if no preference is saved
                alignCenter.checked = true;
                previewText.style.textAlign = 'center';
            }

            // Load usage tracking data
            const usageCount = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
            const timeSpent = localStorage.getItem('myPointCardTimeSpent') || 0;

             // Load download count
             cardDownloadCount = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
    

            
            // Update usage count and display it
            const newUsageCount = parseInt(usageCount) + 1;
            localStorage.setItem('myPointCardUsageCount', newUsageCount.toString());
            totalTimeSpent = parseInt(timeSpent);
            
            // Update the UI to show usage stats with download count
            updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);

            const savedTextPosX = localStorage.getItem('myPointCardTextPosX');
            const savedTextPosY = localStorage.getItem('myPointCardTextPosY');
          
            if (savedTextPosX && savedTextPosY) {
                textPosX = parseFloat(savedTextPosX);
                textPosY = parseFloat(savedTextPosY);
                previewText.style.left = textPosX + '%';
                previewText.style.top = textPosY + '%';
             }

        }

        function updateUsageStats(count, timeInSeconds, downloads) {
            if (ENABLE_USAGE_TRACKING !== 'yes') return;

            const formattedTime = formatTime(timeInSeconds);
            
            // Find the container first - this is a crucial part
            const footerContainer = document.querySelector('.footer-container');
            if (!footerContainer) return;
            
            // Check if the stats element already exists
            let statsElement = document.getElementById('usageStats');
            
            if (!statsElement) {
                // Create a new element if it doesn't exist
                statsElement = document.createElement('p');
                statsElement.id = 'usageStats';
                statsElement.className = 'text-muted';
                statsElement.style.fontSize = '0.75em';
                statsElement.style.color = '#6c757d';
                statsElement.style.margin = '0';
                statsElement.style.marginTop = '5px';
                
                // Make sure to append to the container
                footerContainer.appendChild(statsElement);
            }
            
            // Update the text with download count
            statsElement.textContent = `Loaded ${count} times for ${formattedTime} & created ${downloads} cards`;
        }

        function startTimeTracking() {

             // Skip if tracking is disabled
            if (ENABLE_USAGE_TRACKING !== 'yes') return;

            appStartTime = new Date();
            isUserActive = true;
            
            // Set up event handlers for tracking when user leaves/closes
            window.addEventListener('beforeunload', stopTimeTracking);
            document.addEventListener('visibilitychange', handleVisibilityChange);
            
            // Set up activity tracking
            setupUserActivityTracking();
        }

        function handleVisibilityChange() {
            if (document.hidden) {
                // User switched tabs or minimized window
                if (isUserActive && appStartTime) {
                    const now = new Date();
                    const sessionTime = Math.floor((now - appStartTime) / 1000);
                    totalTimeSpent += sessionTime;
                    localStorage.setItem('myPointCardTimeSpent', totalTimeSpent.toString());
                    appStartTime = null;
                    isUserActive = false;
                }
            } else {
                // User returned to tab - reset activity timer
                resetUserActivityTimer();
            }
        }
        function stopTimeTracking() {

            // Skip if tracking is disabled
            if (ENABLE_USAGE_TRACKING !== 'yes') return;

            if (appStartTime) {
                const now = new Date();
                const sessionTime = Math.floor((now - appStartTime) / 1000); // Time in seconds
                appStartTime = null;
                
                // Update total time
                totalTimeSpent += sessionTime;
                localStorage.setItem('myPointCardTimeSpent', totalTimeSpent);
                
                // Update the stats display
                const count = parseInt(localStorage.getItem('myPointCardUsageCount') || '1');
                const downloads = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
                updateUsageStats(count, totalTimeSpent, downloads);
            }
        }


        // Add CSS class for dragging indicator
        function addDraggingStyleIfNeeded() {
            // Check if the style already exists
            if (!document.getElementById('draggingStyle')) {
                const style = document.createElement('style');
                style.id = 'draggingStyle';
                style.textContent = `
                    .card-preview.dragging {
                        cursor: move !important;
                        cursor: grabbing !important;
                        border: 2px dashed rgba(255, 255, 255, 0.5) !important;
                    }
                    
                    .card-preview:hover {
                        cursor: ${hasBackgroundImage ? 'grab' : 'default'};
                    }
                    
                    @media (max-width: 768px) {
                        #dragHint {
                            padding: 8px;
                            background-color: rgba(0, 0, 0, 0.05);
                            border-radius: 4px;
                            font-weight: 500;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }


        // Call this function when the page loads
        document.addEventListener('DOMContentLoaded', function() {


            // Add CSS for the usage stats
            const style = document.createElement('style');
            style.textContent = `
                #usageStats {
                    color: #6c757d;
                    font-size: 0.8em;
                    margin-top: 0.25rem;
                }
                
                [data-bs-theme="dark"] #usageStats {
                    color: #adb5bd;
                }
            `;
            document.head.appendChild(style);

            // Only set up the interval if tracking is enabled
            if (ENABLE_USAGE_TRACKING === 'yes') {
                setInterval(function() {
                    if (appStartTime) {
                        const sessionTime = Math.floor((new Date() - appStartTime) / 1000);
                        const displayTime = totalTimeSpent + sessionTime;
                        const count = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
                        const downloads = parseInt(localStorage.getItem('myPointCardDownloadCount') || '0');
                        updateUsageStats(parseInt(count), displayTime, downloads);
                    }
                }, 1000);
            }


          setupClipboardPaste();


          initializeApp();


          // First clean up any existing toggles
          cleanupExistingToggles();
          
          // Then set up a fresh one
          setupTextOptionsToggle();
          
          // Handle tab switching
          const textTab = document.getElementById('text-tab');
          if (textTab) {
            textTab.addEventListener('click', function() {
              // Clean up first, then set up
              setTimeout(function() {
                cleanupExistingToggles();
                setupTextOptionsToggle();
              }, 100);
            });
          }
          
          // Handle window resize
          let resizeTimer;
          window.addEventListener('resize', function() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(function() {
              // If switching between desktop and mobile views
              const isMobile = window.innerWidth <= 768;
              
              if (isMobile) {
                // On mobile, clean up and recreate the toggle
                cleanupExistingToggles();
                setupTextOptionsToggle();
              } else {
                // On desktop, just clean up any toggles
                cleanupExistingToggles();
              }
            }, 250);
          });


        });


        // Update cursor style when background image status changes
        function updateCursorStyle() {
            if (hasBackgroundImage) {
                cardPreview.style.cursor = 'grab';
            } else {
                cardPreview.style.cursor = 'default';
            }
        }

        if (isMobile) {
            // Create tip element
            const mobileTip = document.createElement('div');
            mobileTip.id = 'mobileInfoTip';
            mobileTip.textContent = 'Tap an image to use it as background';
            document.body.appendChild(mobileTip);
            
            // Show tip when featured tab is clicked on mobile
            featuredTab.addEventListener('click', function() {
                if (mobileTip) {
                    mobileTip.style.display = 'block';
                    setTimeout(() => {
                        mobileTip.style.display = 'none';
                    }, 3000);
                }
            });
            
            // Modify the featured image display function to show image info differently on mobile
            const originalDisplayFeaturedImages = displayFeaturedImages;
            displayFeaturedImages = function(images, searchTerm = '') {
                originalDisplayFeaturedImages(images, searchTerm);
                
                if (isMobile) {
                    // Add long-press handler to show info for mobile
                    const featuredImgs = document.querySelectorAll('.featured-image');
                    featuredImgs.forEach(img => {
                        let pressTimer;
                        
                        img.addEventListener('touchstart', function(e) {
                            pressTimer = setTimeout(function() {
                                // Get the category and tags from the parent container
                                const infoDiv = img.parentElement.querySelector('.image-info');
                                if (infoDiv) {
                                    const infoText = infoDiv.textContent.trim();
                                    alert(`Image Info: ${infoText}`);
                                }
                            }, 800); // Long press threshold - 800ms
                        });
                        
                        img.addEventListener('touchend', function() {
                            clearTimeout(pressTimer);
                        });
                        
                        img.addEventListener('touchmove', function() {
                            clearTimeout(pressTimer);
                        });
                    });
                }
            };
        }

        function applyBackgroundDarkness() {
            if (hasBackgroundImage) {
                const opacity = parseInt(bgOpacity.value);
                bgOpacityValue.textContent = opacity;
                
                // Get the current background image style
                let bgImageUrl = cardPreview.style.backgroundImage;
                
                // If it already has a linear gradient, extract just the URL part
                if (bgImageUrl.includes('linear-gradient')) {
                    // Find where the URL starts (after the gradient)
                    const urlStartIndex = bgImageUrl.lastIndexOf('url(');
                    if (urlStartIndex !== -1) {
                        bgImageUrl = bgImageUrl.substring(urlStartIndex);
                    }
                }
                
                // Apply the appropriate background image based on the opacity setting
                if (opacity === 0) {
                    // If opacity is 0, use just the image without any darkness overlay
                    cardPreview.style.backgroundImage = bgImageUrl;
                } else {
                    // Apply the gradient overlay with specified opacity
                    cardPreview.style.backgroundImage = 
                        `linear-gradient(rgba(0,0,0,${opacity/100}), rgba(0,0,0,${opacity/100})), ${bgImageUrl}`;
                }
            }
        }


        // Hook this into existing functions that change background image status
        const originalApplyBackgroundDarkness = applyBackgroundDarkness;
        applyBackgroundDarkness = function() {
            originalApplyBackgroundDarkness();
            updateCursorStyle();
        };

        // Ensure we update cursor style after removing background images too
        const originalRemoveImage = removeImage.onclick;
        removeImage.onclick = function() {
            if (typeof originalRemoveImage === 'function') {
                originalRemoveImage();
            } else {
                // Fallback - copy existing functionality
                imageUpload.value = '';
                uploadPreview.classList.add('d-none');
                cardPreview.style.backgroundImage = 'none';
                hasBackgroundImage = false;
                backgroundImageSource = null;
                
                const activeColorBox = document.querySelector('.color-box.active');
                if (activeColorBox) {
                    cardPreview.style.backgroundColor = activeColorBox.getAttribute('data-color');
                } else {
                    cardPreview.style.backgroundColor = customColor.value;
                }
                
                hideBackgroundControls();
                showAlert('Image removed!', 'info');
            }
            updateCursorStyle();
        };


        // Show controls when an image is selected
        function showBackgroundControls() {
            backgroundControls.style.display = 'block';
            
            // Add a hint about dragging functionality
            const dragHint = document.getElementById('dragHint') || document.createElement('div');
            dragHint.id = 'dragHint';
            dragHint.className = 'mt-2 small text-muted';
            // Enhanced message depending on device
            if (isMobile) {
                dragHint.innerHTML = '<i class="fas fa-hand-point-up"></i> You can drag on the card to position the image precisely';
            } else {
                dragHint.innerHTML = '<i class="fas fa-mouse-pointer"></i> You can drag on the card to position the image precisely';
            }
            
            
            if (!document.getElementById('dragHint')) {
                backgroundControls.appendChild(dragHint);
            }
        }

        // Hide controls when no image is selected
        function hideBackgroundControls() {
            backgroundControls.style.display = 'none';
        }

        // Load saved preferences from localStorage
        function loadSavedPreferences() {

            // Fix the counter logic
            const usageCount = parseInt(localStorage.getItem('myPointCardUsageCount') || '0');
            
            // Increment by 1 for this session
            const newUsageCount = usageCount + 1;
            
            // Store the incremented value back
            localStorage.setItem('myPointCardUsageCount', newUsageCount.toString());

            // Check if poweredBy preference is saved
            const savedPoweredBy = localStorage.getItem('myPointCardPoweredBy');
            if (savedPoweredBy !== null) {
                const showPoweredBy = savedPoweredBy === 'true';
                poweredBy.checked = showPoweredBy;
                poweredByText.style.display = showPoweredBy ? 'block' : 'none';
            }
            
            // Check if font preferences are saved
            const savedFontFamily = localStorage.getItem('myPointCardFontFamily');
            if (savedFontFamily) {
                fontFamily.value = savedFontFamily;
                previewText.style.fontFamily = savedFontFamily;
            }
            
            const savedFontSize = localStorage.getItem('myPointCardFontSize');
            if (savedFontSize) {
                fontSize.value = savedFontSize;
                fontSizeValue.textContent = savedFontSize;
                previewText.style.fontSize = `${savedFontSize}px`;
            }
            
            const savedFontColor = localStorage.getItem('myPointCardFontColor');
            if (savedFontColor) {
                fontColor.value = savedFontColor;
                fontColorHex.textContent = savedFontColor;
                previewText.style.color = savedFontColor;
            }
            
            const savedTextShadow = localStorage.getItem('myPointCardTextShadow');
            if (savedTextShadow !== null) {
                const useTextShadow = savedTextShadow === 'true';
                textShadow.checked = useTextShadow;
                previewText.style.textShadow = useTextShadow ? '0 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
            }

            // Load text alignment preference
           const savedTextAlign = localStorage.getItem('myPointCardTextAlign');
           if (savedTextAlign) {
             switch(savedTextAlign) {
              case 'left':
                alignLeft.checked = true;
                previewText.style.textAlign = 'left';
                break;
              case 'right':
                alignRight.checked = true;
                previewText.style.textAlign = 'right';
                break;
              default:
                alignCenter.checked = true;
                previewText.style.textAlign = 'center';
             }
           } else {
             // Default to center if no preference is saved
             alignCenter.checked = true;
             previewText.style.textAlign = 'center';
           }


          // Update the display
          updateUsageStats(newUsageCount, totalTimeSpent, cardDownloadCount);


        }

        // Save preferences to localStorage
        function savePreferences() {
            localStorage.setItem('myPointCardPoweredBy', poweredBy.checked);
            localStorage.setItem('myPointCardFontFamily', fontFamily.value);
            localStorage.setItem('myPointCardFontSize', fontSize.value);
            localStorage.setItem('myPointCardFontColor', fontColor.value);
            localStorage.setItem('myPointCardTextShadow', textShadow.checked);
            localStorage.setItem('myPointCardLineHeight', lineHeight.value);
            localStorage.setItem('myPointCardTextPosX', textPosX);
            localStorage.setItem('myPointCardTextPosY', textPosY);
        }

        // Helper function to show alerts
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type} position-fixed bottom-0 end-0 m-3`;
            alertDiv.innerHTML = message;
            document.body.appendChild(alertDiv);
            
            setTimeout(() => {
                if (document.body.contains(alertDiv)) {
                    document.body.removeChild(alertDiv);
                }
            }, 3000);
        }
        
        // Helper function to calculate Levenshtein distance for typo tolerance
        function levenshteinDistance(a, b) {
            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;
            
            const matrix = [];
            
            // Initialize matrix
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            
            // Fill matrix
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i-1) === a.charAt(j-1)) {
                        matrix[i][j] = matrix[i-1][j-1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i-1][j-1] + 1, // substitution
                            matrix[i][j-1] + 1,   // insertion
                            matrix[i-1][j] + 1    // deletion
                        );
                    }
                }
            }
            
            return matrix[b.length][a.length];
        }


        // Modified version of displayFeaturedImages for better iOS compatibility
        function displayFeaturedImages(images, searchTerm = '', addPagination = true) {
          featuredResults.innerHTML = '';
          
          if (!images || Object.keys(images).length === 0) {
            featuredResults.innerHTML = '<div class="alert alert-info">No featured images available.</div>';
            return;
          }
          
          // Filter images if search term is provided
          let filteredImages = Object.entries(images);
          if (searchTerm) {
            searchTerm = searchTerm.toLowerCase();
            featuredCurrentQuery = searchTerm;
            
            filteredImages = filteredImages.filter(([id, image]) => {
              // Check category
              const category = (image.category || '').toLowerCase();
              if (category.includes(searchTerm) || levenshteinDistance(category, searchTerm) <= 2) return true;
              
              // Check individual categories if it's a comma-separated list
              const categories = category.split(',').map(cat => cat.trim());
              if (categories.some(cat => cat.includes(searchTerm) || levenshteinDistance(cat, searchTerm) <= 2)) return true;
              
              // Check tags
              const tags = (image.tags || '').toLowerCase();
              if (tags.includes(searchTerm) || levenshteinDistance(tags, searchTerm) <= 2) return true;
              
              // Check individual tags if it's a comma-separated list
              const tagList = tags.split(',').map(tag => tag.trim());
              if (tagList.some(tag => tag.includes(searchTerm) || levenshteinDistance(tag, searchTerm) <= 2)) return true;
              
              return false;
            });
          }
          
          // Store the filtered results for pagination
          featuredTotalResults = filteredImages;
          featuredMaxPages = Math.ceil(featuredTotalResults.length / featuredResultsPerPage);
          
          // Calculate start and end indices for current page
          const startIndex = featuredCurrentPage * featuredResultsPerPage;
          const endIndex = startIndex + featuredResultsPerPage;
          
          // Get items for the current page
          const imagesToDisplay = featuredTotalResults.slice(startIndex, endIndex);
          
          if (imagesToDisplay.length === 0) {
            featuredResults.innerHTML = '<div class="alert alert-info">No images match your search. Try a different keyword.</div>';
            return;
          }
          
          // Create a grid container for better layout
          const gridContainer = document.createElement('div');
          gridContainer.className = 'featured-grid';
          gridContainer.style.display = 'grid';
          gridContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
          gridContainer.style.gap = '10px';
          gridContainer.style.marginBottom = '15px';
          
          imagesToDisplay.forEach(([id, image]) => {
            try {
              const imgContainer = document.createElement('div');
              imgContainer.className = 'featured-image-container';
              
              const img = document.createElement('img');
              img.src = image['image-url'];
              img.alt = `Featured image ${id}`;
              img.className = 'featured-image';
              img.loading = 'lazy'; // Lazy load images
              
              // Store the URL as a data attribute for easier access
              img.dataset.originalUrl = image['image-url'];
              
              // Add error handling for images
              img.onerror = function() {
                this.src = 'https://featured.mypoint.cards/assets/water-lily-001.jpg';
                this.alt = 'Image not available';
              };
              
              // Add info tooltip
              const infoDiv = document.createElement('div');
              infoDiv.className = 'image-info';
              infoDiv.innerHTML = `
                <div><i class="fa-solid fa-tag"></i> ${image.category || 'N/A'}</div>
              `;
              
              // Set click event to use image as background
              img.addEventListener('click', async () => {
                await applyBackgroundImage(image['image-url'], 'featured');
                showAlert('Featured image applied as background!', 'success');
              });
              
              imgContainer.appendChild(img);
              imgContainer.appendChild(infoDiv);
              gridContainer.appendChild(imgContainer);
            } catch (err) {
              console.warn('Error displaying featured image:', err);
            }
          });
          
          // Fill empty spots in the grid to maintain 3x3 layout
          const emptySpots = featuredResultsPerPage - imagesToDisplay.length;
          for (let i = 0; i < emptySpots; i++) {
            const emptyDiv = document.createElement('div');
            emptyDiv.style.width = '120px';
            emptyDiv.style.height = '120px';
            gridContainer.appendChild(emptyDiv);
          }
          
          featuredResults.appendChild(gridContainer);
          
          // Add pagination controls if needed
          if (addPagination && featuredTotalResults.length > featuredResultsPerPage) {
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'd-flex justify-content-center mt-3';
            
            const pagination = document.createElement('nav');
            pagination.setAttribute('aria-label', 'Featured results pages');
            
            const pageList = document.createElement('ul');
            pageList.className = 'pagination';
            
            // Previous button
            const prevItem = document.createElement('li');
            prevItem.className = `page-item ${featuredCurrentPage === 0 ? 'disabled' : ''}`;
            
            const prevLink = document.createElement('a');
            prevLink.className = 'page-link';
            prevLink.href = '#';
            prevLink.innerHTML = '&laquo; Previous';
            prevLink.id = 'featuredPrevPage';
            
            prevItem.appendChild(prevLink);
            pageList.appendChild(prevItem);
            
            // Current page info
            const pageInfoItem = document.createElement('li');
            pageInfoItem.className = 'page-item';
            
            const pageInfoSpan = document.createElement('span');
            pageInfoSpan.className = 'page-link';
            const totalPages = Math.min(featuredMaxPages, Math.ceil(featuredTotalResults.length / featuredResultsPerPage) || 1);
            pageInfoSpan.textContent = `Page ${featuredCurrentPage + 1} of ${totalPages}`;
            
            pageInfoItem.appendChild(pageInfoSpan);
            pageList.appendChild(pageInfoItem);
            
            // Next button
            const nextItem = document.createElement('li');
            nextItem.className = `page-item ${
              featuredCurrentPage >= totalPages - 1 || imagesToDisplay.length < featuredResultsPerPage ? 'disabled' : ''
            }`;
            
            const nextLink = document.createElement('a');
            nextLink.className = 'page-link';
            nextLink.href = '#';
            nextLink.innerHTML = 'Next &raquo;';
            nextLink.id = 'featuredNextPage';
            
            nextItem.appendChild(nextLink);
            pageList.appendChild(nextItem);
            
            pagination.appendChild(pageList);
            paginationContainer.appendChild(pagination);
            featuredResults.appendChild(paginationContainer);
            
            // Add event listeners for pagination buttons
            const prevButton = document.getElementById('featuredPrevPage');
            const nextButton = document.getElementById('featuredNextPage');
            
            if (prevButton) {
              prevButton.addEventListener('click', (e) => {
                e.preventDefault();
                if (featuredCurrentPage > 0) {
                  featuredCurrentPage--;
                  displayFeaturedPage(featuredCurrentPage);
                }
              });
            }
            
            if (nextButton) {
              nextButton.addEventListener('click', (e) => {
                e.preventDefault();
                if (featuredCurrentPage < totalPages - 1 && imagesToDisplay.length === featuredResultsPerPage) {
                  featuredCurrentPage++;
                  displayFeaturedPage(featuredCurrentPage);
                }
              });
            }
          }
        }

        function displayFeaturedPage(page = 0) {
            featuredCurrentPage = page;
            displayFeaturedImages(featuredImages, featuredCurrentQuery);
        }


        // Function to search featured images
        function searchFeaturedImages() {
            const query = featuredSearch.value.trim();
            featuredCurrentQuery = query;
            featuredCurrentPage = 0; // Reset to first page when searching
            
            // Always use the available featuredImages or fallback if not available
            if (!featuredImages) {
                featuredImages = FALLBACK_FEATURED_DATA.featured;
            }
            
            // Display all or filtered images
            displayFeaturedImages(featuredImages, query);
        }
        

        function loadFeaturedImages() {
            // Display loading state first
            featuredResults.innerHTML = '<div class="text-center w-100"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Loading featured images...</p></div>';
            
            // Reset page to 0 when loading featured images
            featuredCurrentPage = 0;
            
            // If CORS is known to be blocked, use fallback data immediately
            if (corsBlocked) {
                setTimeout(() => {
                    displayFeaturedImages(FALLBACK_FEATURED_DATA.featured);
                    featuredResults.insertAdjacentHTML('beforeend', 
                        '<div class="alert alert-info mt-3">Using placeholder images. The featured image service requires server-side access.</div>'
                    );
                }, 300); // Small delay for better user experience
                return;
            }
            
            // Otherwise, make a real attempt
            fetch(FEATURED_API_ENDPOINT, {
                headers: { 'Accept': 'application/json' },
                signal: AbortSignal.timeout(3000),
                cache: 'no-store'
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`Server responded with ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                if (data && data.featured) {
                    featuredImages = data.featured;
                    displayFeaturedImages(featuredImages);
                } else {
                    throw new Error('Invalid data format');
                }
            })
            .catch(error => {
                // Mark as CORS blocked for future attempts
                corsBlocked = true;
                
                // Use fallback data
                featuredImages = FALLBACK_FEATURED_DATA.featured;
                displayFeaturedImages(featuredImages);
                
                // Show a message about using fallback
                featuredResults.insertAdjacentHTML('beforeend', 
                    '<div class="alert alert-info mt-3">Using placeholder images. The featured image service is currently unavailable.</div>'
                );
            });
        }
        
        // Function to make a single API request test
        function trySingleApiRequest() {
            // Make a single, quiet attempt to check if the API is available
            // We use a silent fetch that won't generate console errors
            const controller = new AbortController();
            const signal = controller.signal;
            
            // Set a timeout to avoid waiting too long
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            // Attempt a HEAD request to check if the endpoint exists without triggering CORS errors in console
            fetch(FEATURED_API_ENDPOINT, {
                method: 'HEAD',
                mode: 'no-cors',
                signal: signal,
                credentials: 'omit'
            }).then(() => {
                // We got a response, but because of no-cors we can't access it
                // Let's try a single attempt with regular fetch to see if CORS is actually enabled
                return fetch(FEATURED_API_ENDPOINT, {
                    credentials: 'omit',
                    cache: 'no-store',
                    signal: AbortSignal.timeout(2000)
                });
            }).then(response => {
                if (response.ok) {
                    return response.json();
                }
                // If we get here with a response that's not OK, still use fallback
                throw new Error('API returned non-OK status');
            }).then(data => {
                // If we get here, CORS is actually working!
                corsBlocked = false;
                if (data && data.featured) {
                    featuredImages = data.featured;
                }
            }).catch(() => {
                // Silently fail and keep using fallback data
                corsBlocked = true;
            }).finally(() => {
                clearTimeout(timeoutId);
            });
        }
        
        // Function to initialize featured images
        function initFeaturedImages() {
            // Immediately use fallback data - no need to try external API first
            featuredImages = FALLBACK_FEATURED_DATA.featured;
            
            // Make a single attempt to load from API
            setTimeout(function() {
                trySingleApiRequest();
            }, 500);
            
            // Always enable the Featured tab because we have fallback data
            featuredTab.classList.remove('disabled');
        }
        
        // Initialize Featured Images
        initFeaturedImages();

        // Load saved preferences
        loadSavedPreferences();
        
        // Event Listeners
        // Gradient boxes
gradientBoxes.forEach(box => {
    box.addEventListener('click', function() {
        // Remove active class from all boxes
        gradientBoxes.forEach(b => b.classList.remove('active'));
        colorBoxes.forEach(b => b.classList.remove('active'));
        
        // Add active class to the clicked box
        this.classList.add('active');
        
        // Update background gradient
        const gradient = this.getAttribute('data-gradient');
        cardPreview.style.background = gradient;
        
        // If there's a background image, remove it
        if (hasBackgroundImage) {
            cardPreview.style.backgroundImage = gradient;
            hasBackgroundImage = false;
        }
    });
});

// Event listeners for text alignment
alignLeft.addEventListener('change', function() {
  if(this.checked) {
    previewText.style.textAlign = 'left';
    savePreferences();
  }
});

alignCenter.addEventListener('change', function() {
  if(this.checked) {
    previewText.style.textAlign = 'center';
    savePreferences();
  }
});

alignRight.addEventListener('change', function() {
  if(this.checked) {
    previewText.style.textAlign = 'right';
    savePreferences();
  }
});

lineHeight.addEventListener('input', function() {
    const height = this.value;
    lineHeightValue.textContent = height;
    previewText.style.lineHeight = height;
    savePreferences();
});


// Text Customization Event Listeners
fontFamily.addEventListener('change', function() {
    previewText.style.fontFamily = this.value;
    savePreferences();
});

fontSize.addEventListener('input', function() {
    const size = this.value;
    fontSizeValue.textContent = size;
    previewText.style.fontSize = `${size}px`;
    savePreferences();
});

fontColor.addEventListener('input', function() {
    const color = this.value;
    fontColorHex.textContent = color;
    previewText.style.color = color;
    savePreferences();
});

textShadow.addEventListener('change', function() {
    previewText.style.textShadow = this.checked ? '0 2px 4px rgba(0, 0, 0, 0.5)' : 'none';
    savePreferences();
});

poweredBy.addEventListener('change', function() {
    poweredByText.style.display = this.checked ? 'block' : 'none';
    savePreferences();
});


// Add mouse events for positioning background image
cardPreview.addEventListener('mousedown', function(e) {
    if (hasBackgroundImage) {
        isDragging = true;
        dragStartX = e.clientX;
        dragStartY = e.clientY;
        
        // Get current background position
        const bgPosition = cardPreview.style.backgroundPosition;
        if (bgPosition) {
            const positions = bgPosition.split(' ');
            if (positions.length === 2) {
                initialBgPosX = parseInt(positions[0]);
                initialBgPosY = parseInt(positions[1]);
            }
        }
        
        // Change cursor to indicate draggable
        cardPreview.style.cursor = 'move';
        
        // Prevent default behavior to avoid text selection
        e.preventDefault();
    }
});

// Touch support for mobile devices
cardPreview.addEventListener('touchstart', function(e) {
    if (hasBackgroundImage && e.touches.length === 1) {
        isDragging = true;
        dragStartX = e.touches[0].clientX;
        dragStartY = e.touches[0].clientY;
        
        // Get current background position
        const bgPosition = cardPreview.style.backgroundPosition;
        if (bgPosition) {
            const positions = bgPosition.split(' ');
            if (positions.length === 2) {
                initialBgPosX = parseInt(positions[0]);
                initialBgPosY = parseInt(positions[1]);
            }
        }
        
        // Prevent default to avoid scrolling
        e.preventDefault();
    }
});

cardPreview.addEventListener('touchmove', function(e) {
    if (isDragging && hasBackgroundImage && e.touches.length === 1) {
        // Calculate how far the touch has moved
        const deltaX = e.touches[0].clientX - dragStartX;
        const deltaY = e.touches[0].clientY - dragStartY;
        
        // Convert pixel difference to percentage (relative to card size)
        const moveX = deltaX / cardPreview.offsetWidth * 100;
        const moveY = deltaY / cardPreview.offsetHeight * 100;
        
        // Move in the opposite direction of the drag
        currentBgPosX = initialBgPosX - moveX;
        currentBgPosY = initialBgPosY - moveY;
        
        // Apply the position
        cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;
        
        // Prevent default to avoid scrolling
        e.preventDefault();
    }
});

cardPreview.addEventListener('touchend', function() {
    if (isDragging) {
        isDragging = false;
        
        // Save the final position
        initialBgPosX = currentBgPosX;
        initialBgPosY = currentBgPosY;
    }
});

cardPreview.addEventListener('touchcancel', function() {
    if (isDragging) {
        isDragging = false;
    }
});

// Add a visual indicator when dragging is active
// This helps users understand they're positioning the image
document.addEventListener('mousemove', function(e) {
    if (isDragging && hasBackgroundImage) {
        // Add a class to the card preview to show it's being positioned
        cardPreview.classList.add('dragging');
        
        // Calculate how far the mouse has moved
        const deltaX = e.clientX - dragStartX;
        const deltaY = e.clientY - dragStartY;
        
        // Convert pixel difference to percentage (relative to card size)
        const moveX = deltaX / cardPreview.offsetWidth * 100;
        const moveY = deltaY / cardPreview.offsetHeight * 100;
        
        // Move in the opposite direction of the drag (to make content follow mouse)
        currentBgPosX = initialBgPosX - moveX;
        currentBgPosY = initialBgPosY - moveY;
        
        // Apply the position
        cardPreview.style.backgroundPosition = `${currentBgPosX}% ${currentBgPosY}%`;
    }
});

document.addEventListener('mouseup', function() {
    if (isDragging) {
        isDragging = false;
        cardPreview.classList.remove('dragging');
        
        // Save the final position
        initialBgPosX = currentBgPosX;
        initialBgPosY = currentBgPosY;
    }
});

// Help button
helpBtn.addEventListener('click', function() {

    window.open('https://mypoint.cards/help', '_blank');

});

// Reset button
resetBtn.addEventListener('click', function() {
    // Reset text
    cardText.value = '';
    previewText.innerText = "What's on your mind?";
    
    // Reset background to default color
    cardPreview.style.backgroundImage = 'none';
    cardPreview.style.background = '';
    cardPreview.style.backgroundColor = '#ED213A'; // Default color
    
    // Reset color selection
    colorBoxes.forEach(box => box.classList.remove('active'));
    gradientBoxes.forEach(box => box.classList.remove('active'));
    colorBoxes[0].classList.add('active'); // Select the first color box (default red)
    
    // Reset custom color picker
    customColor.value = '#ED213A';
    
    // Reset gradient colors
    gradientColor1.value = '#ff0000';
    gradientColor2.value = '#ffcc00';
    gradientDirection.value = 'to right';
    
    // Reset uploaded image if any
    imageUpload.value = '';
    uploadPreview.classList.add('d-none');
    
    // Reset giphy search
    giphySearch.value = '';
    giphyResults.innerHTML = '<div class="text-center w-100 text-muted"><p>Enter a search term and click Search to find GIFs</p></div>';
    
    // Reset featured search
    featuredSearch.value = '';
    
    // Reset background state variables
    hasBackgroundImage = false;
    backgroundImageSource = null;

    fontFamily.value = 'Roboto, sans-serif';
    previewText.style.fontFamily = 'Roboto, sans-serif';

    fontSize.value = '32';
    fontSizeValue.textContent = '32';
    previewText.style.fontSize = '32px';

    fontColor.value = '#ffffff';
    fontColorHex.textContent = '#ffffff';
    previewText.style.color = '#ffffff';

    textShadow.checked = true;
    previewText.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.5)';

    // In the resetBtn event listener, add:
    initialBgPosX = 50;
    initialBgPosY = 50;
    currentBgPosX = 50;
    currentBgPosY = 50;
    cardPreview.style.backgroundPosition = '50% 50%';


    lineHeight.value = '1.2';
    lineHeightValue.textContent = '1.2';
    previewText.style.lineHeight = '1.2';

    let textIsDragging = false;
    let textDragStartX = 0;
    let textDragStartY = 0;

    textPosX = 50;
    textPosY = 50;
    previewText.style.left = '50%';
    previewText.style.top = '50%';
    
    // Save the preferences (except for the reset text-specific items)
    savePreferences();

    hideBackgroundControls();

    cardPreview.style.backgroundImage = 'none';

    // Provide visual feedback
    showAlert('Card reset to default state!', 'info');
});

// Enhanced function to apply background image from Featured, Giphy, or Uploads
// This version creates a data URL for iOS devices when possible
function applyBackgroundImage(imageUrl, source) {
  return new Promise((resolve, reject) => {
    // Create a unique ID for this loading overlay
    const overlayId = 'bgLoadingOverlay-' + Date.now();
    
    // Set loading state
    const loadingOverlay = document.createElement('div');
    loadingOverlay.id = overlayId;
    loadingOverlay.style.position = 'absolute';
    loadingOverlay.style.top = '0';
    loadingOverlay.style.left = '0';
    loadingOverlay.style.width = '100%';
    loadingOverlay.style.height = '100%';
    loadingOverlay.style.background = 'rgba(0,0,0,0.5)';
    loadingOverlay.style.display = 'flex';
    loadingOverlay.style.justifyContent = 'center';
    loadingOverlay.style.alignItems = 'center';
    loadingOverlay.style.zIndex = '10';
    loadingOverlay.style.borderRadius = '12px';
    loadingOverlay.innerHTML = '<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading...</span></div>';
    
    cardPreview.style.position = 'relative';
    cardPreview.appendChild(loadingOverlay);
    
    // Set a timeout to prevent infinite loading
    const timeoutId = setTimeout(() => {
      // If this overlay still exists, remove it
      if (document.getElementById(overlayId)) {
        cardPreview.removeChild(loadingOverlay);
      }
      
      // Show error message
      showAlert('Image loading timed out. Please try a different image.', 'warning');
      reject(new Error('Image loading timed out'));
    }, 8000); // 8-second timeout
    
    // Pre-load the image to check if it's valid
    const img = new Image();
    img.crossOrigin = 'anonymous';
    
    img.onload = function() {
      // Clear the timeout since image loaded successfully
      clearTimeout(timeoutId);
      
      // Apply the image as background
      cardPreview.style.backgroundImage = `url(${imageUrl})`;
      cardPreview.style.backgroundSize = 'cover';
      cardPreview.style.backgroundPosition = 'center';
      
      // Update state
      hasBackgroundImage = true;
      backgroundImageSource = source;
      
      // Reset any color box selections
      colorBoxes.forEach(box => box.classList.remove('active'));
      gradientBoxes.forEach(box => box.classList.remove('active'));
      
      // Initialize position variables for dragging
      cardPreview.style.backgroundPosition = '50% 50%';
      initialBgPosX = 50;
      initialBgPosY = 50;
      currentBgPosX = 50;
      currentBgPosY = 50;
      
      // Apply the darkness overlay
      applyBackgroundDarkness();
      
      // Show background controls
      showBackgroundControls();
      
      // Update cursor style
      updateCursorStyle();
      
      // Remove loading overlay
      if (document.getElementById(overlayId)) {
        cardPreview.removeChild(loadingOverlay);
      }
      
      resolve(true);
    };
    
    img.onerror = function() {
      // Clear the timeout
      clearTimeout(timeoutId);
      
      // Remove loading overlay
      if (document.getElementById(overlayId)) {
        cardPreview.removeChild(loadingOverlay);
      }
      
      // Show error message
      showAlert('Failed to load image. Please try a different one.', 'warning');
      reject(new Error('Image failed to load'));
    };
    
    // Start loading the image
    img.src = imageUrl;
  });
}

function setupFeaturedImageHandlers() {
  // Find all featured images
  const featuredImages = document.querySelectorAll('.featured-image');
  
  featuredImages.forEach(img => {
    // Remove any existing click handlers
    const newImg = img.cloneNode(true);
    img.parentNode.replaceChild(newImg, img);
    
    // Add the new click handler
    newImg.addEventListener('click', () => {
      const imageUrl = newImg.dataset.originalUrl || newImg.src;
      
      // Use the Promise-based applyBackgroundImage
      applyBackgroundImage(imageUrl, 'featured')
        .then(() => {
          showAlert('Featured image applied as background!', 'success');
        })
        .catch(error => {
          console.error('Error applying featured image:', error);
          // The error alert is already shown in the applyBackgroundImage function
        });
    });
  });
}

// Enhanced Giphy image click handler
function setupGiphyImageHandlers() {
  // Find all giphy images
  const giphyImages = document.querySelectorAll('.giphy-image');
  
  giphyImages.forEach(img => {
    // Remove any existing click handlers
    const newImg = img.cloneNode(true);
    img.parentNode.replaceChild(newImg, img);
    
    // Add the new click handler
    newImg.addEventListener('click', async () => {
      // Get the original URL (should be stored in a data attribute)
      const originalUrl = newImg.dataset.originalUrl || newImg.src;
      await applyBackgroundImage(originalUrl, 'giphy');
      showAlert('GIF applied as background!', 'success');
    });
  });
}

function cleanupStuckOverlays() {
  // Find all loading overlays
  const overlays = cardPreview.querySelectorAll('div[id^="bgLoadingOverlay-"]');
  
  // Remove them
  overlays.forEach(overlay => {
    cardPreview.removeChild(overlay);
  });
  
  // Also check for any generic overlays without ID
  const genericOverlays = cardPreview.querySelectorAll('div[style*="background: rgba(0,0,0,0.5)"]');
  genericOverlays.forEach(overlay => {
    cardPreview.removeChild(overlay);
  });
  
  return 'Cleaned up ' + (overlays.length + genericOverlays.length) + ' stuck overlays';
}


// Listen for scale changes
bgContain.addEventListener('change', function() {
    if(this.checked && hasBackgroundImage) {
        cardPreview.style.backgroundSize = 'contain';
        cardPreview.style.backgroundRepeat = 'no-repeat'; // Ensure no-repeat is set
    }
});

bgCover.addEventListener('change', function() {
    if(this.checked && hasBackgroundImage) {
        cardPreview.style.backgroundSize = 'cover';
        cardPreview.style.backgroundRepeat = 'no-repeat'; // Ensure no-repeat is set
    }
});

bgActual.addEventListener('change', function() {
    if(this.checked && hasBackgroundImage) {
        cardPreview.style.backgroundSize = 'auto';
        cardPreview.style.backgroundRepeat = 'no-repeat'; // Ensure no-repeat is set
    }
});

// Background opacity control
bgOpacity.addEventListener('input', function() {
    const opacity = parseInt(this.value);
    bgOpacityValue.textContent = opacity;
    
    // Apply the darkness using our consistent function
    applyBackgroundDarkness();
});


// Custom gradient button
applyCustomGradient.addEventListener('click', function() {
    const color1 = gradientColor1.value;
    const color2 = gradientColor2.value;
    const direction = gradientDirection.value;
    
    // Create gradient
    const gradient = `linear-gradient(${direction}, ${color1}, ${color2})`;
    
    // Apply gradient
    cardPreview.style.background = gradient;
    
    // Remove active class from all boxes
    gradientBoxes.forEach(b => b.classList.remove('active'));
    colorBoxes.forEach(b => b.classList.remove('active'));
    
    // If there's a background image, remove it
    if (hasBackgroundImage) {
        hasBackgroundImage = false;
    }
    
    // Visual feedback
    showAlert('Custom gradient applied!', 'success');
});

        
        // Text input
        cardText.addEventListener('input', function() {
            // Using textContent would lose the line breaks
            // Using innerHTML would be a security risk
            // Using innerText properly preserves the line breaks
            previewText.innerText = this.value || "What's on your mind?";
        });
        
        // Color boxes
        colorBoxes.forEach(box => {
            box.addEventListener('click', function() {
                // Remove active class from all boxes
                colorBoxes.forEach(b => b.classList.remove('active'));
                if (gradientBoxes) {
                    gradientBoxes.forEach(b => b.classList.remove('active'));
                }
                
                // Add active class to the clicked box
                this.classList.add('active');
                
                // Clear any gradient backgrounds first
                cardPreview.style.background = '';
                
                // Update background color
                const color = this.getAttribute('data-color');
                cardPreview.style.backgroundColor = color;
                customColor.value = color;
                
                // If there's a background image, remove it
                if (hasBackgroundImage) {
                    cardPreview.style.backgroundImage = 'none';
                    hasBackgroundImage = false;
                }
            });
        });
        
        // Custom color picker
        customColor.addEventListener('input', function() {
            // Clear any gradient backgrounds first
            cardPreview.style.background = '';
            
            // Set the solid background color
            cardPreview.style.backgroundColor = this.value;
            
            // Remove active class from all color boxes and gradient boxes
            colorBoxes.forEach(box => box.classList.remove('active'));
            if (gradientBoxes) {
                gradientBoxes.forEach(box => box.classList.remove('active'));
            }
            
            // If there's a background image, remove it
            if (hasBackgroundImage) {
                cardPreview.style.backgroundImage = 'none';
                hasBackgroundImage = false;
                backgroundImageSource = null;
            }
        });
        
        // Emoji clicks
        emojis.forEach(emoji => {
            emoji.addEventListener('click', function() {
                // Add emoji at cursor position or at the end
                const cursorPos = cardText.selectionStart;
                const textBefore = cardText.value.substring(0, cursorPos);
                const textAfter = cardText.value.substring(cursorPos);
                cardText.value = textBefore + this.textContent + textAfter;
                
                // Update preview
                previewText.innerText = cardText.value;
                
                // Return focus to textarea and place cursor after inserted emoji
                cardText.focus();
                cardText.selectionStart = cursorPos + this.textContent.length;
                cardText.selectionEnd = cursorPos + this.textContent.length;
            });
        });
        
        // Enhanced version of the image upload handler with improved iOS support
        imageUpload.addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (file) {
            // Show a loading indicator
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'uploadLoadingOverlay';
            loadingOverlay.style.position = 'absolute';
            loadingOverlay.style.top = '0';
            loadingOverlay.style.left = '0';
            loadingOverlay.style.width = '100%';
            loadingOverlay.style.height = '100%';
            loadingOverlay.style.background = 'rgba(0,0,0,0.5)';
            loadingOverlay.style.display = 'flex';
            loadingOverlay.style.justifyContent = 'center';
            loadingOverlay.style.alignItems = 'center';
            loadingOverlay.style.zIndex = '10';
            loadingOverlay.style.borderRadius = '12px';
            loadingOverlay.innerHTML = '<div class="spinner-border text-light" role="status"><span class="visually-hidden">Loading image...</span></div>';
            
            cardPreview.style.position = 'relative';
            cardPreview.appendChild(loadingOverlay);
            
            try {
              // Check if this is iOS Safari
              const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
              const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
              const isIOSSafari = isIOS && isSafari;
              
              // Create a data URL from the file
              const reader = new FileReader();
              
              // Use a promise to wait for the file to be read
              const dataUrl = await new Promise((resolve, reject) => {
                reader.onload = function(event) {
                  resolve(event.target.result);
                };
                reader.onerror = function(error) {
                  reject(error);
                };
                reader.readAsDataURL(file);
              });
              
              // Show the thumbnail preview
              uploadedImage.src = dataUrl;
              uploadPreview.classList.remove('d-none');
              
              // Set as background image
              cardPreview.style.backgroundImage = `url(${dataUrl})`;
              cardPreview.style.backgroundSize = 'contain';
              cardPreview.style.backgroundPosition = 'center';
              cardPreview.style.backgroundRepeat = 'no-repeat';
              
              // Update the state variables
              hasBackgroundImage = true;
              backgroundImageSource = 'upload';
              
              // Reset position to center
              cardPreview.style.backgroundPosition = '50% 50%';
              initialBgPosX = 50;
              initialBgPosY = 50;
              currentBgPosX = 50;
              currentBgPosY = 50;
              
              // Apply the darkness overlay
              applyBackgroundDarkness();
              
              // Update cursor style
              updateCursorStyle();
              
              // Show background controls
              showBackgroundControls();
              
              // Select appropriate scaling option
              if (isIOSSafari) {
                // For iOS Safari, 'contain' mode tends to work better
                bgContain.checked = true;
              }
              
              showAlert('Image uploaded successfully!', 'success');
            } catch (error) {
              console.error('Error handling image upload:', error);
              showAlert('Error uploading image. Please try again.', 'warning');
            } finally {
              // Remove loading overlay
              if (document.getElementById('uploadLoadingOverlay')) {
                cardPreview.removeChild(loadingOverlay);
              }
            }
          }
        });

        // Remove uploaded image
        removeImage.addEventListener('click', function() {
            // Clear the file input
            imageUpload.value = '';
            
            // Hide the preview
            uploadPreview.classList.add('d-none');
            
            // Remove background image
            cardPreview.style.backgroundImage = 'none';
            hasBackgroundImage = false;
            backgroundImageSource = null;
            
            // Reset to the active color
            const activeColorBox = document.querySelector('.color-box.active');
            if (activeColorBox) {
                cardPreview.style.backgroundColor = activeColorBox.getAttribute('data-color');
            } else {
                cardPreview.style.backgroundColor = customColor.value;
            }
            
            hideBackgroundControls();

            // Visual feedback
            showAlert('Image removed!', 'info');
        });
        

        // This function will handle temporary style changes during image generation
        // to ensure proper transparency
        function prepareCardForExport() {
        // Save original styles
        const originalBorderRadius = cardPreview.style.borderRadius;
        const originalBoxShadow = cardPreview.style.boxShadow;
        const originalBorder = cardPreview.style.border;

        // Temporarily remove any rounded corners, border or shadow that might affect transparency
        cardPreview.style.borderRadius = '0';
        cardPreview.style.boxShadow = 'none';
        cardPreview.style.border = 'none';

        return function restoreStyles() {
            // Restore original styles
            cardPreview.style.borderRadius = originalBorderRadius;
            cardPreview.style.boxShadow = originalBoxShadow;
            cardPreview.style.border = originalBorder;
        };
        }



        // Giphy Search
        searchGiphyBtn.addEventListener('click', () => searchGiphy(0)); // Start fresh search
        giphySearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchGiphy(0); // Start fresh search
            }
        });
        
        // Enhanced function to display Giphy results
        function displayGiphyResults(gifs, addPagination = false) {
          giphyResults.innerHTML = '';
          
          if (!gifs || gifs.length === 0) {
            giphyResults.innerHTML = '<div class="alert alert-info">No GIFs found. Try another search term.</div>';
            return;
          }
          
          // Create a container for the grid
          const gridContainer = document.createElement('div');
          gridContainer.className = 'giphy-grid';
          gridContainer.style.display = 'grid';
          gridContainer.style.gridTemplateColumns = 'repeat(3, 1fr)'; // Exactly 3 columns
          gridContainer.style.gap = '10px';
          gridContainer.style.marginBottom = '15px';
          
          // Display up to 9 GIFs (3x3 grid)
          const gifsToShow = gifs.slice(0, 9);
          
          gifsToShow.forEach(gif => {
            try {
              const imgContainer = document.createElement('div');
              imgContainer.style.display = 'flex';
              imgContainer.style.justifyContent = 'center';
              imgContainer.style.alignItems = 'center';
              
              const img = document.createElement('img');
              img.src = gif.images.fixed_height_small.url;
              img.alt = gif.title || 'Giphy image';
              img.className = 'giphy-image';
              
              // Store the original image URL as a data attribute
              img.dataset.originalUrl = gif.images.original.url;
              
              img.style.width = '120px';
              img.style.height = '120px';
              img.style.objectFit = 'cover';
              img.style.cursor = 'pointer';
              img.style.borderRadius = '8px';
              img.style.transition = 'transform 0.2s, box-shadow 0.2s';
              img.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
              
              img.addEventListener('mouseover', () => {
                img.style.transform = 'scale(1.05)';
                img.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
                img.style.zIndex = '1';
              });
              
              img.addEventListener('mouseout', () => {
                img.style.transform = 'scale(1)';
                img.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                img.style.zIndex = 'auto';
              });
              
              img.addEventListener('click', async () => {
                await applyBackgroundImage(gif.images.original.url, 'giphy');
                showAlert('GIF applied as background!', 'success');
              });
              
              imgContainer.appendChild(img);
              gridContainer.appendChild(imgContainer);
            } catch (err) {
              console.warn('Error displaying GIF:', err);
            }
          });
          
          // Fill any empty spots in the grid with placeholder divs to maintain 3x3 layout
          const emptySpots = 9 - gifsToShow.length;
          for (let i = 0; i < emptySpots; i++) {
            const emptyDiv = document.createElement('div');
            emptyDiv.style.width = '120px';
            emptyDiv.style.height = '120px';
            gridContainer.appendChild(emptyDiv);
          }
          
          giphyResults.appendChild(gridContainer);
          
          // Add pagination controls if needed
          if (addPagination) {
            const paginationContainer = document.createElement('div');
            paginationContainer.className = 'd-flex justify-content-center mt-3';
            
            const pagination = document.createElement('nav');
            pagination.setAttribute('aria-label', 'Giphy results pages');
            
            const pageList = document.createElement('ul');
            pageList.className = 'pagination';
            
            // Previous button
            const prevItem = document.createElement('li');
            prevItem.className = `page-item ${giphyCurrentPage === 0 ? 'disabled' : ''}`;
            
            const prevLink = document.createElement('a');
            prevLink.className = 'page-link';
            prevLink.href = '#';
            prevLink.innerHTML = '&laquo; Previous';
            prevLink.id = 'giphyPrevPage';
            
            prevItem.appendChild(prevLink);
            pageList.appendChild(prevItem);
            
            // Current page info
            const pageInfoItem = document.createElement('li');
            pageInfoItem.className = 'page-item';
            
            const pageInfoSpan = document.createElement('span');
            pageInfoSpan.className = 'page-link';
            pageInfoSpan.textContent = `Page ${giphyCurrentPage + 1} of ${Math.min(giphyMaxPages, Math.ceil(giphyTotalResults.length / 9) || 1)}`;
            
            pageInfoItem.appendChild(pageInfoSpan);
            pageList.appendChild(pageInfoItem);
            
            // Next button
            const nextItem = document.createElement('li');
            nextItem.className = `page-item ${giphyCurrentPage >= giphyMaxPages - 1 || gifsToShow.length < 9 ? 'disabled' : ''}`;
            
            const nextLink = document.createElement('a');
            nextLink.className = 'page-link';
            nextLink.href = '#';
            nextLink.innerHTML = 'Next &raquo;';
            nextLink.id = 'giphyNextPage';
            
            nextItem.appendChild(nextLink);
            pageList.appendChild(nextItem);
            
            pagination.appendChild(pageList);
            paginationContainer.appendChild(pagination);
            giphyResults.appendChild(paginationContainer);
            
            // Add event listeners for pagination buttons
            const prevButton = document.getElementById('giphyPrevPage');
            const nextButton = document.getElementById('giphyNextPage');
            
            if (prevButton) {
              prevButton.addEventListener('click', (e) => {
                e.preventDefault();
                if (giphyCurrentPage > 0) {
                  giphyCurrentPage--;
                  searchGiphy(giphyCurrentPage);
                }
              });
            }
            
            if (nextButton) {
              nextButton.addEventListener('click', (e) => {
                e.preventDefault();
                if (giphyCurrentPage < giphyMaxPages - 1 && gifsToShow.length === 9) {
                  giphyCurrentPage++;
                  searchGiphy(giphyCurrentPage);
                }
              });
            }
          }
        }

        function searchGiphy(page = 0) {
            const query = giphySearch.value.trim();
            
            // If it's a new search (page 0) or a different query
            if (page === 0 || query !== giphyCurrentQuery) {
                giphyCurrentQuery = query;
                giphyCurrentPage = 0;
                giphyTotalResults = [];
            }
            
            if (!query) {
                // Replace alert with inline error message
                giphyResults.innerHTML = '<div class="alert alert-warning">Please enter a search term</div>';
                return;
            }
            
            // Show loading indicator
            giphyResults.innerHTML = '<div class="text-center w-100"><div class="spinner-border text-primary" role="status"><span class="visually-hidden">Loading...</span></div><p class="mt-2">Searching for GIFs...</p></div>';
            
            // Calculate offset for pagination (which results to start from)
            const offset = page * 9; // Now we want 9 results per page for 3x3 grid
            
            // If we already have these results cached, use them
            if (giphyTotalResults.length > offset) {
                displayGiphyResults(giphyTotalResults.slice(offset, offset + 9), true);
                return;
            }
            
            // Fetch more GIFs from Giphy API
            const limit = 9 * (giphyMaxPages - page);
            
            fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(query)}&limit=${limit}&offset=${offset}&rating=g`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Network response was not ok: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Cache all results
                    giphyTotalResults = giphyTotalResults.concat(data.data);
                    
                    // But only display the current page (9 results)
                    displayGiphyResults(data.data.slice(0, 9), true);
                })
                .catch(error => {
                    console.error('Error fetching from Giphy:', error);
                    giphyResults.innerHTML = '<div class="alert alert-danger">Error fetching GIFs. Please try again or check your internet connection.</div>';
                });
        }
                
        // Featured tab click handler - optimized to avoid CORS errors
        featuredTab.addEventListener('click', function() {
            // If we already have featured images, just display them
            if (featuredImages) {
                displayFeaturedImages(featuredImages);
            } else {
                // Otherwise, try to load them (but only once since we know there are CORS issues)
                loadFeaturedImages();
            }

            setTimeout(updateFeaturedImageHandlers, 500);
            setTimeout(setupFeaturedImageHandlers, 500);
        });
        
        searchFeaturedBtn.addEventListener('click', searchFeaturedImages);
        featuredSearch.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchFeaturedImages();
            }


        });
        
        function initFeaturedImages() {
            // Immediately use fallback data - no need to try external API first
            featuredImages = FALLBACK_FEATURED_DATA.featured;
            
            // Make a single attempt to load from API
            setTimeout(function() {
                trySingleApiRequest();
            }, 500);
            
            // Always enable the Featured tab because we have fallback data
            featuredTab.classList.remove('disabled');
        }
        
        function trySingleApiRequest() {
            // Make a single, quiet attempt to check if the API is available
            // We use a silent fetch that won't generate console errors
            const controller = new AbortController();
            const signal = controller.signal;
            
            // Set a timeout to avoid waiting too long
            const timeoutId = setTimeout(() => controller.abort(), 2000);
            
            // Attempt a HEAD request to check if the endpoint exists without triggering CORS errors in console
            fetch(FEATURED_API_ENDPOINT, {
                method: 'HEAD',
                mode: 'no-cors',
                signal: signal,
                credentials: 'omit'
            }).then(() => {
                // We got a response, but because of no-cors we can't access it
                // Let's try a single attempt with regular fetch to see if CORS is actually enabled
                return fetch(FEATURED_API_ENDPOINT, {
                    credentials: 'omit',
                    cache: 'no-store',
                    signal: AbortSignal.timeout(2000)
                });
            }).then(response => {
                if (response.ok) {
                    return response.json();
                }
                // If we get here with a response that's not OK, still use fallback
                throw new Error('API returned non-OK status');
            }).then(data => {
                // If we get here, CORS is actually working!
                corsBlocked = false;
                if (data && data.featured) {
                    featuredImages = data.featured;
                }
            }).catch(() => {
                // Silently fail and keep using fallback data
                corsBlocked = true;
            }).finally(() => {
                clearTimeout(timeoutId);
            });
        }



    
    // Check for saved theme preference or use system preference
    function initTheme() {
        const savedTheme = localStorage.getItem('mypointcardsTheme');
        
        if (savedTheme) {
            // Apply saved preference
            htmlElement.setAttribute('data-bs-theme', savedTheme);
            themeSwitch.checked = savedTheme === 'dark';
        } else {
            // Check system preference
            const prefersDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDarkMode) {
                htmlElement.setAttribute('data-bs-theme', 'dark');
                themeSwitch.checked = true;
            }
        }
    }
    
    // Toggle theme when switch is clicked
    themeSwitch.addEventListener('change', function() {
        const theme = this.checked ? 'dark' : 'light';
        htmlElement.setAttribute('data-bs-theme', theme);
        localStorage.setItem('mypointcardsTheme', theme);
    });
    
    
    // Add the cleanup function to the window to make it accessible from the console
    window.cleanupStuckOverlays = cleanupStuckOverlays;
 
    </script>
